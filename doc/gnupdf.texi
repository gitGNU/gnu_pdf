\input texinfo
@comment $Id: gnupdf.texi,v 1.27 2008/02/22 19:37:56 gerel Exp $
@comment %**start of header
@setfilename gnupdf.info
@settitle GNU PDF Library Reference
@comment %**end of header

@set EDITION first
@set VERSION 0.1

@copying 
This is the @strong{@value{EDITION}} edition of the @cite{GNU PDF Library
Reference}, updated for @strong{libgnupdf} version @strong{@value{VERSION}}.

Copyright @copyright{} 2007, 2008 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Software libraries
@direntry
* gnupdf: (gnupdf).             The GNU PDF Library reference.
@end direntry

@titlepage
@sp 6
@center @titlefont{GNU PDF Library Reference}
@sp 4
@center @value{EDITION} Edition, Updated for version @value{VERSION}.
@sp 5
@center Jos@'e E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU PDF Library Reference

GNU PDF Library Reference

@insertcopying
@end ifnottex

@menu
* Overview::            The GNU PDF library in brief.
* Base Layer::          Base library facilities.
* Object Layer::        Editing the object structure of a PDF file.
* Document Layer::      Editing the document-level structure of a PDF
                          file.
* Page Contents Layer::  Editing the contents of pages.
* GNU Free Documentation License::  Distribution terms of this manual.

Indices

* Global variable index::       
* Data type index::             
* Function index::              
@end menu

@node Overview
@chapter Overview

@node Base Layer
@chapter Base Layer

@menu
* Base Layer Overview::
* Error Management::
* Memory Allocation::
* Basic Types::
* Hash Tables::
* Lists::
* Filtered Streams::
* Floating Point Arithmetic::
* Encoded Text::
* Time Management::
* Accessing the File System::
@end menu

@node Base Layer Overview
@section Overview

The base layer of the GNU PDF Library provide system-independent
access to several facilities.

The implemented facilities are organized into modules. Each module
export an API to be used by the client application or other layers of
the library. Some modules make use of the facilities implemented in
other modules (such as allocation or error functions).

@node Error Management
@section Error Management


The Error module provides procedures for error reporting to the
client as well as for error tracing (via debug messages) to
developers. Here we also define status types returned by most
procedures (there are exceptions though).

@menu
* Status types::
* Error Reporting procedures::
* Debugging procedures::
@end menu

@node Status types
@subsection Status types

@deftp {Data Type} pdf_status_t
A status variable. This type of variable is returned by many library
functions in order to communicate the status of the performed
operation.
@end deftp

The following constants defines the valid values to be hold in a
@code{pdf_status_t} variable:

@deftp {Constant} PDF_OK
Success
@end deftp

@deftp {Constant} PDF_ERROR
A serious error
@end deftp

@deftp {Constant} PDF_EBADDATA
Invalid or bad arguments
@end deftp

@deftp {Constant} PDF_ENOMEM
Insufficient memory
@end deftp

@deftp {Constant} PDF_EEOF
End of file
@end deftp

@deftp {Constant} PDF_EDIVBYZERO
Divison by zero
@end deftp

@deftp {Constant} PDF_ENONODE
No node found
@end deftp

@deftp {Constant} PDF_EINVRANGE
Invalid range
@end deftp

@deftp {Constant} PDF_ETEXTENC
Error in text encoding
@end deftp

@deftp {Constant} PDF_ENOMATCH 
No matching found
@end deftp

This list will grow as we get closer to a mature state of development.


@node Error Reporting procedures
@subsection Error Reporting procedures

@deftypefun void pdf_perror (pdf_status_t @var{status}, const char *@var{str})

Prints the message corresponding to @var{status} to stderr followed by @var{str}.

@table @strong
@item Parameters
@table @var
@item status
status code
@item str
a user-defined message
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

st = pdf_i64_add (dest, addend_1, addend_2);

if (st != PDF_OK)
@{
        pdf_perror (st, "Couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_error (pdf_status_t @var{status}, FILE *@var{fd}, const char *@var{format}, @var{...})

Prints a message with `fprintf (@var{fd}, @var{format}, ...)'; 
if @var{status} is nonzero, also prints the corresponding message.

@table @strong
@item Parameters
@table @var
@item status
status code
@item fd
file descriptor open for writing
@item format
string format for the message
@item ...
format's arguments
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

st = pdf_i64_add (dest, addend_1, addend_2);

if (st != PDF_OK)
@{
        pdf_error (st, logfd, "Couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun

@node Debugging procedures
@subsection Debugging procedures

For each layer there is a macro procedure defined. The file name and
the line number at which the error ocurred is printed to stderr
followed by @var{message}.

@defmac PDF_DEBUG_BASE (message, ...)
@end defmac
@defmac PDF_DEBUG_OBJECT (message, ...)
@end defmac
@defmac PDF_DEBUG_DOCUMENT (message, ...)
@end defmac
@defmac PDF_DEBUG_PAGE (message, ...)
@end defmac

@table @strong
@item Parameters
@table @var
@item message
a 'const char*' string
@item ...
message's arguments
@end table
@item Returns
nothing
@item Usage example
@example
PDF_DEBUG_BASE("Testing macro '%s' '%d' '%lf'", "string", 7, 10.1);
@end example
@end table

@heading Output format
The output format for these macros is,

GNU PDF:***DEBUG <layer>***:<file-name>:<line-number>: <message>.

For example,

GNU PDF:***DEBUG BASE***:pdf-memory.c:344: insufficient memory.

@node Memory Allocation
@section Memory Allocation

The memory allocation module provides system-independent heap memory
allocation and deallocation. The usual malloc/free/realloc schema is
used to provide this service.

@deftypefun char* pdf_alloc (int @var{size})

Allocates heap memory.

@table @strong
@item Parameters

@table @var
@item size
The requested number of octects to allocate.
@end table

@item Returns
A pointer to the newly allocated memory. 

If there is not enough available memory to satisfy the petition then
@code{NULL} is returned.
@item Usage example
@example
int *p;

p = (int *) pdf_alloc (sizeof(int));
p = 666;
@end example
@end table
@end deftypefun

@deftypefun void pdf_dealloc (char *@var{pointer})

Deallocates heap memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer pointing to the memory we want to deallocate. The memory to
deallocate should have been previously allocated using
@code{pdf_alloc}.
@end table

@item Returns
None.
@item Usage Example

@example
char *p;

p = (char *) pdf_alloc (21);
pdf_dealloc (p);
@end example
@end table
@end deftypefun

@deftypefun char* pdf_realloc (char *@var{pointer}, int @var{size})

Reallocates memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer to previously allocated memory. 

The memory to reallocate should have been allocated using
@code{pdf_alloc} or @code{pdf_realloc}.
@item size
The new size of the allocated memory chunk. 

If the requested size is shorter than the original size of the
allocated memory then it is truncated. Any previous contents in the
memory will be lost.

If the requested size is larger or equal than the original size of the
allocated memory then the previous contents of the allocated memory
remains. The contents of newly allocated memory are undetermined.

If there is not enough available memory to satisfy the petition a
fatal error is signaled killing the current process. An error status
is returned to the operating system.
@end table

@item Returns
A pointer to the reallocated memory.
@item Usage Example
@example
char *p;

p = (char *) pdf_alloc (4);
strncpy (p, "abcd", 4);

/* p now points to "abcd" */

p = (char *) pdf_realloc (5);
p[4] = 'e';

/* p now points to "abcde" */

p = (char *) pdf_realloc (4);

/* p now points to "abcd" */

pdf_dealloc (p);
@end example
@end table
@end deftypefun

@node Basic Types
@section Basic Types

@menu
* Boolean Types::
* Numeric Types::
* Big Numbers::
@end menu

@node Boolean Types
@subsection Boolean Types

@deftp {Data Type} pdf_bool_t
A boolean value.
@end deftp

The following constants defines the valid values to be hold in a
@code{pdf_bool_t} variable:

@deftp {Constant} PDF_TRUE
Logical true.
@end deftp

@deftp {Constant} PDF_FALSE
Logical false.
@end deftp

@node Numeric Types
@subsection Numeric Types

@deftp {Data Type} pdf_i32_t
Signed 32 bits integer.
@end deftp

@deftp {Data Type} pdf_u32_t
Unsigned 32 bits integer.
@end deftp

The following constants are defined in order to define the valid value
ranges for these data types:

@deftp {Constant} PDF_I32_MAX
Maximum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_I32_MIN
Minimum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MAX
Maximum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MIN
Minimum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@node Big Numbers
@subsection Big Numbers

An implementation of Big numbers (64 bit) is also provided. These
bignums can be used in machines not providing true 64 bit integers.

@deftp {Data Type} pdf_i64_t
A variable of type pdf_i64_t is capabable of representing 64 bit signed integers.
@end deftp

@deftypefun pdf_i64_t  pdf_i64_new (pdf_i32_t @var{high}, pdf_u32_t @var{low})

Create a new i64 variable from one 32 bit signed integer and a 32 bit unsigned integer.

@table @strong
@item Parameters
@table @var
@item high
The high (signed) part of the 64 bit integer.
@item low
The low (unsigned) part of the 64 bit integer.
@end table
@item Returns
The newly created i64 object.
@item Usage example
@example
pdf_i64_t bignum;

bignum = pdf_i64_new((32 << 1),10); /*bignum is now -10*/
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_assign (pdf_i64_t *@var{bignum}, pdf_i32_t @var{high}, pdf_u32_t @var{low})

Assign a value coming from one 32 bit signed integer and a 32 bit unsigned integer to a  i64 integer.

@table @strong
@item Parameters
@table @var
@item high
The high (signed) part of the 64 bit integer.
@item low
The low (unsigned) part of the 64 bit integer.
@item bignum
Variable that stores 64 bit integer
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *bignum;
pdf_i64_t result;

result = pdf_i64_new(0, 0);
bignum = &result;

if (pdf_i64_assign(bignum, (32 << 1), 10) != PDF_OK) /*bignum is now -10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_assign_quick (pdf_i64_t *@var{bignum}, pdf_i32_t @var{value})

Assign a value coming from one 32 bit signed integer to a  i64 integer.

@table @strong
@item Parameters
@table @var
@item value
A signed 32 bit integer
@item bignum
Variable that stores 64 bit integer
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *bignum;
pdf_i64_t result;

result = pdf_i64_new(0, 0);
bignum = &result;
if (pdf_i64_assign_quick(bignum, -10) != PDF_OK) /*bignum is now -10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun	

@deftypefun pdf_status_t pdf_i64_copy (pdf_i64_t @var{orig}, pdf_i64_t *@var{copy})

Copies the data from orig to copy.

@table @strong
@item Parameters
@table @var
@item orig
Original variable whose data is to be copied.
@item copy
Variable where data is copied to.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t orig;
pdf_i64_t *copy;

orig = pdf_i64_new(0, 10);
if (pdf_i64_copy(orig, copy) != PDF_OK) /*Now copy is also 10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_add (pdf_i64_t *@var{dest}, pdf_i64_t @var{addend_1}, pdf_i64_t @var{addend_2})

Adds two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item addend_1
First addend of the sum
@item addend_2
Second addend of the sum
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t addend_1;
pdf_i64_t addend_2;

addend_1 = pdf_i64_new(0, 25);
addend_2 = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_add (dest, addend_1, addend_2) != PDF_OK) /* Now dest is 60 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_subtraction (pdf_i64_t *@var{dest}, pdf_i64_t @var{minuend}, pdf_i64_t @var{subtrahend})

Finds the difference between two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item minuend
The minuend of the subtraction
@item subtrahend
The subtrahend of the subtraction
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t minuend;
pdf_i64_t subtrahend;

minuend = pdf_i64_new(0, 25);
subtrahend = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_subtraction (dest, minuend, subtrahend) != PDF_OK) /* Now dest is -10 */
@{
  /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_mult (pdf_i64_t *@var{dest}, pdf_i64_t @var{factor_1}, pdf_i64_t @var{factor_2})

Multiplication of two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item factor_1
First factor in the multiplication
@item factor_2
Second factor in the multiplication
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t factor_1;
pdf_i64_t factor_2;

factor_1 = pdf_i64_new (0, 10);
factor_2 = pdf_i64_new (0, 100);
result = pdf_i64_new (0, 0);
dest = &result;

if (pdf_i64_mult (dest, factor_1, factor_2) != PDF_OK) /* Now dest is 1000 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_div (pdf_i64_t *@var{dest}, pdf_i64_t @var{dividend}, pdf_i64_t @var{divisor})

Division of two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division
@item divisor
The divisor in the division
@item dest
Where 64 bit result is stored
@end table
@item Returns
PDF_OK	Operation successful
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;
pdf_i64_t divisor;

dividend = pdf_i64_new(0, 200);
divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_div (dest, dividend, divisor) != PDF_OK) /* Now dest is 20 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_i64_mod (pdf_i64_t *@var{dest}, pdf_i64_t @var{dividend}, pdf_i64_t @var{divisor})

Returns the remainder of the division between two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division
@item divisor
The divisor in the division
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;
pdf_i64_t divisor;

dividend = pdf_i64_new(0, 105);
divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_mod (dest, dividend, divisor) != PDF_OK) /* Now dest is 5 */
@{
   /* Error code */
@}	
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_abs (pdf_i64_t *@var{dest}, pdf_i64_t @var{number})

Returns the absolute value

@table @strong
@item Parameters
@table @var
@item number
pdf_i64_t type variable
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i65_t result;
pdf_i64_t number;

number = pdf_i64_new ((32 << 1), 105); /*number is -105*/
result = pdf_i64_new (0, 0);
dest = &result;

if (pdf_i64_abs (dest, number) != PDF_OK) /* now dest stores 105 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun int pdf_i64_cmp (pdf_i64_t @var{number_1}, pdf_i64_t @var{number_2})

Compares two 64 bit integers

@table @strong
@item Parameters
@table @var
@item number_1
pdf_i64_t type variable
@item number_2
pdf_i64_t type variable
@end table
@item Returns
An integer:
@table @code
@item 0
If numbers are equal
@item 1
If @var{number_1} is greater than @var{number_2}
@item -1
If @var{number_2} is greater than @var{number_1}
@end table
@item Usage example
@example
pdf_i65_t number_1;
pdf_i64_t number_2;
int result;

number_1 = pdf_i64_new ((32 << 1), 10); /* number_1 is -10 */
number_2 = pdf_i64_new (0, 10); /* number_2 is 10 */
result = pdf_i64_cmp (number_1, number_2); /* Now result is -1 */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_i64_neg (pdf_i64_t *@var{dest}, pdf_i64_t @var{number})

Changes sign of 64 bit integer

@table @strong
@item Parameters
@table @var
@item number
pdf_i64_t type variable
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i65_t result;
pdf_i64_t number;

number = pdf_i64_new (0, 10);
result = pdf_i64_new (0, 0);
dest = &result;

if (pdf_i64_neg (dest, number) != PDF_OK) /* now dest stores -10 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@node Hash Tables
@section Hash Tables

@menu
* Hash Table Types::
* Creating and Destroying Hash Tables::
@end menu

@node Hash Table Types
@subsection Hash Table Types

@deftp {Data Type} {enum pdf_hash_value_type_e}

Enumeration of supported value types in a hash variable:

@table @code
@item PDF_HASH_VAL_BOOL
@item PDF_HASH_VAL_U32
@item PDF_HASH_VAL_I32
@item PDF_HASH_VAL_REAL
@item PDF_HASH_VAL_STR
@item PDF_HASH_VAL_TEXT
@item PDF_HASH_VAL_HASH
@item PDF_HASH_VAL_LIST
@end table
@end deftp

@deftp {Data Type} pdf_hash_t

A Hash Table able to store key/value pairs. A key may be any
NULL-terminated string.
@end deftp

@node Creating and Destroying Hash Tables
@subsection Creating and Destroying Hash Tables


@node Lists
@section Lists

@menu
* List Data Types::
* Creating and Destroying Lists::
* Managing List Properties::
* Searching for List Elements::
* Setting and Getting List Elements::
* Adding and Removing List Elements::
* Working with Iterators::
@end menu

@node List Data Types
@subsection List Data Types

@deftp {Data Type} pdf_list_t
A list composed by zero or more nodes.
@end deftp

@deftp {Data Type} pdf_list_node_t
A list node. Each node is able to contain a data structure via a void
npointer.
@end deftp

@deftp {Data Type} pdf_list_iterator_t
A list iterator.
@end deftp

@deftp {Data Type} pdf_list_element_equals_fn_t
A function for comparing list elements.
@end deftp

@deftp {Data Type} pdf_list_element_dispose_fn_t
A function for disposing list elements.
@end deftp

@node Creating and Destroying Lists
@subsection Creating and Destroying Lists

@deftypefun pdf_list_t pdf_list_create (pdf_list_element_equals_fn_t @var{equals_fn}, pdf_list_element_dipose_fn_t @var{dispose_fn}, pdf_bool_t @var{allow_duplicates})

Create a new list containing no elements.

@table @strong
@item Parameters
@table @var
@item equals_fn
A function to compare list elements. 
It is used in sort operations.
@item dispose_fn
A function to dispose list elements.
It is used when destroying list elements.
@item allow_duplicates
This parameter indicate if the list is allowed to contain duplicate
elements (elements for which @var{equals_fn} evaluate to
@code{PDF_TRUE}). 
@end table
@item Returns
The newly created list.
@item Usage example
@example
pdf_list_t mylist;

mylist = pdf_list_create (list_element_equal_p, list_element_destroy, PDF_FALSE);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_destroy (pdf_list_t @var{list})

Destroy a list freeing all used resources. 
The elements of the list are disposed first.

@table @strong
@item Parameters
@table @var
@item list
The list to be destroyed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_list_t mylist;

/* ...create `mylist'... */

pdf_list_destroy (mylist);
@end example
@end table
@end deftypefun

@node Managing List Properties
@subsection Managing List Properties

@deftypefun pdf_size_t pdf_list_size (pdf_list_t @var{list})

Get the number of elements contained into a given list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@end table
@item Returns
The number of elements inside @var{list}.
@item Usage example
@example
pdf_list_t mylist;
pdf_size_t num_elm;

/* ...insert some elements into `mylist'... */
num_elm = pdf_list_size (mylist);
@end example
@end table
@end deftypefun

@node Searching for List Elements
@subsection Searching for List Elements

@deftypefun pdf_list_node_t pdf_list_search (pdf_list_t @var{list}, const void* @var{element})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to search for.
@end table
@item Returns
The searched node if found, or @code{NULL} if not present in the
list.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_node_t pdf_list_search_from (pdf_list_t @var{list}, pdf_size_t @var{start_index}, const void* @var{element})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index indicating the begin of the search.
@end table
@item Returns
The searched node if found, or NULL if not present in the list.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_node_t pdf_list_search_from_to (pdf_list_t @var{list}, pdf_size_t @var{start_index}, pdf_size_t @var{end_index}, const void* @var{element})

Search whether an element is already in the list, at a position >=
@var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index to the first list position to be searched.
@item end_index
Index to the last list position to be searched.
@item element
The element to search for.
@end table
@item Returns
The node if found, or @code{NULL} if not present in the list.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_node_t pdf_list_next_node (pdf_list_t @var{list}, pdf_list_node_t @var{node})

Return the node immediately after the given node in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@end table
@item Returns
The node immediately after the given node in the list, or @code{NULL}
if the given node is the last (rightmost) one in the list.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_node_t pdf_list_previous_node (pdf_list_t @var{list}, pdf_list_node_t @var{node})

Return the node immediately before the given node in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@end table
@item Returns 
The node immediately before the given node in the list, or @code{NULL}
if the given node is the first (leftmost) one in the list.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_indexof (pdf_list_t @var{list}, const void* @var{element})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to user data.
@end table
@item Returns
The position of @var{element} if found, or @code{(pdf_size_t)(-1)} if
not present in the list.
@item Usage Example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_indexof_from (pdf_list_t @var{list}, pdf_size_t @var{start_index}, const void* @var{element})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
An index to a position in @var{list}.
@item element
The element to search for.
@end table
@item Returns
The position of the element containing @var{element} if found, or
@code{(size_t)(-1)} if not present in the list.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_indexof_from_to (pdf_list_t @var{list}, pdf_size_t @var{start_index}, pdf_size_t @var{end_index}, const void* @var{element})

Search whether an element is already in the list, at a position >= @var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item element
A pointer to some user data.
@end table
@item Returns
The position of the node containin @var{element} if found, or
@code{(size_t)(-1)} if not present in the list.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Setting and Getting List Elements
@subsection Setting and Getting List Elements

@deftypefun void * pdf_list_node_value (pdf_list_t @var{list}, pdf_list_node_t @var{node})

Get the element value represented by a list node.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node of @var{list}.
@end table
@item Returns
The element value represented by @var{node}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun {void *} pdf_list_get_at (pdf_list_t @var{list}, pdf_size_t @var{position})

Get the element at a given position in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}. 
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@end table
@item Returns
The element 
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_node_t pdf_list_set_at (pdf_list_t @var{list}, pdf_size_t @var{position}, const void* @var{element})

Replace the element at a given position in a list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@end table
@item Returns
The node containing the replaced element.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Adding and Removing List Elements
@subsection Adding and Removing List Elements

@deftypefun pdf_list_node_t pdf_list_add_first (pdf_list_t @var{list}, const void* @var{element})

Add an element as the first element of the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to the user data to be stored as a list element.
@end table
@item Returns
The node containing the added elemetn.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_node_t pdf_list_add_last (pdf_list_t @var{list}, const void* @var{element})

Add an element as the last element of the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to the user data to be stored as a list element.
@end table
@item Returns
The node containing the given @var{element}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_node_t pdf_list_add_at (pdf_list_t @var{list}, pdf_size_t @var{position}, const void* @var{element})

Add an element at a given position in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in the list.
Should be @code{>= 0} and @code{<= pdf_list_size (list)}.
@item element
A pointer to the user data to be stored as a list element.
@end table
@item Returns
The node containing the given @var{element}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove_node (pdf_list_t @var{list}, pdf_list_node_t @var{node})

Remove an element from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
The node to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove_at (pdf_list_t @var{list}, pdf_size_t @var{position})

Remove an element at a given position from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove (pdf_list_t @var{list}, const void * @var{element})

Search and remove an element from the lsit.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@var{element} was found in the list and was removed.
@item PDF_BADDATA
@var{element} was not found in the list.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Working with Iterators
@subsection Working with Iterators

@deftypefun pdf_list_iterator_t pdf_list_iterator (pdf_list_t @var{list})

Create an iterator traversing a list.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item list
A list.
@end table
@item Returns
An iterator pointing to the head of @var{list}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_list_iterator_t pdf_list_iterator_from_to (pdf_list_t @var{list}, pdf_size_t @var{start_index}, pdf_size_t @var{end_index})

Create an iterator traversing the element with indices @code{i},
@code{start_index <= i < end_index}, of a list.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@end table
@item Returns
An iterator pointing to @var{start_index}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_next (pdf_list_iterator_t *@var{iterator}, const void **@var{element_pointer}, pdf_list_node_t *@var{node_pointer})

If there is a next element, store the next element in
@var{*element_pointer}, store its node in @var{*node_pointer} if it is
non-@code{NULL}, and advance the iterator.

@table @strong
@item Parameters
@table @var
@item iterator
A list iterator.
@item element_pointer
A pointer to a pointer to user data.
@item node_pointer
A pointer to a list node.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
There is a next element.
@item PDF_ERROR
There is not a next element.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_free (pdf_list_iterator_t *@var{iterator})

Free an iterator releasing any used resource.

@table @strong
@item Parameters
@table @var
@item iterator
A list iterator.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Filtered Streams
@section Filtered Streams

@node Floating Point Arithmetic
@section Floating Point Arithmetic

@menu
* Floating Point Types::
* Point Manipulation Functions::
* Rectangle Manipulation Functions::
* Quadrilateral Manipulation Functions::
* Matrix Manipulation Functions::
* Interpolation Functions::
@end menu

@node Floating Point Types
@subsection Floating Point Types

@deftp {Data Type} pdf_real_t
A floating-point number.
@end deftp

@deftp {Data Type} struct pdf_point_s

This structure represents a single point. The coordinates of the point
are made using floating point numbers.

@table @code
@item pdf_real_t h
Horizontal coordinate.
@item pdf_real_t v
Vertical coordinate.
@end table
@end deftp

@deftp {Data Type} struct pdf_rect_s

This structure represents a rectangle. It is composed by the
coordinates for its four sides.

The rectangle sides should be horizontal and vertical and opposite
sides should be parallel.

@table @code
@item pdf_real_t left
@code{x} coordinate for the left points.
@item pdf_real_t top
@code{y} coordinate for the upper points.
@item pdf_real_t right
@code{x} coordinate for the right points.
@item pdf_real_t bottom
@code{y} coordinate for the bottom points.
@end table
@end deftp

@deftp {Data Type} struct pdf_quad_s
This structure represents a quadrilateral. It is composed by four
corners (floating-point points).
@table @code
@item pdf_point_t tl
Top-left point.
@item pdf_point_t tr
Top-right point.
@item pdf_point_t bl
Bottom-left point.
@item pdf_point_t br
Bottom-right point.
@end table
@end deftp

@deftp {Data Type} struct pdf_matrix_s
This structure represents a 3x3 matrix.

@table @code
@item pdf_real_t a11
@item pdf_real_t a12
@item pdf_real_t a13
First row.
@item pdf_real_t a21
@item pdf_real_t a22
@item pdf_real_t a23
Second row.
@item pdf_real_t a31
@item pdf_real_t a32
@item pdf_real_t a33
Third row.
@end table
@end deftp

@node Point Manipulation Functions
@subsection Point Manipulation Functions

@node Quadrilateral Manipulation Functions
@subsection Quadrilateral Manipulation Functions

@node Rectangle Manipulation Functions
@subsection Rectangle Manipulation Functions

@node Matrix Manipulation Functions
@subsection Matrix Manipulation Functions

@deftypefun pdf_status_t pdf_fp_matrix_concat (pdf_matrix_t @var{result}, pdf_matrix_t @var{m1}, pdf_matrix_t @var{m2})

@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_invert (pdf_matrix_t @var{result}, pdf_matrix_t @var{m})

@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform (pdf_point_t @var{result}, pdf_matrix_t @var{m}, pdf_point_t @var{p})

@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform_rect (pdf_rect_t @var{result}, pdf_matrix_t @var{m}, pdf_rect_t @var{rect})

@end deftypefun

@node Interpolation Functions
@subsection Interpolation Functions

@node Encoded Text
@section Encoded Text

@menu
* Text Data Types::
* Initializing Text Module::
* Creating and Destroying Text::
* Managing Text Properties::
* Managing Text Contents::
* Comparing Text Variables::
* Managing Host Encodings::
@end menu

@node Text Data Types
@subsection Text Data Types

@deftp {Data Type} {enum pdf_text_unicode_encoding_e}

Enumeration of supported Unicode encodings.

@table @code
@item PDF_TEXT_UTF8
UTF-8 encoding.
@item PDF_TEXT_UTF16_BE
Big Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_LE
Little Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_HE
Host Endian UTF-16 encoding (may be little-endian or big-endian).
@item PDF_TEXT_UTF32_BE
Big Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_LE
Little Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_HE
Host Endian UTF-32 encoding (may be little-endian or big-endian).
@end table
@end deftp


@deftp {Data Type} pdf_text_unicode_options_e

Enumeration of extra options to get the contents of a pdf_text_t in a given
UNICODE encoding (see function `pdf_text_get_unicode').

@table @code
@item PDF_TEXT_UNICODE_NO_OPTION (= 0)
No specific option
@item PDF_TEXT_UNICODE_WITH_BOM
Prepend Byte Order Marker to the UNICODE string. This option is NOT applicable
to UTF-8. If specified in UTF-8, it will be ignored.
@item PDF_TEXT_UTF16BE_WITH_LANGCODE
Insert language/country code information between the BOM (if required) and the
data. This option is ONLY applicable to UTF16BE. If specified in any other
encoding, it will be ignored. 
@end table
@end deftp



@deftp {Data Type} pdf_text_filter_type_e

Enumeration of supported filters in encoded text objects.

@table @code
@item PDF_TEXT_FILTER_UNKNOWN (= -1)
Invalid filter.
@item PDF_TEXT_FILTER_IDENTITY
Do not perform any transformation in the encoded text. It is a no-op.
@item PDF_TEXT_FILTER_LINE_ENDINGS
Normalize line endings.
@item PDF_TEXT_FILTER_UPPER_CASE
Makes all text upper case.
@item PDF_TEXT_FILTER_LOWER_CASE
Makes all text lower case.
@item PDF_TEXT_FILTER_REMOVE_AMP
Remove all single ampersands. This filter transform @code{&&} into
@code{&}.
@item PDF_TEXT_FILTER_NORM_WITH_FULL_WIDTH
Normalize with full width ASCII variants filter.
@item PDF_TEXT_FILTER_REMOVE_LINE_ENDINGS
Replace line endings with space characters.
@end table
@end deftp


@deftp {Data Type} pdf_text_t

A Unicode string, which must be considered as an opaque type. It contains the data
in UTF-32BE encoding, as well as any `ISO-639-1' country code and/or `ISO-3166-1 alpha-2'
language code applied.

This data type must be initialized before being used, and destroyed afterwards.

@end deftp

@deftp {Data Type} pdf_text_host_encoding_t

This data type identifies an encoding used in a host (all the possible values
are host-dependent). There is no initialization/destruction requirement for
this data type.

@end deftp


@node Initializing Text Module
@subsection Initializing Text Module

@deftypefun pdf_status_t pdf_text_init (void)

Initialize the Text Module. Must be launched only once at program startup,
and is NOT thread-safe.

@table @strong
@item Parameters
None.
@item Returns
Status of the initialization.
@end table
@end deftypefun

@node Creating and Destroying Text
@subsection Creating and Destroying Text

@deftypefun pdf_text_t pdf_text_new (void)

Create a new text object containing no text.

@table @strong
@item Parameters
None.
@item Returns
A pointer to the newly created text object.
@item Usage Example
@example
pdf_text_t mytext;

mytext = pdf_text_new ();
@end example
@end table
@end deftypefun


@deftypefun void pdf_text_destroy (pdf_text_t text)

Destroy a text object and its contents.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@end table
@item Returns
None
@item Usage Example
@example
pdf_text_t mytext;

mytext = pdf_text_new ();
pdf_text_destroy(mytext);

@end example
@end table
@end deftypefun

@deftypefun pdf_text_t pdf_text_dup (pdf_text_t @var{text})

Dup a new text object from a existing one.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@end table
@item Returns
A pointer to the newly created text object.
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

text1 = pdf_text_new ();
text2 = pdf_text_dup (text1);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_host (pdf_text_t *@var{text}, const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const pdf_text_host_encoding_t @var{enc})

Create a new text object and initialize it with a given host encoded
string.

@table @strong
@item Parameters
@table @var
@item text
A pointer to the output text object
@item str
A multybyte string in some host encoding.
@item size
The length of @var{str}, in bytes.
@item enc
The host encoding with which @var{str} is encoded.
@end table
@item Returns
The status of the conversion
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *he_string;
pdf_size_t  he_string_size;
pdf_text_host_encoding_t encoding;
pdf_status_t ret_code;

/* Obtain host encoding and text... */

/* And create text object with those contents */
ret_code = pdf_text_new_from_host(&text,
                                  he_string, he_string_size,
                                  encoding);
if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_pdf_string (pdf_text_t *@var{text}, const pdf_char_t *@var{str}, pdf_size_t @var{size}, pdf_char_t *@var{remaining_str}, pdf_size_t *@var{remaining_length})

Create a new text object and initialize it with a given `PDF string'
text representation. This `PDF string' can be either encoded in UTF-16BE, with
BOM and optional Country/Language code information, or in PDF Doc Encoding.

The Country/Language code marker is treated as end-of-text marker, so that a text object
handles only a given pair of country and language codes. This function must be used
inside a loop, so that the input string of data is splitted in chunks if more than
one language/code is available in the text (only if PDF string is encoded in
UTF-16BE).

@table @strong
@item Parameters
@table @var
@item text
A pointer to the newly created text object.
@item str
A text representation of a PDF string.
@item size
The length of @var{str} in bytes
@item remaining_str
Returned pointer to the next chunk of data to process, if any.
@item remaining_length
Length of @var{remaining_str} in bytes
@item Returns
The status of the conversion
@end table

@item Usage Example
@example

pdf_text_t text;
pdf_char_t *pdf_string;
pdf_size_t  pdf_string_size;
pdf_char_t *remaining_str;
pdf_size_t remaining_size;
pdf_status_t ret_code;

/* Obtain PDF string... */

/* And create text object with those contents */
remaining_str = pdf_string;
remaining_length = pdf_string_size;
do
@{
  ret_code = pdf_text_new_from_host(&text,
                                    remaining_str, remaining_length,
                                    &remaining_str, &remaining_length);

  /* Do something with the chunk of string */

  pdf_text_destroy(text);
@}
while((ret_code == PDF_OK) && (remaining_length > 0));


@end example
@end table
@end deftypefun

@deftypefun pdf_text_t pdf_text_new_from_unicode (pdf_text_t *@var{text}, const pdf_char_t *@var{ucs}, const pdf_size_t @var{size}, const enum pdf_text_unicode_encoding_e @var{enc})

Create a new text object from a string of Unicode characters in a
given unicode encoding. The Unicode string can be given with or without BOM,
and there mustn't be any language/code information embedded in the string.

Note that for UTF-16BE strings two options are possible to create the
pdf_text_t object: treating it as a PDF string (so BOM is mandatory and 
Language/Country code are optional) or treating it as a general Unicode
string (so BOM is optional and Language/Country code is not allowed).

@table @strong
@item Parameters
@table @var
@item text
A pointer to the newly created text object.
@item ucs
A Unicode string.
@item size
The length of @var{ucs} in bytes.
@item enc
The Unicode encoding used by @var{ucs}.
@end table
@item Returns
The status of the conversion
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *unicode_string;
pdf_size_t  unicode_string_size;
pdf_status_t ret_code;

/* Obtain unicode text... */

/* And create text object with those contents */
ret_code = pdf_text_new_from_unicode(&text,
                                     unicode_string, unicode_string_size,
                                     PDF_TEXT_UTF16_BE);
if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_u32 (pdf_text_t *text, const pdf_u32_t @var{number})

Create a new text variable containing the textual representation of a
given integer.

@table @strong
@item Parameters
@table @var
@item text
A pointer to the newly created text object.
@item number
An unsigned 32 bit number.
@end table
@item Returns
The status of the conversion
@item Usage Example
@example
pdf_text_t text;
pdf_u32_t number;
pdf_status_t ret_code;

number = 24;
ret_code = pdf_text_new_from_u32 (&text, number);

if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@node Managing Text Properties
@subsection Managing Text Properties

@deftypefun {const pdf_char_t *}pdf_text_get_country (pdf_text_t @var{text})

Return the `ISO-3166-1 alpha-2' country code associated with a text variable, as a
NUL-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the country associated with @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_country (text);
@end example
@end table
@end deftypefun

@deftypefun {const pdf_char_t *}pdf_text_get_language (pdf_text_t @var{text})

Return the `ISO-639-1' language code associated with a text variable, as a
NUL-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the language associated with @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_language (text);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_country (pdf_text_t @var{text}, const pdf_char_t *@var{code})

Associate a text variable with a `ISO-3166-1 alpha-2' country code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A country code.
@end table
@item Returns
The status of the assignment.
@item Usage Example
@example
pdf_text_t text;
pdf_status_t ret_code;

/* ...create and manipulate `text' */

ret_code = pdf_text_set_country (text, "27");

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_language (pdf_text_t @var{text}, const pdf_char_t *@var{code})

Associate a text variable with a `ISO-639-1' language code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A language code.
@end table
@item Returns
The status of the assignment.
@item Usage Example
@example
pdf_text_t text;
pdf_status_t ret_code;

/* ...create and manipulate `text' */

ret_code = pdf_text_set_language (text, "10");
@end example
@end table
@end deftypefun

@deftypefun {inline pdf_bool_t} pdf_text_empty_p (pdf_text_t @var{text})

Determine if a given text variable is empty (contains no text).

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The text variable contain no text.
@item PDF_FALSE
The text variable contain some text.
@end table
@item Usage Example
@example
pdf_text_t text;

/* ...initialize and manipulate `text'... */

if (pdf_text_empty_p (text))
@{
  /* `text' contains no text */
@}
@end example
@end table
@end deftypefun


@node Managing Text Contents
@subsection Managing Text Contents

@deftypefun pdf_status_t pdf_text_get_host (pdf_char_t **@var{contents}, pdf_size_t *@var{length}, const pdf_text_t @var{text}, const pdf_text_host_encoding_t @var{enc})

Get the contents of a text variable encoded in a given host encoding.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (May contain NUL bytes). Must be freed afterwards.
@item length
Output length of @var{contents}
@item text
A text variable.
@item enc
A host encoding supported by the host.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding_t encoding;
pdf_char_t *str;
pdf_size_t str_length;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_host (&str, &str_length, text, encoding);

pdf_free(str);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_get_pdfdocenc (pdf_char_t **@var{contents}, const pdf_text_t @var{text})

Get the contents of a text variable encoded in PDF Doc Encoding,
and NUL-terminated.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (Can't contain NUL bytes). Must be freed afterwards.
@item text
A text variable.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_pdfdocenc (&str, text);

pdf_free(str);

@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_text_get_unicode (pdf_char_t **@var{contents}, pdf_size_t *@var{length}, const pdf_text_t @var{text}, const enum pdf_text_unicode_encoding_e @var{enc}, const int @var{options})

Get the contents of a text variable encoded in the specified
Unicode encoding. Additional options can be set in the request.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (May contain NUL bytes). Must be freed afterwards.
@item length
Output length of @var{contents}
@item text
A text variable.
@item enc
A given UNICODE encoding, specifying requested endianness.
@item options
Additional options that can be set, in the way: OPTION_1 | OPTION_2 | OPTION_3.
(see @code{pdf_text_unicode_options_e} data type)
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_size_t str_length;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_unicode (&str, &str_length,
                                 text,
                                 PDF_TEXT_UTF16_BE,
                                 PDF_TEXT_UNICODE_WITH_BOM | PDF_TEXT_UTF16BE_WITH_LANGCODE);

pdf_free(str);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_host (pdf_text_t @var{text}, const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const pdf_text_host_encoding_t @var{enc})

Set a string encoded with some host encoding as the value of a text
variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with some host encoding.
@item enc
The length of @var{str}, in bytes.
@item enc
The host encoding used to encode @var{str}.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding_t encoding;
pdf_char_t *str;
pdf_size_t length;

/* ...initialize and manipulate `text', `encoding' and `str'... */
if (pdf_text_set_host (text, str, length, enc) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_pdfdocenc (pdf_text_t @var{text}, const pdf_char_t *@var{str})

Set a PDF Doc Encoding encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with PDF Doc Encoding, NUL terminated.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;

/* ...initialize and manipulate `text' and `str'... */
if (pdf_text_set_pdfdocenc (text, str) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_unicode (pdf_text_t @var{text}, const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const enum pdf_text_unicode_encoding_e @var{enc})

Set a Unicode encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A Unicode string without country/language data embedded.
@item size
The length of @var{str}, in bytes.
@item enc
The used Unicode encoding in @var{str}.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_size_t length;
enum pdf_text_unicode_encoding_e enc;

/* ...initialize and manipulate `text', `str' and `enc'... */
if (pdf_text_set_unicode (text, str, length, enc) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_concat (pdf_text_t @var{text}, const pdf_text_t @var{text1}, const pdf_text_t @var{text2})

Concatenate the contents of two text variables (@var{text1} first,
then @var{text2}) and store the result in the output text variable (@var{text}).

Warning! If different country/language codes are found within
the text variables an error will be returned (concatenation not
possible)

@table @strong
@item Parameters
@table @var
@item text
The output text variable.
@item text1
The first text variable to concatenate. The contents of this variable
are left unchanged.
@item text2
The second text variable to concatenate. The contents of this variable
are left unchanged.
@end table
@item Returns
The status of the operation.
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

/* ...initialize `text1' and `text2'... */
if (pdf_text_concat (text1, text1, text2) != PDF_OK)
@{
   /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_replace (pdf_text_t @var{text}, const pdf_text_t @var{new_pattern}, const pdf_text_t @var{old_pattern})

Replace a fixed pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement text.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;
pdf_text_t new_pattern;
pdf_text_t old_pattern;

/* ...initialize `text', `new_pattern' and `old_pattern'... */
if (pdf_text_replace (text, new_pattern, new_pattern) != PDF_OK)
@{
  /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_replace_ascii (pdf_text_t @var{text}, const pdf_char_t *@var{new_pattern}, const pdf_char_t *@var{old_pattern})

Replace a fixed ASCII pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement ASCII string.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;
const pdf_char_t *new_pattern = "GNU/Linux";
const pdf_char_t *old_pattern = "Linux";

/* ...initialize `text'... */
if (pdf_text_replace_ascii (text, new_pattern, old_pattern) != PDF_OK)
@{
  /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_filter (pdf_text_t @var{text}, const enum pdf_text_filter_type_e @var{filter})

Filter the contents of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item filter
A filter to run in @var{text} contents.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;

/* ...initialize `text'... */

if (pdf_text_filter (text, PDF_TEXT_FILTER_LOWER_CASE) != PDF_OK)
@{
  /* Manage error */
@}
@end example
@end table
@end deftypefun


@node Comparing Text Variables
@subsection Comparing Text Variables

@deftypefun pdf_i32_t pdf_text_cmp (pdf_text_t @var{text1}, pdf_text_t @var{text2}, pdf_bool_t @var{case_sensitive})

Compare the contents of two text variables.

@table @strong
@item Parameters
@table @var
@item text1
A text variable.
@item text2
A text variable.
@item case_sensitive
A boolean value indicating if the comparison is case-sensitive:
@table @code
@item PDF_TRUE
Case sensitive.
@item PDF_FALSE
Case insensitive.
@end table
@end table
@item Returns
An integer:
@table @code
@item -1
If text1 < text2
@item 0
If text1 = text2
@item +1
If text1 > text2
@end table
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

/* ...initialize `text1' and `text2'... */

switch (pdf_text_cmp (text1, text2, PDF_FALSE))
@{
 case -1:
 @{
   /* XXX */
   break;
 @}
 case 0:
 @{
   /* XXX */
   break;
 @}
 case +1:
 @{
   /* XXX */
   break;
 @}
@}
@end example
@end table
@end deftypefun

@node Managing Host Encodings
@subsection Managing Host Encodings

@deftypefun pdf_text_host_encoding_t pdf_text_get_host_encoding (void)

Return the host encoding configured by the user/system in the locale. 

@table @strong
@item Parameters
None
@item Returns
The host encoding configured in the user's locale.
@item Usage Example
@example
pdf_text_host_encoding enc;

enc = pdf_text_get_host_encoding();

@end example
@end table
@end deftypefun


@deftypefun pdf_text_host_encoding_t pdf_text_get_best_encoding (const pdf_text_t @var{text}, const pdf_text_host_encoding_t @var{preferred_encoding})

Return the best available host encoding to encode the contents of a
given text variable. A specified preferred encoding is selected if
available. 

The ``best'' encoding is an encoding able to encode the bigger number
of characters of the unicode content of the given text variable.
@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item preferred_encoding
A text encoding supported by the host.
@end table
@item Returns
The best host encoding available to encode the contents of @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding pref;
pdf_text_host_encoding enc;

/* ...create and manipulate `text'... */

enc = pdf_text_get_best_encoding (text, pref);

@end example
@end table
@end deftypefun


@node Time Management
@section Time Management

@menu
* Time Related Data Types::
* Time Creation and Destruction::
* Managing Time Values::
* Getting Time Intervals::
* Time Comparison::
* Time Printing and Parsing::
* Getting the Current Time::
* Time Span Creation and Destruction::
* Managing Time Span Values::
* Time Span Comparison::
* Calendar Spans Management::
@end menu

@node Time Related Data Types
@subsection Time Related Data Types

@deftp {Data Type} pdf_time_t
A variable of type @code{pdf_time_t} contain information about a
particular date and time.

Note that leap seconds are not considered.
@end deftp

@deftp {Data Type} pdf_time_span_t
A variable of type @code{pdf_time_span_t} represent a span of time.

@end deftp

@deftp {Data Type} struct pdf_time_cal_s
This structure holds information about a specific time represented in
calendar items: years, months, days, day of week, hours, minutes,
seconds and the relative offset with GMT.

@table @code
@item pdf_i32_t year
A year number. Negative values may be supported in some systems.
@item pdf_u32_t month
A month number. The valid range is @code{1..12}.
@item pdf_u32_t day
A day number. The valid range is @code{1..31}.
@item pdf_u32_t dow
Day of the week. The valid range is @code{1..7} (Monday to Sunday).
@item pdf_u32_t hour
An hour. The valid range is @code{0..23}.
@item pdf_u32_t minute
A minute. The valid range is @code{0..59}.
@item pdf_u32_t sec
A second. The valid range is @code{0..59}.
@item pdf_i32_t gmt_offset
A GMT offset.
@end table
@end deftp

@deftp {Data Type} struct pdf_time_cal_span_s
This structure holds information about a time span represented in
calendar items: years, months, days, hours, minutes and seconds.

@table @code
@item pdf_u32_t sign
@item pdf_u32_t years
@item pdf_u32_t months
@item pdf_u32_t days
@item pdf_u32_t hours
@item pdf_u32_t minutes
@item pdf_u32_t seconds
@end table
@end deftp

@deftp {Data Type} {enum pdf_time_format_e}
Enumeration containing the several supported time formats used to
convert a time to a string representation or to parse a time from a
string representation.

@table @code
@item PDF_TIME_FORMAT_PDF
PDF date strings.
@item PDF_TIME_FORMAT_ISO_8601
ISO 8601 date and time strings.
@item PDF_TIME_FORMAT_ASN1
UTC ASN1 date.
@item PDF_TIME_FORMAT_GENERALIZED_ASN1
ASN1 date.
@end table
@end deftp

@node Time Creation and Destruction
@subsection Time Creation and Destruction

@deftypefun pdf_time_t pdf_time_new (void)
Create a new time and set it to the Epoch: Jan 1 1970-01-01 00:00:00 UTC

@table @strong
@item Parameters
None.

@item Returns
The newly created time object.
If an error occurs then @code{NULL} is returned.
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
if (mytime == NULL)
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_time_t pdf_time_dup (pdf_time_t @var{orig})
Dup a new time variable from a given one, allocating memory.

@table @strong
@item Parameters

@table @var
@item orig
The time variable to be dupped. Should be a properly created time
variable.
@end table
@item Returns
A new time variable containing a copy of @var{orig} values.
@code{NULL} if there is an error.
@item Usage example
@example
pdf_time_t orig;
pdf_time_t new_time;

orig = pdf_time_new ();
new_time = pdf_time_dup (orig);

if (new_time == NULL)
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_destroy (pdf_time_t @var{time})
Destroy @var{mytime} and free all used memory.

@table @strong
@item Parameters
@table @var
@item time
The time variable to be destroyed. Should be a properly created time
variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@node Managing Time Values
@subsection Managing Time Values

@deftypefun pdf_status_t pdf_time_copy (pdf_time_t orig, pdf_time_t @var{copy})
Copies the data from @var{orig} to @var{copy}.

@table @strong
@item Parameters
@table @var
@item orig
The time whose data is to be copied. Should be a properly created time variable.
@item copy
The time to receive the data from @var{orig}. Should be a properly
created time variable.

Note that any previous data is destroyed.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t orig;
pdf_time_t copy;

orig = pdf_time_new ();
copy = pdf_time_new ();

if (!pdf_time_copy (orig, copy))
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_clear (pdf_time_t @var{time})
Reset @var{time} to the newly created state. After this call
@var{time} will contain the same date as if returned by
@code{pdf_time_new}.

@table @strong
@item Parameters
@table @var
@item time
The time variable to clear. Should be a properly create time variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

/* ...manipulate `mytime'... */

pdf_time_clear (mytime);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_add_cal_span (pdf_time_t @var{time}, struct pdf_time_cal_span_s @var{cal_span})
Add the time span represented by @var{cal_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_span
A calendar span with valid values.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
The data in @var{cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, cal_span) == PDF_E_BADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_cal_span (pdf_time_t @var{time}, struct pdf_time_cal_span_s @var{cal_span})
Subtract the time span represented by @var{cal_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_span
A calendar span with valid values.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
The data in @var{cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, cal_span) == PDF_E_BADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}

if (pdf_time_sub_cal_span (mytime, cal_span) == PDF_E_BADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Jan 1 1970-01-01 00:00:00 */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_add_span (pdf_time_t @var{time}, pdf_time_span_t @var{time_span})
Add the time span contained in @var{time_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_add_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_span (pdf_time_t @var{time}, pdf_time_span_t @var{time_span})
Subtract the time span contained in @var{time_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_sub_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_local_cal (pdf_time_t @var{time}, struct pdf_time_cal_s @var{local_cal})
Fill @var{local_cal} with the local calendar time of @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item local_cal
A time calendar structure that will hold the local time of @var{time}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s cal;

/* ...create and manipulate `mytime'... */

pdf_time_get_local_cal (mytime, cal);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_utc_cal (pdf_time_t @var{time}, struct pdf_time_cal_s @var{cal_time})
Get the UTC calendar time of a given time variable.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_time
A calendar time structure that will hold the UTC time of @var{time}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
sruct pdf_time_cal_s cal_time;

/* ...create and manipulate `mytime'... */

pdf_time_get_utc_cal (mytime, cal_time);
@end example
@end table
@end deftypefun

@deftypefun pdf_time_from_cal (pdf_time_t @var{time}, struct pdf_time_cal_s @var{cal_time})
Set the value of a time variable to a given calendar time.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_time
A calendar time structure.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
There is invalid data in the calendar structure @var{cal_time}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s mycaltime;

mytime = pdf_time_new ();

mycaltime.year = 2000;
mycaltime.month = 8;
mycaltime.day = 10;
mycaltime.dow = 0; /* This field is ignored by `pdf_time_from_cal' */
mycaltime.hour = 0;
mycaltime.minute = 0;
mycaltime.sec = 0;
mycaltime.gmt_offset = 1;

if (pdf_time_from_cal (mytime, mycaltime) == PDF_E_BADDATA)
@{
  /* Bad data in `mycaltime' */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_local_offset (pdf_time_t @var{time})
Set the local time offset of @var{time} to the one used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_set_local_offset (time);
@end example
@end table
@end deftypefun

@node Getting Time Intervals
@subsection Getting Time Intervals

@deftypefun pdf_status_t pdf_time_diff_cal (pdf_time_t @var{time1}, pdf_time_t @var{time2}, struct pdf_time_cal_span_s @var{cal_span})
Calculate the time span that goes from @var{time1} to @var{time2} and
store it in @var{cal_span}.

Note that the highest possible distribution inside @var{cal_span} is used.
@table @strong
@item Parameters

@table @var
@item time1
The beginning of the time interval (inclusive).
@item time2
The end of the time interval (exclusive).
@item cal_span
The calendar time span structure that will hold the time span that
goes between @var{time1} and @var{time2}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time_begin;
pdf_time_t time_end;
struct pdf_time_cal_span_s cal_span;

/* ...create and manipulate `time_begin' and `time_end' */

pdf_time_diff (time_begin, time_end, cal_span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_diff (pdf_time_t @var{time1}, pdf_time_t @var{time2}, pdf_time_span_t @var{time_span})
Calculate the time span between two dates.

@table @strong
@item Parameters

@table @var
@item time1
The beginning time. Should be a properly created time.
@item time2
The ending time. Should be a properly created time.
@item time_span
The time span variable that will hold the difference between
@var{time1} and @var{time2}. Should be a properly created time
span. Any previous content of @var{time_span} will be destroyed.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;
pdf_time_span_t time_span;

/* ...create and manipulate `time1', `time2' and `time_span'... */

pdf_time_diff (time1, time2, time_span);
@end example
@end table
@end deftypefun

@node Time Comparison
@subsection Time Comparison

@deftypefun pdf_i32_t pdf_time_cmp (pdf_time_t @var{time1}, pdf_time_t @var{time2})
Compares two times.

@table @strong
@item Parameters

@table @var
@item time1
The first time to compare.
Should be a properly created time variable.
@item time2
The second time to compare.
Should be a properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item -1
If @var{time1} precedes @var{time2}.
@item 0
If @var{time1} and @var{time2} contain the same time.
@item 1
If @var{time2} precedes @var{time1}.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;

time1 = pdf_time_new ();
time2 = pdf_time_new ();

/* ...manipulate `time1' and `time2'... */

switch (pdf_time_cmp (time1, time2))
@{
  case -1:
  @{
    /* `time1' precedes `time2' */
    break;
  @}
  case 0:
  @{
    /* `time1' contain the same time than `time2' */
    break;
  @}
  case 1:
  @{
    /* `time2' precedes `time1' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Time Printing and Parsing
@subsection Time Printing and Parsing

@deftypefun char* pdf_time_to_string (pdf_time_t @var{time}, enum pdf_time_format_e @var{time_format})
Create a string representation of a given time.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item time_format
The format to use when creating the string representation of @var{time}. 
@end table

@item Returns
The string representation of @var{time}.
@code{NULL} if there is an error.

@item Usage example
@example
pdf_time_t mytime;
char *mytime_str;

/* ...create and manipulate `mytime'... */

mytime_str = pdf_time_to_string (mytime, PDF_TIME_FORMAT_PDF);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_from_string (pdf_time_t mytime, char *@var{time_str}, enum pdf_time_format_e @var{time_format})
Get a string containing a time specification in some format and fill a
time variable with the parsed values.

@table @strong
@item Parameters

@table @var
@item mytime
A properly created time variable.

@item time_str
A null-terminated string representation of a time.
@item time_format
The format indicating how to parse @var{time_str}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_E_BADDATA
Error while parsing @var{time_str} according to @var{time_format}.
@end table

@item Usage example
@example
pdf_time_t mytime;
char time_str[] = "FIXME: put a correct PDF time there";

mytime = pdf_time_new ();
if (pdf_time_from_string (mytime, 
                          time_str,
                          PDF_TIME_FORMAT_PDF) == PDF_E_BADDATA)
@{
  /* Error while parsing `time_str' according to `PDF_TIME_FORMAT_PDF' */
@}
@end example
@end table
@end deftypefun

@node Getting the Current Time
@subsection Getting the Current Time

@deftypefun pdf_status_t pdf_time_set_to_current_local_time (pdf_time_t @var{time})
Set the value of @var{time} to the current local time used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_local_time (mytime);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_to_current_utc_time (pdf_time_t @var{time})
Set the value of @var{time} to the current UTC time used by the operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_utc_time (mytime);
@end example
@end table
@end deftypefun

@node Time Span Creation and Destruction
@subsection Time Span Creation and Destruction

@deftypefun pdf_time_span_t pdf_time_span_new (void)

Allocate and return a new time span variable. The time span is
initialized with a zero value (zero seconds).

@table @strong
@item Parameters

None.

@item Returns
The newly created time span variable or @code{NULL} if there is an
error. 
@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
@end example
@end table
@end deftypefun

@deftypefun pdf_time_span_t pdf_time_span_dup (pdf_time_span_t @var{span})

Allocate and dup a new time span from an existing one. The new time
span has the same value as the base time span.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns
The newly created time span variable.
@item Usage example
@example
pdf_time_span_t span;
pdf_time_span_t new_span;

/* ...create and manipulate `span'... */

new_span = pdf_time_span_dup (span);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_span_destroy (pdf_time_span_t @var{span})

Destroy a time span variable freeing all used memory.

@table @strong
@item Parameters

@table @var
@item span
The time span variable to be destroyed.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table
@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_destroy (span);
@end example
@end table
@end deftypefun

@node Managing Time Span Values
@subsection Managing Time Span Values

@deftypefun pdf_status_t pdf_time_span_set (pdf_time_span_t @var{span}, pdf_i32_t @var{high_value}, pdf_u32_t @var{low_value})

Set the value of a time span. The internal representation of the time
span is 64 bits long (signed).

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@item high_value
The high (signed) part of the time span value.
@item low_value
The low (unsigned) part of the time span value.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage exaple
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
pdf_time_span_set (span, (32 << 1), 10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_set_from_i32 (pdf_time_span_t @var{span}, pdf_i32_t @var{seconds})

Set the value of a time span from a 32 bits signed number.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@item seconds
A signed 32 bits number.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_create ();
pdf_time_span_set_from_i32 (span, -10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_negate (pdf_time_span_t @var{span})

Make a positive time span into a negative one or make a negative time
span into a positive one.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_negate (span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_add (pdf_time_span_t @var{span1}, pdf_time_span_t @var{span2}, pdf_time_span_t @var{result})

Add two time spans and store the result in another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to add.
@item span2
The second time span to add.
@item result
The time span holding the result of the add operation. Any previous
content is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t result;

/* ...create and manipulate `span1', `span2' and `result'... */
pdf_time_span_add (span1, span2, result);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_copy (pdf_time_span_t @var{orig}, pdf_time_span_t @var{dest})

Copy the value of a time span into another time span.

@table @strong
@item Parameters

@table @var
@item orig
The origin time span.
@item dest
The time span variable that will hold the value of @var{orig}. Any
previous value is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span_orig;
pdf_time_span_t span_dest;

/* ...create and manipulate `span_orig' and `span_dest'... */

pdf_time_span_copy (span_orig, span_dest);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_diff (pdf_time_span_t @var{span1}, pdf_time_span_t @var{span2}, pdf_time_span_t @var{result})

Difference two time spans and store the result (maybe negative) into
another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to diff.
@item span2
The second time span to diff.
@item result
The result of the diff operation. Any previous value of the time span
is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t span_diff;

/* ...create and manipulate `span1', `span2' and `span3' */

pdf_time_span_diff (span1, span2, span_diff);
@end example
@end table
@end deftypefun

@deftypefun pdf_i32_t pdf_time_span_to_secs (pdf_time_span_t @var{span})

Get the value of a time span in seconds. 

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns
The value of the time span in seconds.
A negative value is returned if the time span is negative.
@item Usage example
@example
pdf_time_span_t span;
pdf_i32_t num_seconds;

/* ...create and manipulate `span'... */

num_seconds = pdf_time_span_to_secs (span);
@end example
@end table
@end deftypefun

@node Time Span Comparison
@subsection Time Span Comparison

@deftypefun pdf_i32_t pdf_time_span_cmp (pdf_time_span_t @var{span1}, pdf_time_span_t @var{span2})

Compare the length two time spans.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to compare.
@item span2
The second time span to compare.
@end table

@item Returns
A status value:
@table @code
@item -1
The length of @var{span1} is shorter than the length of @var{span2}.
@item 0
The lengts of @var{span1} and @var{span2} are equal.
@item +1
The length of @var{span1} is greater than the length of @var{span2}.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;

/* ...create and manipulate `span1' and `span2'... */
switch (pdf_time_span_cmp (span1, span2))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal to the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Calendar Spans Management
@subsection  Calendar Spans Management

@deftypefun pdf_status_t pdf_time_add_cal_span_with_base (struct pdf_time_cal_span_s @var{span1}, struct pdf_time_cal_span_s @var{span2}, pdf_time_t @var{base_time}, struct pdf_time_cal_span_s @var{result})

Add two calendar spans. Since the calendar spans are relative (some
years has more days than another) the calendar spans are first
resolved from a base time.

@table @strong
@item Parameters

@table @var
@item span1
The first calendar span to add.
@item span2
The second calendar span to add.
@item base_time
The base time to use.
@item result
The calendar span to store the result of the add operation.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span1;
struct pdf_time_cal_span_s cal_span2;
struct pdf_time_cal_span_s cal_result;

/* ...create and initialize `mytime', `cal_span1'
 *    and `cal_span2'...
 */

if (pdf_time_add_cal_span_with_base (cal_span1,
                                     cal_span2,
                                     mytime,
                                     cal_result) == PDF_E_BADDATA)
@{
  /* Invalid data in `cal_span1' or `cal_span2' */
@}      
@end example
@end table
@end deftypefun


@deftypefun pdf_i32_t pdf_time_cal_span_cmp (struct pdf_time_cal_span_s @var{span1}, struct pdf_time_cal_span_s @var{span2}, pdf_time_t @var{base_time})

Compare two calendar spans previously resolved with a given base time.

@table @strong
@item Parameters

@table @var
@item span1
The first calendar span to be compared.
@item span2
The second calendar span to be compared.
@item base_time
The used base time. Should be a correctly created time variable.
@end table

@item Returns

@table @code
@item -1
Given the base time, the time interval defined by @var{span1} is
greater in length than the time interval defined by @var{span2}.
@item 0
Given the base time, the time inveral defined by @var{span1} is equal
in length than the time interval defined by @var{span2}.
@item +1
Given the base time, the time interval defined by @var{span2} is
greater in length than the time interval defined by @var{span1}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;

/* ...create and manipulate `mytime', `span1' and `span2'... */

switch (pdf_time_cal_span_cmp (span1, span2, mytime))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal than the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_cal_span_diff (struct pdf_time_cal_span_s @var{span1}, struct pdf_time_cal_span_s @var{span2}, pdf_time_t @var{base_time}, struct pdf_time_cal_span_s @var{result})

Compute the difference between two calendar spans relative to a given
base time and store it in a given calendar span.

@table @strong
@item Parameters

@table @var
@item span1
The first calendar span to diff.
@item span2
The second calendar span to diff.
@item base_time
The base time. Should be a correctly created time variable.
@item result
The calendar structure holding the result of the difference.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;
struct pdf_time_cal_span_s result;

/* ...create and manipulate `span1', `span2' and 
 *    `result'... 
 */

if (pdf_time_cal_span_diff (span1,
                            span2,
                            mytime,
                            result) == PDF_E_BADDATA)
@{
  /* Invalid data in `span1' or `span2' */
@}
@end example
@end table
@end deftypefun


@node Accessing the File System
@section Accessing the File System

@node Object Layer
@chapter Object Layer

@menu
* Object Layer Overview::
* PDF Objects::
* Object Collections::
* Memory Management::
* Object Level Documents::
* Real Objects::
* Integer Objects::
* Boolean Objects::
* Name Objects::
* String Objects::
* Array Objects::
* Dictionary Objects::
* Stream Objects::
* Indirect Objects::
* Null Object::
@end menu

@node Object Layer Overview
@section Overview

The Object Layer of the library provides access to manipulate PDF
documents as a collection of PDF objects (@pxref{PDF Objects}).

Note that the use of this layer can lead to non-well conformed PDF
documents: not every PDF object collection define a document. So the
client should be careful when using this layer. In contrast the
@ref{Document Layer} provides a convenient API to manipulate PDF files
while maintaining its structural integrity.

All the names for constants, data types and functions defined in this
layer are prefixed with @code{pdfo_} or @code{PDFO_}.

@node PDF Objects
@section PDF Objects

@node Object Collections
@section Object Collections

@node Memory Management
@section Memory Management

@node Object Level Documents
@section Object Level Documents

@node Real Objects
@section Real Objects

A real object represent a fixed-point real number.

@menu
* Real Object Creation::
* Managing Real Object Attributes::
@end menu

@node Real Object Creation
@subsection Real Object Creation

@deftypefun pdfo_obj_t pdfo_create_real (pdfo_doc_t @var{doc}, pdf_bool_t @var{indirect}, pdf_real_t @var{value})

Creates a new real object.

@table @strong
@item Parameters

@table @var
@item doc
Document that contain this object.
@item indirect
Boolean value specifying if we want to create an indirect object.
@item value
Initialization value.
@end table

@item Returns
The newly created object.
@item Usage example

@example
pdfo_doc_t doc;
pdfo_obj_t new_obj;

/* Initialize `doc' ... */

new_obj = pdfo_create_real (doc, PDF_FALSE, 2.12);
@end example 
@end table
@end deftypefun 

@node Managing Real Object Attributes
@subsection Managing Real Object Attributes

@deftypefun pdf_real_t pdfo_get_real (pdfo_obj_t @var{object})

Gets the real value of a real object.

@table @strong
@item Parameters

None.

@item Returns
The real value of the given object.
@item Usage example

@example
pdfo_obj_t real_obj;
pdf_real_t value;

/* Initialize `real_obj' as a Real object ... */

value = pdfo_get_real (new_obj);
@end example
@end table
@end deftypefun

@deftypefun void pdfo_set_real (pdfo_obj_t @var{object}, pdf_real_t @var{value})

Set a new real value in a real object.

@table @strong
@item Parameters
@table @var
@item object
Real object.
@item value
New real value.
@end table

@item Returns
None.
@item Usage example
@example
pdfo_obj_t real_obj;
pdf_real_t value;

/* Initialize `real_obj' as a Real object ... */

pdfo_set_real (new_obj, 3.14);
@end example
@end table
@end deftypefun

@node Integer Objects
@section Integer Objects

@node Boolean Objects
@section Boolean Objects

@node Name Objects
@section Name Objects

@node String Objects
@section String Objects

@node Array Objects
@section Array Objects

@node Dictionary Objects
@section Dictionary Objects

@node Stream Objects
@section Stream Objects

@node Indirect Objects
@section Indirect Objects

@node Null Object
@section Null Object


@node Document Layer
@chapter Document Layer

@node Page Contents Layer
@chapter Page Contents Layer


@c FDL
@c ===

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi


@c The indexes
@c ===========

@node Global variable index
@unnumbered Global variable index

@printindex vr

@node Data type index
@unnumbered Data type index

@printindex tp

@node Function index
@unnumbered Function index

@printindex fn


@bye
