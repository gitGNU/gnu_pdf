\input texinfo
@comment $Id: gnupdf.texi,v 1.79 2008/07/07 20:22:31 jemarch Exp $
@comment %**start of header
@setfilename gnupdf.info
@settitle GNU PDF Library Reference
@comment %**end of header

@include version.texi
@set EDITION first

@copying
This is the @strong{@value{EDITION}} edition of the @cite{GNU PDF Library
Reference}, updated for @strong{libgnupdf} version @strong{@value{VERSION}}.

Copyright @copyright{} 2007, 2008, 2009 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Software libraries
@direntry
* gnupdf: (gnupdf).             The GNU PDF Library reference.
@end direntry

@titlepage
@sp 6
@center @titlefont{GNU PDF Library Reference}
@sp 4
@center @value{EDITION} Edition, Updated for version @value{VERSION}.
@sp 5
@center Free Software Foundation
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU PDF Library Reference

GNU PDF Library Reference

@insertcopying
@end ifnottex

@menu
* Overview::                    The GNU PDF library in brief.
* Base Layer::                  Base library facilities.
* Object Layer::                Editing the object structure of a PDF file.
* Document Layer::              Editing the document-level structure of a PDF
                          file.
* Page Contents Layer::         Editing the contents of pages.
* Implementation Limits::       Implementation limits in the library.
* GNU Free Documentation License::  Distribution terms of this manual.

Indices

* Global variable index::
* Data type index::
* Function index::
@end menu

@node Overview
@chapter Overview

@node Base Layer
@chapter Base Layer

@menu
* Base Layer Overview::
* Error Management::
* Memory Allocation::
* Basic Types::
* Hash Tables::
* Lists::
* Filtered Streams::
* Floating Point Maths::
* Encoded Text::
* Time Management::
* The Filesystem Module::
* The Tokeniser::
* Encryption::
@end menu

@node Base Layer Overview
@section Overview

The base layer of the GNU PDF Library provides system-independent
access to several facilities.

The implemented facilities are organized into modules. Each module
exports an API to be used by the client application or other layers of
the library. Some modules make use of the facilities implemented in
other modules (such as allocation or error functions).

@node Error Management
@section Error Management


The Error module provides procedures for error reporting to the
client as well as for error tracing (via debug messages) to
developers. Here we also define status types returned by most
procedures (there are exceptions though).

@menu
* Status types::
* Error Reporting procedures::
* Debugging procedures::
@end menu

@node Status types
@subsection Status types

@deftp {Data Type} pdf_status_t
A status variable. This type of variable is returned by many library
functions in order to communicate the status of the performed
operation.
@end deftp

The following constants define the valid values to be held in a
@code{pdf_status_t} variable:

@deftp {Constant} PDF_OK
Success
@end deftp

@deftp {Constant} PDF_ERROR
A serious error
@end deftp

@deftp {Constant} PDF_EBADDATA
Invalid or bad arguments
@end deftp

@deftp {Constant} PDF_ENOMEM
Insufficient memory
@end deftp

@deftp {Constant} PDF_EEOF
End of file
@end deftp

@deftp {Constant} PDF_EDIVBYZERO
Divison by zero
@end deftp

@deftp {Constant} PDF_ENONODE
No node found
@end deftp

@deftp {Constant} PDF_EINVRANGE
Invalid range
@end deftp

@deftp {Constant} PDF_ETEXTENC
Error in text encoding
@end deftp

@deftp {Constant} PDF_ENOMATCH
No matching found
@end deftp

This list will grow as we get closer to a mature state of development.


@node Error Reporting procedures
@subsection Error Reporting procedures

@deftypefun void pdf_perror (const pdf_status_t @var{status}, const char *@var{str})

Prints the message corresponding to @var{status} to stderr followed by @var{str}.

@table @strong
@item Parameters
@table @var
@item status
status code
@item str
a user-defined message
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

pdf_i64_add (dest, addend_1, addend_2, &st);

if (st != PDF_OK)
@{
        pdf_perror (st, "Couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_error (const pdf_status_t @var{status}, FILE *@var{fd}, const char *@var{format}, @var{...})

Prints a message with `fprintf (@var{fd}, @var{format}, ...)';
if @var{status} is nonzero, also prints the corresponding message.

@table @strong
@item Parameters
@table @var
@item status
status code
@item fd
file descriptor open for writing
@item format
string format for the message
@item ...
format's arguments
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

pdf_i64_add (dest, addend_1, addend_2, &st);

if (st != PDF_OK)
@{
        pdf_error (st, logfd, "couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun

@node Debugging procedures
@subsection Debugging procedures

For each layer there is a macro procedure defined. The file name and
the line number at which the error ocurred is printed to stderr
followed by @var{message}.

@defmac PDF_DEBUG_BASE (message, ...)
@end defmac
@defmac PDF_DEBUG_OBJECT (message, ...)
@end defmac
@defmac PDF_DEBUG_DOCUMENT (message, ...)
@end defmac
@defmac PDF_DEBUG_PAGE (message, ...)
@end defmac

@table @strong
@item Parameters
@table @var
@item message
a 'const char*' string
@item ...
message's arguments
@end table
@item Returns
nothing
@item Usage example
@example
PDF_DEBUG_BASE("Testing macro '%s' '%d' '%lf'", "string", 7, 10.1);
@end example
@end table


In addition, this module provides a assert macro for each layer.

@defmac PDF_ASSERT_BASE (condition)
@end defmac
@defmac PDF_ASSERT_OBJECT (condition)
@end defmac
@defmac PDF_ASSERT_DOCUMENT (condition)
@end defmac
@defmac PDF_ASSERT_PAGE (condition)
@end defmac

@table @strong
@item Parameters
@table @var
@item condition
a C expression.
@end table
@item Usage example
@example
PDF_ASSERT_BASE (1 == 1);
@end example
@end table


@subheading Output format
The output format for these macros is,

GNU PDF:***DEBUG <layer>***:<file-name>:<line-number>: <message>.

For example,

GNU PDF:***DEBUG BASE***:pdf-fp-func.c:344: division by zero.



@node Memory Allocation
@section Memory Allocation

The memory allocation module provides system-independent heap memory
allocation and deallocation. The usual malloc/free/realloc schema is
used to provide this service.

@deftypefun void* pdf_alloc (const pdf_size_t @var{size})

Allocates heap memory.

@table @strong
@item Parameters

@table @var
@item size
The requested number of octects to allocate.  If this value is
@code{0} then no memory is allocated and @code{NULL} is returned.
@end table

@item Returns
A pointer to the newly allocated memory.

If there is not enough available memory to satisfy the petition then
@code{NULL} is returned.
@item Usage example
@example
int *p;

p = (int *) pdf_alloc (sizeof(int));
*p = 666;
@end example
@end table


@end deftypefun

@deftypefun void pdf_dealloc (const void *@var{pointer})

Deallocates heap memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer pointing to the memory we want to deallocate. The memory to
deallocate should have been previously allocated using
@code{pdf_alloc}.
@end table

@item Returns
None.
@item Usage Example

@example
char *p;

p = (char *) pdf_alloc (21);
pdf_dealloc (p);
@end example
@end table
@end deftypefun

@deftypefun void* pdf_realloc (const void *@var{pointer}, const pdf_size_t @var{size})

Reallocates memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer to previously allocated memory.

The memory to reallocate should have been allocated using
@code{pdf_alloc} or @code{pdf_realloc}.
@item size
The new size of the allocated memory chunk.

If the requested size is shorter than the original size of the
allocated memory then it is truncated. Any previous contents in the
memory will be lost.

If the requested size is larger or equal than the original size of the
allocated memory then the previous contents of the allocated memory
remains. The contents of newly allocated memory are undetermined.

If there is not enough available memory to satisfy the request, then a
fatal error is signaled killing the current process. An error status
is returned to the operating system.
@end table

@item Returns
A pointer to the reallocated memory.
@item Usage Example
@example
char *p;

p = (char *) pdf_alloc (4);
strncpy (p, "abcd", 4);

/* p now points to "abcd" */

p = (char *) pdf_realloc (5);
p[4] = 'e';

/* p now points to "abcde" */

p = (char *) pdf_realloc (4);

/* p now points to "abcd" */

pdf_dealloc (p);
@end example
@end table
@end deftypefun

@node Basic Types
@section Basic Types

@menu
* Boolean Types::
* Numeric Types::
* Big Numbers::
* Memory Buffers::
* Progress Monitors::
@end menu

@node Boolean Types
@subsection Boolean Types

@deftp {Data Type} pdf_bool_t
A boolean value.
@end deftp

The following constants define the valid values to be held in a
@code{pdf_bool_t} variable:

@deftp {Constant} PDF_TRUE
Logical true.
@end deftp

@deftp {Constant} PDF_FALSE
Logical false.
@end deftp

@node Numeric Types
@subsection Numeric Types

@deftp {Data Type} pdf_i32_t
Signed 32 bits integer.
@end deftp

@deftp {Data Type} pdf_u32_t
Unsigned 32 bits integer.
@end deftp

The following constants specify the valid ranges for these data types:

@deftp {Constant} PDF_I32_MAX
Maximum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_I32_MIN
Minimum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MAX
Maximum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MIN
Minimum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@node Big Numbers
@subsection Big Numbers

An implementation of big numbers (64 bit) is also provided. This data type
can be used in machines not providing true 64 bit integers.

@deftp {Data Type} pdf_i64_t
A variable of type pdf_i64_t is capable of representing a 64 bit signed integer.
@end deftp

@deftypefun pdf_i64_t  pdf_i64_new (const pdf_i32_t @var{high}, const pdf_u32_t @var{low})

Create a new i64 variable from one 32 bit signed integer and a 32 bit unsigned integer.

@table @strong
@item Parameters
@table @var
@item high
The high (signed) part of the 64 bit integer.
@item low
The low (unsigned) part of the 64 bit integer.
@end table
@item Returns
The newly created i64 object.
@item Usage example
@example
pdf_i64_t bignum;

bignum = pdf_i64_new((1 << 31),10); /*bignum is now -10*/
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_assign (pdf_i64_t *@var{bignum}, const pdf_i32_t @var{high}, const pdf_u32_t @var{low}, pdf_status_t *@var{p_status})

Assign a value based on a 32 bit signed integer and a 32 bit
unsigned integer to a 64 bit integer.

@table @strong
@item Parameters
@table @var
@item bignum
Variable that stores a 64 bit integer
@item high
The high (signed) part of the 64 bit integer.
@item low
The low (unsigned) part of the 64 bit integer.
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{bignum}.
@end table
@item Usage example
@example
pdf_i64_t *bignum;
pdf_i64_t result;
pdf_status_t *p_status;
result = pdf_i64_new(0, 0);
bignum = &result;

pdf_i64_assign(bignum, (1 << 31), 10, p_status);
if (*p_status != PDF_OK) /*bignum is now -10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_assign_quick (pdf_i64_t *@var{bignum}, const pdf_i32_t @var{value}, pdf_status_t *@var{p_status})

Assign a value coming from one 32 bit signed integer to a 64 bit signed integer.

Note that if the client is in a system supporting true 64 bit scalar
types, @code{pdf_i64_assign_quick} will be a macro that will also
accept a 64 bit value.

@table @strong
@item Parameters
@table @var
@item value
A signed 32 bit integer
@item bignum
Variable that stores 64 bit integer
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{bignum}.
@end table
@item Usage example
@example
pdf_i64_t *bignum;
pdf_i64_t result;
pdf_status_t *p_status;
result = pdf_i64_new(0, 0);
bignum = &result;
pdf_i64_assign_quick(bignum, -10, p_status);
if (*p_status != PDF_OK) /*bignum is now -10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_copy (const pdf_i64_t @var{orig}, pdf_i64_t *@var{copy}, pdf_status_t *@var{p_status})

Copies the data from orig to copy.

@table @strong
@item Parameters
@table @var
@item orig
Original variable whose data is to be copied.
@item copy
Variable where data is copied to.
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{bignum}.
@end table
@item Usage example
@example
pdf_i64_t orig;
pdf_i64_t *copy;
pdf_status_t *p_status;
orig = pdf_i64_new(0, 10);
pdf_i64_copy(orig, copy, p_status)
if ( *p_status != PDF_OK) /*Now copy is also 10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_add (pdf_i64_t *@var{dest}, const pdf_i64_t @var{addend1}, const pdf_i64_t @var{addend2}, pdf_status_t *@var{p_status})

Adds two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item addend1
First addend of the sum
@item addend2
Second addend of the sum
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{bignum}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t addend_1;
pdf_i64_t addend_2;
pdf_status_t *p_status;
addend_1 = pdf_i64_new(0, 25);
addend_2 = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_add (dest, addend_1, addend_2, &p_status);
if (*p_status != PDF_OK) /* Now dest is 60 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_add_i32 (pdf_i64_t *@var{dest}, const pdf_i64_t @var{addend1}, const pdf_i32_t @var{addend2}, pdf_status_t *@var{p_status})

Adds a 64bit number and a 32bit number.

@table @strong
@item Parameters
@table @var
@item addend1
First addend of the sum (64bit type)
@item addend2
Second addend of the sum (32 bit)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t addend_1;
pdf_status_t *p_status;
addend_1 = pdf_i64_new(0, 25);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_add (dest, addend_1, 35,p_status)
if (*p_status != PDF_OK) /* Now dest is 60 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_subtraction (pdf_i64_t *@var{dest}, const pdf_i64_t @var{minuend}, const pdf_i64_t @var{subtrahend}, pdf_status_t *@var{p_status})

Finds the difference between two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item minuend
The minuend of the subtraction
@item subtrahend
The subtrahend of the subtraction
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{bignum}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t minuend;
pdf_i64_t subtrahend;
pdf_status_t *p_status;
minuend = pdf_i64_new(0, 25);
subtrahend = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_subtraction (dest, minuend, subtrahend,p_status)
if (*p_status != PDF_OK) /* Now dest is -10 */
@{
  /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_subtraction_i32_min (pdf_i64_t *@var{dest}, const pdf_i32_t @var{minuend}, const pdf_i64_t @var{subtrahend}, pdf_status_t *@var{p_status})

Finds the difference between a 32 bit number and a 64 bit number

@table @strong
@item Parameters
@table @var
@item minuend
The minuend of the subtraction (32 bits)
@item subtrahend
The subtrahend of the subtraction (64 bits type)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t subtrahend;
pdf_status_t *p_status;
subtrahend = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_subtraction (dest, 25, subtrahend, p_status)
if (*p_status != PDF_OK) /* Now dest is -10 */
@{
  /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_subtraction_i32_sub (pdf_i64_t *@var{dest}, const pdf_i64_t @var{minuend}, const pdf_i32_t @var{subtrahend}, pdf_status_t *@var{p_status})

Finds the difference between a 64 bit number and a 32 bit number

@table @strong
@item Parameters
@table @var
@item minuend
The minuend of the subtraction (64 bits type)
@item subtrahend
The subtrahend of the subtraction (32 bits)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t minuend;
pdf_status_t *p_status;
minuend = pdf_i64_new(0, 25);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_subtraction (dest, minuend, 35, p_status);
if ( != PDF_OK) /* Now dest is -10 */
@{
  /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_mult (pdf_i64_t *@var{dest}, const pdf_i64_t @var{factor_1}, const pdf_i64_t @var{factor_2}, pdf_status_t *@var{p_status})

Multiplication of two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item factor_1
First factor in the multiplication
@item factor_2
Second factor in the multiplication
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{bignum}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t factor_1;
pdf_i64_t factor_2;
pdf_status_t *p_status;
factor_1 = pdf_i64_new (0, 10);
factor_2 = pdf_i64_new (0, 100);
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_mult (dest, factor_1, factor_2,p_status);
if ( *p_status != PDF_OK) /* Now dest is 1000 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_mult_i32 (pdf_i64_t *@var{dest}, const pdf_i64_t @var{factor_1}, const pdf_i32_t @var{factor_2}, pdf_status_t *@var{p_status})

Multiplication of a 64 bit number and a 32 bit number

@table @strong
@item Parameters
@table @var
@item factor_1
First factor in the multiplication (64 bits)
@item factor_2
Second factor in the multiplication (32bits)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t factor_1;

factor_1 = pdf_i64_new (0, 10);
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_mult (dest, factor_1, 100,p_status)
if (*p_status != PDF_OK) /* Now dest is 1000 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_div (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Division of two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division
@item divisor
The divisor in the division
@item dest
Where 64 bit result is stored
@end table
@item Returns
PDF_OK	Operation successful
@item PDF_EDIVBYZERO
Division by zero.
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;
pdf_i64_t divisor;

dividend = pdf_i64_new(0, 200);
divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_div (dest, dividend, divisor,p_status);
if(*p_status  != PDF_OK) /* Now dest is 20 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_div_i32_dividend (pdf_i64_t *@var{dest}, const pdf_i32_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Division of a 32bit number and a 64bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (64 bits)
@item divisor
The divisor in the division (32 bits)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK 
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t divisor;

divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_div (dest, 200, divisor) != PDF_OK) /* Now dest is 20 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_div_i32_divisor (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i32_t @var{divisor}, pdf_status_t *@var{p_status})

Division of a 64bit number and a 32bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (64 bits)
@item divisor
The divisor in the division (32 bits)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful.
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;

dividend = pdf_i64_new(0, 200);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_div (dest, dividend, 10) != PDF_OK) /* Now dest is 20 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_mod (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Returns the remainder of the division between two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division
@item divisor
The divisor in the division
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@var{dest} is null
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;
pdf_i64_t divisor;
pdf_status_t *p_status;
dividend = pdf_i64_new(0, 105);
divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_mod (dest, dividend, divisor,p_status);
if ( *p_status != PDF_OK) /* Now dest is 5 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_mod_i32_dividend (pdf_i64_t *@var{dest}, const pdf_i32_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Returns the remainder of the division between a 32 bit number and a 64 bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (32bits)
@item divisor
The divisor in the division (64bits)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t divisor;

divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_mod (dest, 105, divisor) != PDF_OK) /* Now dest is 5 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_mod_i32_divisor (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i32_t @var{divisor}, pdf_status_t *@var{p_status})

Returns the remainder of the division between a 64 bit number and a 32 bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (64 bits)
@item divisor
The divisor in the division (32 bits)
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;

dividend = pdf_i64_new(0, 105);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_mod (dest, dividend, 10) != PDF_OK) /* Now dest is 5 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_abs (pdf_i64_t *@var{dest}, const pdf_i64_t @var{number}, pdf_status_t *@var{p_status})

Returns the absolute value

@table @strong
@item Parameters
@table @var
@item number
pdf_i64_t type variable
@item dest
Where 64 bit result is stored
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t number;
pdf_status_t *p_status;
number = pdf_i64_new ((1 << 31), 105); /*number is -105*/
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_abs (dest, number,p_status)
if ( *p_status != PDF_OK) /* now dest stores 105 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun int pdf_i64_cmp (const pdf_i64_t @var{number_1}, const pdf_i64_t @var{number_2})

Compares two 64 bit integers

@table @strong
@item Parameters
@table @var
@item number_1
pdf_i64_t type variable
@item number_2
pdf_i64_t type variable
@end table
@item Returns
An integer:
@table @code
@item 0
If numbers are equal
@item 1
If @var{number_1} is greater than @var{number_2}
@item -1
If @var{number_2} is greater than @var{number_1}
@end table
@item Usage example
@example
pdf_i64_t number_1;
pdf_i64_t number_2;
int result;

number_1 = pdf_i64_new ((1 << 31), 10); /* number_1 is -10 */
number_2 = pdf_i64_new (0, 10); /* number_2 is 10 */
result = pdf_i64_cmp (number_1, number_2); /* Now result is -1 */
@end example
@end table
@end deftypefun

@deftypefun int pdf_i64_cmp_i32 (const pdf_i64_t @var{number_1}, const pdf_i32_t @var{number_2})

Compares a 64 bit number and a 32 bit number

@table @strong
@item Parameters
@table @var
@item number_1
pdf_i64_t type variable
@item number_2
pdf_i32_t type variable
@end table
@item Returns
An integer:
@table @code
@item 0
If numbers are equal
@item 1
If @var{number_1} is greater than @var{number_2}
@item -1
If @var{number_2} is greater than @var{number_1}
@end table
@item Usage example
@example
pdf_i64_t number_1;
int result;

number_1 = pdf_i64_new ((1 << 31), 10); /* number_1 is -10 */
result = pdf_i64_cmp (number_1, 10); /* Now result is -1 */
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_neg (pdf_i64_t *@var{dest}, const pdf_i64_t @var{number}, pdf_status_t *@var{p_status})

Changes sign of 64 bit integer

@table @strong
@item Parameters
@table @var
@item number
pdf_i64_t type variable
@item p_status
Pointer to a pdf_status_t variable to hold the status of the
operation. If it is @code{NULL} then this parameter is ignored.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
@code{NULL} value in @var{dest}.
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t number;
pdf_status_t *p_status;
number = pdf_i64_new (0, 10);
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_neg (dest, number,p_status)
if ( *p_status != PDF_OK) /* now dest stores -10 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_i32_t pdf_i64_to_i32 (const pdf_i64_t @var{bignum})

Converts a pdf_i64_t to a 32 bit value. If number can't be represented in 32 bits
the result is undefined, so should be used with caution.

@table @strong
@item Parameters
@table @var
@item bignum
pdf_i64_t type variable
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i32_t num;
pdf_i64_t bignum;

bignum = pdf_i64_new (0, 10);

num = pdf_i64_to_i32(bignum);

@end example
@end table
@end deftypefun

@node Memory Buffers
@subsection Memory Buffers

@deftp {Data Type} {struct pdf_buffer_s}

This structure contains the data associated to a simple memory
buffer.

@table @code
@item data
Pointer to the buffer contents.
@item size
Number of octects allocated in @code{data}.
@item rp
Current read pointer.
@item wp
Current write pointer.
@end table
@end deftp

@deftp {Data Type} pdf_buffer_t
Pointer to a @code{pdf_buffer_s} structure.
@end deftp

@deftypefun pdf_buffer_t pdf_buffer_new (pdf_size_t @var{size})

Create a new memory buffer.

@table @strong
@item Parameters
@table @var
@item size
The size of the new buffer, in octects.
@end table
@item Returns
A pointer to a @code{pdf_buffer_s} structure, or @code{NULL} if there
is not enough memory to serve the petition.
@item Usage example
@example
pdf_buffer_t my_buffer;

my_buffer = pdf_buffer_new (1024);
if (my_buffer == NULL)
@{
   /* Not enough memory */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_buffer_destroy (pdf_buffer_t @var{buffer})

Destroy a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
A pointer to the buffer that will be destroyed.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation suceeded.
@end table
@item Usage example
@example
pdf_buffer_t my_buffer;

my_buffer = pdf_buffer_new (1024);
pdf_buffer_destroy (my_buffer);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_buffer_full_p (pdf_buffer_t @var{buffer})

Determine whether a memory buffer is full.

@table @strong
@item Parameters
@table @var
@item buffer
A pointer to a buffer.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_OK
The buffer is full.
@item PDF_FALSE
The buffer is not full.
@end table
@item Usage example
@example
int i;
pdf_buffer_t my_buffer;

/* Create a new buffer */
my_buffer = pdf_buffer_new (1024);

/* Fill the entire buffer */
for (i = 0; i < 1024; i++)
@{
   my_buffer->data[my_buffer->wp++] = 'a';
@}

/* The buffer should be full now */
if (pdf_buffer_full_p (my_buffer))
@{
   /* Buffer full */
@}

pdf_buffer_destroy (my_buffer);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_buffer_eob_p (pdf_buffer_t @var{buffer})

Determine whether a memory buffer is in an end-of-buffer state.

@table @strong
@item Parameters
@table @var
@item buffer
A pointer to a memory buffer.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The buffer is in an end-of-buffer state.
@item PDF_FALSE
The buffer is not in an end-of-buffer state.
@end table
@item Usage example
@example
pdf_buffer_t my_buffer;
pdf_char_t my_char;

/* Create a new buffer */
my_buffer = pdf_buffer_new (3);

/* Copy some contents into the buffer, filling it entirely */
strncpy (my_buffer->data, "abc", 3);
my_buffer->wp += 3;

/* Read data from the buffer until an eob condition */
while (!pdf_buffer_eob_p (my_buffer))
@{
   my_char = my_buffer->data[my_buffer->rp++];
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_buffer_resize (pdf_buffer_t @var{buffer}, pdf_size_t @var{newsize})

Resize a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
A pointer to a memory buffer.
@item newsize
The new size (in octects) for the buffer.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@item Usage example
@example
pdf_buffer_t my_buffer;
pdf_char_t my_char;
pdf_char_t *my_string;
pdf_size_t my_string_size;
pdf_size_t written_bytes;

/* Create a string */
my_string_size = 10;
my_string = pdf_alloc (my_string_size);
strncpy (my_string, "0123456789", 10);
my_string[10] = 0;

/* Create a new buffer */
my_buffer = pdf_buffer_new (4);

/* Copy the contents of my_string into my_buffer making it larger in
   chunks of 4 bytes */
written_bytes = 0;
while (written_bytes < my_string_size)
@{
   if (pdf_buffer_full_p (my_buffer))
   @{
      /* Grow the buffer */
      pdf_buffer_resize (my_buffer,
                         my_buffer->wp + 5);
   @}

   my_buffer->data[my_buffer->wp] = my_string[my_buffer->wp];
   my_buffer->wp++;
@}

/* Adjust the buffer size */
pdf_buffer_resize (my_buffer, my_string_size);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_buffer_rewind (pdf_buffer_t @var{buffer})

Rewind a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
A pointer to a memory buffer.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_buffer_t my_buffer;

/* Create a new buffer and initialize its contents */
my_buffer = pdf_buffer_new (3);
strncpy (my_buffer->data, "abc", 3);
my_buffer->wp += 3;

/* Replace the contents */
pdf_buffer_rewind (my_buffer);
strncpy (my_buffer->data, "ABC", 3);
my_buffer->wp += 3;
@end example
@end table
@end deftypefun

@node Progress Monitors
@subsection Progress Monitors

The client application of the library may want to monitor the progress
of some operations, such as the saving of a document. The @code{struct
pdf_pm_s} structure provides a way for the client application to
specify callbacks implemented by a progress monitor.

@deftp {Data Type} {struct pdf_pm_s}

Structure containing several callbacks to be called as an operation
progress.

@table @code
@item pdf_pm_begin_operation_fn_t begin_operation_fn
@item pdf_pm_end_operation_fn_t end_operation_fn
@item pdf_pm_get_duration_fn_t get_duration_fn
@item pdf_pm_set_duration_fn_t set_duration_fn
@item pdf_pm_get_current_value_fn_t get_current_value_fn_t
@item pdf_pm_set_current_value_fn_t set_current_value_fn_t
@item pdf_pm_set_text_fn_t set_text_fn
@end table
@end deftp

The type definitions for the callbacks follows.

@deftp {Data Type} {pdf_status_t (*pdf_pm_begin_operation_fn_t) (void *@var{client_data})}
Callback implemented by a progress monitor that initializes it to a
current value of @code{0}.

@table @strong
@item Parameters
@table @var
@item client_data
User supplied data.
@end table
@item Returns
This callback should return @code{PDF_OK} to the caller.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_pm_end_operation_fn_t) (void *@var{client_data})}
Callback implemented by a progress monitor. This callback is called at
the end of the operation.

@table @strong
@item Parameters
@table @var
@item client_data
User supplied data.
@end table
@item Returns
This callback should return @code{PDF_OK} to the caller.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_pm_get_duration_fn_t) (void *@var{client_data}, void *@var{duration})}

Callback implemented by a progress monitor.

This callback is called to get the current value of the progress
monitor duration.
@table @strong
@item Parameters
@table @var
@item client_data
User supplied data.
@item duration
A pointer to a @var{pdf_time_span_t} variable to store the current
duration of the progress monitor.
@end table
@item Returns
This callback should return @code{PDF_OK} to the caller.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_pm_set_duration_fn_t) (void *@var{client_data}, void *@var{duration})}

Callback implemented by a progress monitor.

This callback is called to set the current value of the progress
monitor duration.
@table @strong
@item Parameters
@table @var
@item client_data
User supplied data.
@item duration
A pointer to a time span variable containing the new duration for the
progress monitor.
@end table
@item Returns
This callback should return @code{PDF_OK} to the caller.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_pm_get_current_value_fn_t) (void *@var{client_data}, void *@var{duration})}

Callback implemented by a progress monitor.

This callback is called to get the current value of the progress
monitor duration.
@table @strong
@item Parameters
@table @var
@item client_data
User supplied data.
@item duration
A pointer to a @var{pdf_time_span_t} variable to store the current
duration of the progress monitor.
@end table
@item Returns
This callback should return @code{PDF_OK} to the caller.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_pm_set_current_value_fn_t) (void *@var{client_data}, void *@var{duration})}

Callback implemented by a progress monitor.

This callback is called to set the current value of the progress
monitor duration.
@table @strong
@item Parameters
@table @var
@item client_data
User supplied data.
@item duration
A time span variable containing the new duration for the progress
monitor.
@end table
@item Returns
This callback should return @code{PDF_OK} to the caller.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_pm_set_text_fn_t) (void *@var{client_data}, void *@var{text})}

Callback implemented by a progress monitor.

This callback is called to set the description of the current status
of the operation to the progress monitor.
@table @strong
@item Parameters
@table @var
@item client_data
User supplied data.
@item text
A text variable containing the new description.
@end table
@item Returns
This callback should return @code{PDF_OK} to the caller.
@end table
@end deftp

@node Hash Tables
@section Hash Tables

@menu
* Hash Table Types::
* Creating and Destroying Hash Tables::
* Hash Table properties::
* Working with keys::
* Adding and removing elements::
* Searching elements::
* Working with iterators::
* Basic dispose functions::
* Hash helper functions::
@end menu

@node Hash Table Types
@subsection Hash Table Types

@deftp {Data Type} pdf_hash_t

A Hash Table able to store key/value pairs. A key may be any
NULL-terminated string.
@end deftp

@deftp {Data Type} pdf_hash_iterator_t

An iterator over the keys of a Hash Table.
@end deftp

@deftp {Data Type} void (*pdf_hash_element_dispose_fn_t) (const void *elt)
A function type for disposing hash elements.
@end deftp

@deftp {Data Type} void (*pdf_hash_key_dispose_fn_t) (const void *key)
A function type for disposing hash keys.
@end deftp

@node Creating and Destroying Hash Tables
@subsection Creating and Destroying Hash Tables

@deftypefun pdf_status_t pdf_hash_new (pdf_hash_key_dispose_fn_t @var{dispose_key_fn}, pdf_hash_t @var{*table})

Create a new empty hash table. When some element is removed @var{dispose_key_fn} are called, can be NULL.

@table @strong
@item Parameters
@table @var
@item dispose_key_fn
A pointer to a hash table element key dispose function or NULL.
@item table
A pointer to a hash table.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Invalid @var{table} pointer.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create an instance of a hash without a disposal function */
if (pdf_hash_new (NULL, &hash) != PDF_OK)
   @{
      /* Error creating the hash table */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_destroy (pdf_hash_t @var{table})

Destroy a hash table. The elements of the table are disposed first.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_hash_t hash;

if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
else
   @{
      /* Error creating the hash table */
   @}
@end example
@end table
@end deftypefun

@node Hash Table properties
@subsection Hash Table properties

@deftypefun pdf_size_t pdf_hash_size (const pdf_hash_t @var{table})

Returns the number of entries in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@end table
@item Returns
The number of entries.
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

      /* This call should return 3 */
      pdf_hash_size (hash);
   @}
@end example
@end table
@end deftypefun

@node Working with keys
@subsection Working with keys

@deftypefun pdf_bool_t pdf_hash_key_p (const pdf_hash_t @var{table}, const char *@var{key})

Returns a boolean value indicating whether an element with key @var{key} exists in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@end table
@item Returns
A pdf boolean value:
@table @code
@item PDF_TRUE
An element associated with @var{key} exists.
@item PDF_FALSE
There is no element associated with @var{key}.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program enters here */
         @}
      if (pdf_hash_key_p (hash, "x-key"))
         @{
            /* The program doesnt reach this */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_rename (pdf_hash_t @var{table}, const char @var{*key}, const char @var{*new_key})

Renames the key @var{key} to @var{new_key} in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item new_key
A valid key string.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeded.
@item PDF_ERROR
The @var{key} is not associated with any element in @var{table}.
@item PDF_EBADDATA
Either @var{table} or a key string is invalid or NULL.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add an element to the hash */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program enters here */
         @}

      /* Rename the key */
      pdf_hash_rename (hash, "a-key", "b-key");

      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program doesnt enter here */
         @}

      if (pdf_hash_key_p (hash, "b-key"))
         @{
            /* The program enters here */
         @}
   @}
@end example
@end table
@end deftypefun

@node Adding and removing elements
@subsection Adding and removing elements

@deftypefun pdf_status_t pdf_hash_add (pdf_hash_t @var{table}, const char @var{*key}, const void @var{*element}, pdf_hash_element_dispose_fn_t @var{disp_fn} )

Adds the element @var{element} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item element
A pointer to the element being added.
@item disp_fn
A function called when @var{element} is removed. If NULL is given nothing is done.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{element} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_remove (pdf_hash_t @var{table}, const char @var{*key})

Removes the element associated with @var{key} from @var{table}. The element is disposed first.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid @var{table} or @var{key}.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add an element to the hash... */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      /* And remove it */
      pdf_hash_remove (hash, "a-key");
   @}
@end example
@end table
@end deftypefun

@node Searching elements
@subsection Searching elements

@deftypefun pdf_status_t pdf_hash_get (const pdf_hash_t @var{table}, const char @var{*key}, const void **@var{elem_pointer})

Searches for the element associated with the given @var{key} in @var{table} and store it in @var{elem_pointer}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid null-terminated string key.
@item elem_pointer
A pointer where to store the element.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Either @var{elem_pointer} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_hash_t hash;
char *elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add an element to the hash... */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      /* Get the element from the hash */
      pdf_hash_search (hash, "a-key", (void **) &elem);
   @}
@end example
@end table
@end deftypefun

@node Working with iterators
@subsection Working with iterators

@deftypefun pdf_status_t pdf_hash_iterator_new (const pdf_hash_t @var{table}, pdf_hash_iterator_t @var{*iterator})

Creates an iterator over the keys of @var{table} and saves it in @var{iterator}. Keys composed only by numbers are returned first followed by keys in the order imposed by the ``strcmp()'' function.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item iterator
A pointer to an iterator.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Either @var{iterator} is NULL or @var{table} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_iterator_t hash_iter;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

      /* Get an iterator to the first element of the hash */
      pdf_hash_iterator_new (hash, &hash_iter);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_iterator_next (pdf_hash_iterator_t @var{iterator}, const char **@var{key})

Retrieves the next key from @var{iterator}.

@table @strong
@item Parameters
@table @var
@item iterator
A Hash Table iterator pointer.
@item key
A pointer where to save the key.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Either @var{iterator} is invalid or @var{key} is NULL.
@item PDF_ERROR
There are no more keys to traverse over.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_iterator_t hash_iter;
pdf_char_t *key;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

     /* Traverse all the values of the hash with an iterator */
     pdf_hash_iterator_new (hash, &hash_iter);
     while (pdf_hash_iterator_next (hash_iter, &key) != PDF_ERROR)
      @{
         /* key contains the next key */
      @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_iterator_destroy (pdf_hash_iterator_t @var{iterator})

Free all resources used by @var{iterator}.

@table @strong
@item Parameters
@table @var
@item iterator
A Hash Table iterator pointer.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_iterator_t hash_iter;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

      /* Get an iterator to the first element of the hash */
      pdf_hash_iterator_new (hash, &hash_iter);

      /* Destroy the iterator */
      pdf_hash_iterator_destroy (hash_iter);
   @}
@end example
@end table
@end deftypefun

@node Basic dispose functions
@subsection Basic dispose functions

These are the basic function implementations to free elements and
keys. They should only be used if you allocated elements/keys with
pdf_alloc() and don't need to free any other resource.

@deftypefun void pdf_hash_element_dealloc_fn (const void * @var{elt})

Deallocates @var{elt} with pdf_dealloc().

@table @strong
@item Parameters
@table @var
@item elt
A pointer to the element being freed.
@end table
@item Returns
Nothing.
@item Usage example
@example
pdf_hash_t hash;
pdf_char_t *elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Allocate memory for a value to be inserted into the hash */
      elem = pdf_alloc (sizeof(pdf_char_t) * 4);
      strcpy ((char *) elem, "abc");

      /* Add an element to the hash, specifying
         pdf_hash_element_dealloc_fn as its disposal
         function */
      pdf_hash_add (hash,
                    "a-key",
                    (void *) elem,
                    pdf_hash_element_dealloc_fn);

      /* Destroy the hash (the disposal function invokes pdf_dealloc
         in the allocated string */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun void pdf_hash_key_dealloc_fn (const void * @var{elt})

Deallocates @var{elt} with pdf_dealloc().

@table @strong
@item Parameters
@table @var
@item elt
A pointer to the element being freed.
@end table
@item Returns
Nothing.
@item Usage example
@example
pdf_hash_t hash;
pdf_char_t *key;

/* Create a new hash */
if (pdf_hash_new (pdf_hash_key_dealloc_fn, &hash) == PDF_OK)
   @{
      /* Allocate memory for a key to be used into the hash */
      key = pdf_alloc (sizeof(pdf_char_t) * 4);
      strcpy ((char *) elem, "abc");

      /* Add an element to the hash, using the key */
      pdf_hash_add (hash, key, "abc", NULL);

      /* Destroy the hash (the key disposal function invokes pdf_dealloc
         in the allocated string */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@node Hash helper functions
@subsection Hash helper functions

These are specific functions for adding and getting different types of
elements (types defined by the library). They guarantee that when an
element of one of these types is removed from a hash table the correct
disposal function is called.

NOTE: If you are going to use the element after the table containing
the element is destroyed, in that case don't use these functions.

@deftypefun pdf_status_t pdf_hash_add_text (pdf_hash_t @var{table}, const char @var{*key}, const pdf_text_t @var{*elt})

Adds the text @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_text_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_text_new_from_unicode ("abc", 3,
                                 PDF_TEXT_UTF8,
                                 &hash);

      /* Add an element to the hash, specifying
         pdf_hash_element_dealloc_fn as its disposal
         function */
      pdf_hash_add_text (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_get_text (pdf_hash_t @var{table}, const char *@var{key}, pdf_text_t *@var{elt})

Get a text variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
The key associated with the desired value.
@item elt
A pointer to the text variable to hold the value.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The value was successfully stored into @var{elt}.
@item PDF_EBADDATA
Either @var{elt} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_text_t text;
pdf_hash_t table;

/* ... insert a text variable into the hash ... */
if (pdf_hash_get_text (table, "a text", &text) != PDF_OK)
   @{
      /* Error */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_add_time (pdf_hash_t @var{table}, const char @var{*key}, const pdf_time_t @var{*elt})

Adds the time @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_time_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_time_new (&elem);

      /* Add an element to the hash */
      pdf_hash_add_time (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_get_time (pdf_hash_t @var{table}, const char *@var{key}, pdf_time_t *@var{elt})

Get a time variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
The key associated with the desired value.
@item elt
A pointer to the time variable to hold the value.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The value was successfully stored into @var{elt}.
@item PDF_EBADDATA
Either @var{elt} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_time_t time;
pdf_hash_t table;

/* ... insert a time variable into the hash ... */
if (pdf_hash_get_time (table, "a time", &time) != PDF_OK)
   @{
      /* Error */
   @}
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_hash_add_list (pdf_hash_t @var{table}, const char @var{*key}, const pdf_list_t @var{*elt})

Adds the list @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_list_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_list_new (&elem);

      /* Add an element to the hash */
      pdf_hash_add_list (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_get_list (pdf_hash_t @var{table}, const char *@var{key}, pdf_list_t *@var{elt})

Get a list variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
The key associated with the desired value.
@item elt
A pointer to the list variable to hold the value.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The value was successfully stored into @var{elt}.
@item PDF_EBADDATA
Either @var{elt} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_hash_t table;

/* ... insert a list variable into the hash ... */
if (pdf_hash_get_list (table, "a list", &list) != PDF_OK)
   @{
      /* Error */
   @}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_hash_add_hash (pdf_hash_t @var{table}, const char @var{*key}, const pdf_hash_t @var{*elt})

Adds the hash table @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_hash_new (&elem);

      /* Add an element to the hash */
      pdf_hash_add_hash (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_get_hash (pdf_hash_t @var{table}, const char *@var{key}, pdf_hash_t *@var{elt})

Get a hash variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
The key associated with the desired value.
@item elt
A pointer to the hash variable to hold the value.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The value was successfully stored into @var{elt}.
@item PDF_EBADDATA
Either @var{elt} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_t table;

/* ... insert a hash variable into the hash ... */
if (pdf_hash_get_hash (table, "a hash", &hash) != PDF_OK)
   @{
      /* Error */
   @}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_hash_add_stm (pdf_hash_t @var{table}, const char @var{*key}, const pdf_stm_t @var{*elt})

Adds the stream @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_stm_t elem;
pdf_char_t *buf;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      buf = pdf_alloc (10);
      pdf_stm_mem_new (buf,
                       10,
                       0, /* Use default cache size */
                       PDF_STM_READ,
                       &stm);

      /* Add the element to the hash */
      pdf_hash_add_hash (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);

      /* Destroy the memory buffer */
      pdf_dealloc (buf);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_get_stm (pdf_hash_t @var{table}, const char *@var{key}, pdf_stm_t *@var{elt})

Get a stm variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
The key associated with the desired value.
@item elt
A pointer to the stm variable to hold the value.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The value was successfully stored into @var{elt}.
@item PDF_EBADDATA
Either @var{elt} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_stm_t stm;
pdf_hash_t table;

/* ... insert a stm variable into the hash ... */
if (pdf_hash_get_stm (table, "a stm", &stm) != PDF_OK)
   @{
      /* Error */
   @}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_hash_add_size (pdf_hash_t @var{table}, const char *@var{key}, const pdf_size_t @var{elt})

Adds the @code{pdf_size_t} value @var{elt} with the associated key
@var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A @code{pdf_size_t} value.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_size_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      elem = 10;

      /* Add the element to the hash */
      pdf_hash_add_size (hash, "a-key", elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);

      /* Destroy the memory buffer */
      pdf_dealloc (buf);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_get_size (pdf_hash_t @var{table}, const char *@var{key}, pdf_size_t *@var{elt})

Get a size variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
The key associated with the desired value.
@item elt
A pointer to the size variable to hold the value.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The value was successfully stored into @var{elt}.
@item PDF_EBADDATA
Either @var{elt} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_size_t size;
pdf_hash_t table;

/* ... insert a size variable into the hash ... */
if (pdf_hash_get_size (table, "a size", &size) != PDF_OK)
   @{
      /* Error */
   @}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_hash_add_string (pdf_hash_t @var{table}, const char *@var{key}, const pdf_char_t *@var{elt})

Adds the @code{*pdf_char_t} value @var{elt} with the associated key
@var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A @code{* pdf_char_t} value.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_char_t *elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      elem = pdf_alloc(4);
      strncpy (elem, "abc", 4);

      /* Add the element to the hash */
      pdf_hash_add_size (hash, "a-key", elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);

      /* Destroy the memory buffer */
      pdf_dealloc (buf);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_get_string (pdf_hash_t @var{table}, const char *@var{key}, pdf_char_t **@var{elt})

Get a string variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
The key associated with the desired value.
@item elt
A pointer to the string variable to hold the value.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The value was successfully stored into @var{elt}.
@item PDF_EBADDATA
Either @var{elt} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_char_t *string;
pdf_hash_t table;

/* ... insert a string variable into the hash ... */
if (pdf_hash_get_string (table, "a string", &string) != PDF_OK)
   @{
      /* Error */
   @}
@end example
@end table
@end deftypefun


@node Lists
@section Lists

This section describes how to work with unsorted and sorted lists. In case you're going to work with a sorted list, you should use the sorted version of each function if it's available. @xref{Working with sorted lists}.

@menu
* List Data Types::
* Creating and Destroying Lists::
* Managing List Properties::
* Searching for List Elements::
* Setting and Getting List Elements::
* Adding and Removing List Elements::
* Working with sorted lists::
* Working with Iterators::
@end menu

@node List Data Types
@subsection List Data Types

@deftp {Data Type} pdf_list_t
A list composed by zero or more nodes.
@end deftp

@deftp {Data Type} pdf_list_node_t
A list node. Each node is able to contain a data structure via a void
npointer.
@end deftp

@deftp {Data Type} pdf_list_iterator_t
A list iterator.
@end deftp

@deftp {Data Type} bool (*pdf_list_element_equals_fn_t) (const void *elt1, const void *elt2)
A function type for comparing list elements equality. Should return PDF_TRUE in case they are equal and PDF_FALSE otherwise.
@end deftp

@deftp {Data Type} void (*pdf_list_element_dispose_fn_t) (const void *elt)
A function type for disposing list elements.
@end deftp

@deftp {Data Type} int (*pdf_list_element_compar_fn_t) (const void *elt1, const void *elt2)
A function type for comparing list elements. Should return an integer less than, equal to, or greater than zero corresponding to whether the first element is considered less than, equal to, or greater than the second element.
@end deftp

@deftp {Data Type} pdf_size_t (*pdf_list_element_hashcode_fn_t) (const void *elt)
A function type for calculating a Hash code given a list element. Should return the corresponding hash code.
@end deftp


@node Creating and Destroying Lists
@subsection Creating and Destroying Lists

@deftypefun pdf_status_t pdf_list_new (pdf_list_element_equals_fn_t @var{equals_fn}, pdf_list_element_dispose_fn_t @var{dispose_fn}, const pdf_bool_t @var{allow_duplicates}, pdf_list_t @var{*list})

Create a new list containing no elements.

@table @strong
@item Parameters
@table @var
@item equals_fn
A function to compare list elements.
It is used in sort operations.
@item dispose_fn
A function to dispose list elements.
It is used when destroying list elements.
@item allow_duplicates
This parameter indicate if the list is allowed to contain duplicate
elements (elements for which @var{equals_fn} evaluate to
@code{PDF_TRUE}).
@item list
A pointer to a list where the new one will be saved.
@end table
@item Returns
A status variable:
@table @code
@item PDF_OK
@var{list} contains a new empty list.
@item PDF_EBADDATA
@var{list} points to NULL.
@item PDF_ENOMEM
Not enough memory to create the list.
@end table
@item Usage example
@example
pdf_list_t mylist;

if (pdf_list_new (list_element_equal_p, list_element_destroy,  PDF_FALSE,
    &mylist) != PDF_OK)
  @{
    /* manage the error... */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_destroy (pdf_list_t @var{list})

Destroy a list freeing all used resources.
The elements of the list are disposed first.

@table @strong
@item Parameters
@table @var
@item list
The list to be destroyed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_list_t mylist;

/* ...create `mylist'... */

pdf_list_destroy (mylist);
@end example
@end table
@end deftypefun

@node Managing List Properties
@subsection Managing List Properties

@deftypefun pdf_size_t pdf_list_size (const pdf_list_t @var{list})

Get the number of elements contained into a given list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@end table
@item Returns
The number of elements inside @var{list}.
@item Usage example
@example
pdf_list_t mylist;
pdf_size_t num_elm;

/* ...insert some elements into `mylist'... */
num_elm = pdf_list_size (mylist);
@end example
@end table
@end deftypefun

@node Searching for List Elements
@subsection Searching for List Elements

@deftypefun pdf_status_t pdf_list_search (const pdf_list_t @var{list}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to search for.
@item node
The searched node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem;

/* Create the list */
if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert an element into the list */
      pdf_list_add_first (list, (void *) &elem, NULL);

      /* Search for that element into the list */
      if (pdf_list_search (list, (void *) &elem, &node) == PDF_OK)
         @{
            /* The program should reach this place */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_search_from (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index indicating the begin of the search.
@item node
The searched node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer.
@item PDF_EINVRANGE
@var{start_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem1;
int elem2;
int elem3;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);


      /* Search for an element into the list */
      if (pdf_list_search_from (list,
                                (void *) &elem1,
                                1,
                                &node) == PDF_OK)
         @{
            /* The program should never reach this place, since
               elem1 occupies the first position (0) in the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_search_from_to (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list, at a position >=
@var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index to the first list position to be searched.
@item end_index
Index to the last list position to be searched.
@item element
The element to search for.
@item node
The seached node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem1;
int elem2;
int elem3;
int elem4;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Search for an element into the list */
      if (pdf_list_search_from_to (list,
                                   (void *) &elem4,
                                   1, 3,
                                   &node) == PDF_OK)
         @{
            /* The program should never reach this place, since
               elem4 occupies the last position (3) in the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_next_node (const pdf_list_t @var{list}, const pdf_list_node_t @var{node}, pdf_list_node_t @var{*next})

Return the node immediately after the given node in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@item prev
A pointer where the next node will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
Next node not found.
@item PDF_EBADDATA
Invalid @var{next} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the node containing "elem1" */
      pdf_list_search (list, (void *) &elem1, &node_first);

      /* Get the next node in the list */
      pdf_list_next_node (list, first_node, &node_second);

      /* Now node_second is the node containing elem2 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_previous_node (const pdf_list_t @var{list}, const pdf_list_node_t @var{node}, pdf_list_node_t @var{*prev})

Return the node immediately before the given node in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@item prev
A pointer where the previous node will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
Previous node not found.
@item PDF_EBADDATA
Invalid @var{prev} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the node containing "elem2" */
      pdf_list_search (list, (void *) &elem2, &node_second);

      /* Get the previous node in the list */
      pdf_list_previous_node (list, second_node, &node_first);

      /* Now node_first is the node containing elem2 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_indexof (const pdf_list_t @var{list}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@end table
@item Usage Example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;
pdf_size_t index_of_elem2;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the index of elem2 */
      pdf_list_indexof (list, (void *) &elem2, &size_of_elem2);

      /* Now size_of_elem2 contains 1 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_indexof_from (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
An index to a position in @var{list}.
@item element
The element to search for.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;
int elem3;
int elem4;
pdf_size_t index_of_elem1;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Get the index of elem1 */
      if (pdf_list_indexof_from (list,
                                 1,
                                 (void *) &elem1,
                                 &size_of_elem1) == PDF_ENONODE)
         @{
            /* The program reaches this point, since elem1 occupies
               the first position into the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_indexof_from_to (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list, at a position >= @var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item element
A pointer to some user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;
int elem3;
int elem4;
pdf_size_t index_of_elem4;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Get the index of elem4 */
      if (pdf_list_indexof_from_to (list,
                                    1, 3,
                                    (void *) &elem1,
                                    &size_of_elem4) == PDF_ENONODE)
         @{
            /* The program reaches this point, since elem4 occupies
               the last position (3) into the list */
         @}
   @}
@end example
@end table
@end deftypefun

@node Setting and Getting List Elements
@subsection Setting and Getting List Elements

@deftypefun {void *} pdf_list_node_value (const pdf_list_t @var{list}, const pdf_list_node_t @var{node})

Get the element value represented by a list node.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node of @var{list}.
@end table
@item Returns
The element value represented by @var{node}.
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem1;
int *pointer_to_elem1;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert an element into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);

      /* Get the node of the element of the list */
      pdf_list_search (list, (void *) &elem1, &node);

      /* Get the value out of the node */
      pointer_to_elem1 = (int *) pdf_list_node_value (list, node);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_get_at (const pdf_list_t @var{list}, const pdf_size_t @var{position}, const void @var{**value})

Get the element at a given position in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@item value
A pointer to which the element will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid @var{position}
@item PDF_EBADDATA
Invalid @var{value} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
int elem1;
int *pointer_to_elem1;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert an element into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);

      /* Get the first element of the list */
      pdf_list_get_at (list, 0, &pointer_to_elem_1);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_set_at (pdf_list_t @var{list}, const pdf_size_t @var{position}, const void* @var{element}, pdf_list_node_t @var{*node})

Replace the element at a given position in a list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@item element
The new element.
@item node
A pointer to save the node containing the replaced element or NULL.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid @var{position} range.
@item PDF_BADDATA
The list does not allow duplicated values and already contain
@var{element}.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_u32_t a;
pdf_u32_t b;
pdf_u32_t c;
pdf_u32_t x;

/* Create a list of integers */
if (pdf_list_new (NULL,
                  NULL,
                  PDF_FALSE, /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert the elements into the list */
      pdf_list_add_last (list, (void *) &a, NULL);
      pdf_list_add_last (list, (void *) &b, NULL);
      pdf_list_add_last (list, (void *) &c, NULL);

      /* Now the list contains abc */

      pdf_list_set_at (list, 1, (void *) &x, NULL);

      /* Now the list contains axc */
   @}
@end example
@end table
@end deftypefun

@node Adding and Removing List Elements
@subsection Adding and Removing List Elements

@deftypefun pdf_status_t pdf_list_add_first (pdf_list_t @var{list}, const void* @var{element}, pdf_list_node_t *@var{node})

Add an element as the first element of the list. If @var{node} is not
NULL then a reference to the newly created node is copied to it.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to the user data to be stored as a list element.
@item node
If non NULL, a list node variable used to contain the added element.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The element was inserted successfully.
@item PDF_EBADDATA
The list does not allow duplicated values and already contain
@var{element}.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_add_last (pdf_list_t @var{list}, const void* @var{element}, pdf_list_node_t *@var{node})

Add an element as the last element of the list. If @var{node} is not
NULL then a reference to the newly created node is copied to it.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to the user data to be stored as a list element.
@item node
If non NULL, a list node variable used to contain the added element.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The element was inserted successfully.
@item PDF_EBADDATA
The list does not allow duplicated values and already contain
@var{element}.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_add_at (pdf_list_t @var{list}, const pdf_size_t @var{position}, const void* @var{element}, pdf_list_node_t @var{*node})

Add an element at a given position in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in the list.
Should be @code{>= 0} and @code{<= pdf_list_size (list)}.
@item element
A pointer to the user data to be stored as a list element.
@item node
A pointer to the node where the given element was stored or NULL.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid range of given @var{position}.
@item PDF_BADDATA
The list does not allow duplicated values and already contain
@var{element}.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove_node (pdf_list_t @var{list}, const pdf_list_node_t @var{node})

Remove an element from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
The node to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove_at (pdf_list_t @var{list}, const pdf_size_t @var{position})

Remove an element at a given position from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid @var{position} range.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove (pdf_list_t @var{list}, const void * @var{element})

Search and remove an element from the lsit.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@var{element} was found in the list and was removed.
@item PDF_EBADDATA
@var{element} was not found in the list.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Working with sorted lists
@subsection Working with sorted lists

@deftypefun pdf_status_t pdf_list_sorted_add (pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void* @var{element}, pdf_list_node_t @var{* element_node})

Add an element to the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
A pointer to the user data to be stored as a list element.
@item element_node
A pointer where the added element node will be saved. Can be NULL.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid @var{compar_fn} pointer.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_remove (pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void * @var{element})

Search and remove an element from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
The element to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@var{element} was found in the list and was removed.
@item PDF_ENONODE
@var{element} was not found in the list.
@item PDF_EBADDATA
Invalid @var{compar_fn}.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_search (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
The element to search for.
@item node
The searched node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer or @var{compar_fn}.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_search_from_to (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list, at a position >=
@var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item start_index
Index to the first list position to be searched.
@item end_index
Index to the last list position to be searched.
@item element
The element to search for.
@item node
The seached node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer or @var{compar_fn}.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_indexof (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
A pointer to user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@end table
@item Usage Example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_indexof_from_to (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list, at a position >= @var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item element
A pointer to some user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Working with Iterators
@subsection Working with Iterators

@deftypefun pdf_status_t pdf_list_iterator (const pdf_list_t @var{list}, pdf_list_iterator_t @var{*itr})

Create an iterator traversing a list.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item itr
A pointer to where the new iterator will be saved.
@end table
@item Returns
A status variable:
@table @code
@item PDF_OK
@var{itr} contains a new iterator for @var{list}.
@item PDF_EBADDATA
@var{itr} points to NULL.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_from_to (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, pdf_list_iterator_t @var{*itr})

Create an iterator traversing the element with indices @code{i},
@code{start_index <= i < end_index}, of a list.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item itr
A pointer to an iterator where the new one will be saved.
@end table
@item Returns
A status variable:
@table @code
@item PDF_OK
@var{itr} contains a new iterator for @var{list} pointing to @var{start_index}.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@item PDF_EBADDATA
@var{itr} points to NULL.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_next (pdf_list_iterator_t *@var{iterator}, const void **@var{element_pointer}, pdf_list_node_t *@var{node_pointer})

If there is a next element, store the next element in
@var{*element_pointer}, store its node in @var{*node_pointer} if it is
non-@code{NULL}, and advance the iterator.

@table @strong
@item Parameters
@table @var
@item iterator
A list iterator.
@item element_pointer
A pointer to a pointer to user data.
@item node_pointer
A pointer to a list node.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
There is a next element.
@item PDF_ERROR
There is not a next element.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_free (pdf_list_iterator_t *@var{iterator})

Free an iterator releasing any used resource.

@table @strong
@item Parameters
@table @var
@item iterator
A list iterator.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Filtered Streams
@section Filtered Streams

This module provides read/write streams of data to memory buffers and
open files adding the following functionality:

@itemize @minus
@item Filtering.
@item Buffering.
@end itemize

Several streams can be created to operate in the same open file. This
provides a convenient access to files with several parts requiring
different filters to read or write its contents.

Filters (such as the PDF standard ones) are supported for both reading
and writing. Many filters may be used in a single stream (those
filters are applied in an order when writing and in the inverse order
when reading).

The file streams maintain a buffer for both reading and writing. The
size of the buffer is specified by the client in creation time. This
is used, for example, to provide efficient character-based I/O.

Note that the streams operating in memory buffers do not provide
buffering.

@menu
* Stream Types::
* Creating and Destroying Streams::
* Getting and Setting Stream Properties::
* Managing the Filter Chain::
* Reading and Writing Data::
* Stream Positioning::
@end menu

@node Stream Types
@subsection Stream Types

@deftp {Data Type} pdf_stm_t
A stm variable.
@end deftp

@deftp {Data Type} {enum pdf_stm_mode_e}
The operation mode of a stm object.

@table @code
@item PDF_STM_READ
The stm will be used to read data from the open file or memory buffer.
@item PDF_STM_WRITE
The stm will be used to write data into the open file or memory buffer.
@end table
@end deftp

@deftp {Data Type} {enum pdf_stm_filter_type_e}
The several types of supported stream filters.

@table @code
@item PDF_STM_FILTER_AHEX_ENC
ASCII Hex encoder.
@item PDF_STM_FILTER_AHEX_DEC
ASCII Hex decoder.
@item PDF_STM_FILTER_RL_ENC
Run-Length encoder.
@item PDF_STM_FILTER_RL_DEC
Run-Length decoder.
@item PDF_STM_FILTER_FLATE_ENC
Flate (zlib) encoder.
@item PDF_STM_FILTER_FLATE_DEC
Flate (zlib) decoder.
@item PDF_STM_FILTER_JBIG2_DEC
JBIG2 decoder.
@item PDF_STM_FILTER_AESV2_ENC
AESV2 encoder.
@item PDF_STM_FILTER_AESV2_DEC
AESV2 decoder.
@item PDF_STM_FILTER_V2_ENC
V2 encoder.
@item PDF_STM_FILTER_V2_ENC
V2 decoder.
@item PDF_STM_FILTER_MD5_ENC
MD5 encoder.
@end table
@end deftp

@node Creating and Destroying Streams
@subsection Creating and Destroying Streams

@deftypefun pdf_status_t pdf_stm_file_new (pdf_fsys_file_t @var{file}, pdf_off_t @var{offset}, pdf_size_t @var{cache_size}, enum pdf_stm_mode_e @var{mode}, pdf_stm_t *@var{stm})

Create a new stream operating in a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item offset
Position into the file.
@item cache_size
The desired size for the stream cache, measured in octects. If it is
@code{0} then the default size (4kb) is used.
@item mode
The operation mode for the stream.
@item stm
A pointer to the stm to be created.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The stream object was successfully created.
@item PDF_ERROR
There was an error and the stream was not created.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_mem_new (pdf_char_t *@var{buffer}, pdf_size_t @var{size}, pdf_size_t @var{cache_size}, enum pdf_stm_mode_e @var{mode}, pdf_stm_t *@var{stm})

Create a new stream operating in a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
Memory buffer where the information will be written-to or readed-from.
@item size
The desired size for the memory buffer, measured in octects.
@item cache_size
The desired size for the stream cache, measured in octects. If it is
@code{0} then the default size (4kb) is used.
@item mode
The operation mode for the stream.
@item stm
A pointer to the stm to be created.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The stream was successfully created.
@item PDF_ERROR
There was an error and the stream was not created.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_destroy (pdf_stm_t @var{stm})

Destroy a stream freeing all the used resources.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
A PDF status value. This is @code{PDF_OK} unless the closed stream is
a writing stream. In that case the return code of @code{pdf_stm_flush}
is returned.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Getting and Setting Stream Properties
@subsection Getting and Setting Stream Properties

@deftypefun pdf_stm_get_mode (pdf_stm_t @var{stm})

Return the mode of a given stream @var{stm}.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
The mode of the stream.
@item Usage example
@example
pdf_stm_t stm;

pdf_stm_mem_new (buffer,
                 2048,
                 0,     /* Use the default cache size */
                 PDF_STM_WRITE,
                 &stm);

pdf_stm_get_mode (stm); /* Returns PDF_STM_WRITE */
@end example
@end table
@end deftypefun

@node Managing the Filter Chain
@subsection Managing the Filter Chain

The following functions can be used to build the filter chain of a
given stream.

@deftypefun pdf_status_t pdf_stm_install_filter (pdf_stm_t @var{stm}, enum pdf_stm_filter_type_e @var{filter_type}, pdf_hash_t @var{filter_params})

Install a fiter in the filter chain of a stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item filter_type
The type of the filter to be installed.
@item filter_params
Hash table containing a set of key-value pairs with the parameters for
the filter.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The filter was successfully installed in the stream.
@item PDF_ERROR
There was an error and the filter was not installed in the stream.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Reading and Writing Data
@subsection Reading and Writing Data

@deftypefun pdf_status_t pdf_stm_read (pdf_stm_t @var{stm}, pdf_char_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{read_bytes})

Read a chunk of data from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item buf
The buffer to hold the read data.
@item bytes
The number of octects to read.
@item read_bytes
The number of octects actually read. If this value is less than
@var{bytes} then an end of file condition occurred.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
All the requested bytes were successfully read into @var{buf}.
@item PDF_EEOF
An end of file condition occurred.
@item PDF_EINVOP
Reading was requested in a writing stream.
@item PDF_ERROR
An error prevented to read the bytes.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_write (pdf_stm_t @var{stm}, const pdf_char_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{written_bytes})

Write a chunk of data into a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item buf
The buffer containing the written information.
@item bytes
The number of bytes to write into the stream.
@item written_bytes
A pointer to a PDF size containing the number of octects actually
written. If the returned value is less than @code{bytes} then a disk
full condition has occured.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
All the requested bytes were successfully written into @var{stm}.
@item PDF_EEOF
A disk full condition occurred.
@item PDF_EINVOP
Writting was requested in a read stream.
@item PDF_ERROR
An error prevented to write the bytes.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_read_char (pdf_stm_t @var{stm}, pdf_char_t *@var{c})

Read a character from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item c
The address of a character.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A character was successfully read into @var{c}.
@item PDF_EEOF
End of file.
@item PDF_EINVOP
Reading was requested in a writing stream.
@item PDF_ERROR
An error prevented to read the character.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_peek_char (pdf_stm_t @var{stm}, pdf_char_t *@var{c})

Peek a character from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item c
The address of a character.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A character was successfully peek into @var{c}.
@item PDF_EEOF
End of file.
@item PDF_EINVOP
Peeking was requested in a writing stream.
@item PDF_ERROR
An error prevented to peek the character.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_flush (pdf_stm_t @var{stm}, pdf_bool_t @var{finish_p}, pdf_size_t *@var{flushed_bytes})

Flush any pending writing data in a given stream.

If @var{finish_p} equals to @code{PDF_TRUE} then the filters in the
stream's filter chain are tell to generate any remaining output.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item finish_p
A boolean value indicating whether to finalize the filter chain.
@item flushed_bytes
A pointer to a @code{pdf_size_t} variable to hold the number of
flushed bytes. May be @code{0}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
All the requested bytes were successfully written into @var{stm}.
@item PDF_EEOF
A disk full condition occurred.
@item PDF_EINVOP
Writting was requested in a read stream.
@item PDF_ERROR
An error prevented to write the bytes.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Stream Positioning
@subsection Stream Positioning

@deftypefun pdf_off_t pdf_stm_bseek (pdf_stm_t @var{stm}, pdf_off_t @var{pos})

Seek into the backend of a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item pos
The position to seek, measured in octects from the beginning of the
backend media.
@end table
@item Returns
The new position of the stream read/write pointer. If it is equal to
the current position then there was an error.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_off_t pdf_stm_btell (pdf_stm_t @var{stm})

Get the current position of the read/write pointer of the backend of a
stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
The current position (measured in octets from the beginning of the
backend media) of the read/write pointer.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_off_t pdf_stm_tell (pdf_stm_t @var{stm})

Get the number of octects read/written from/to the stream since either
the last @code{pdf_stm_bseek} operation or the creation of the
stream, if no bseek was made.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
The current position (measured in octets) of the read/write pointer.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Floating Point Maths
@section Floating Point Maths

@menu
* Floating Point Constants::
* Floating Point Types::
* Rounding Routines::
* Exponential and Logarithmic Routines::
* Number Conversion Routines::
* Trigonometric Routines::
* Geometry Routines::
* Other Maths Routines::
* Creation and Destruction of Functions::
* Evaluation of Functions::
@end menu

@node Floating Point Constants
@subsection Floating Point Constants

@code{PDF_PI} contains the value of pi.

@node Floating Point Types
@subsection Floating Point Types

@deftp {Data Type} pdf_real_t
An opaque type representing a floating-point number.
@end deftp

@deftp {Data Type} {struct pdf_point_s}

This structure represents a single point. The coordinates of the point
are made using floating point numbers.

@table @code
@item pdf_real_t h
Horizontal coordinate.
@item pdf_real_t v
Vertical coordinate.
@end table
@end deftp

@deftp {Data Type} pdf_point_t

A pointer to a @code{pdf_point_s} structure.

@end deftp

@deftp {Data Type} {struct pdf_matrix_s}

This structure represents a 3x3 matrix representing an affine
transformation.

@table @code
@item pdf_real_t a
@item pdf_real_t b
The first row of the matrix is @code{a b 0}.
@item pdf_real_t c
@item pdf_real_t d
The second row of the matrix is @code{c d 0}.
@item pdf_real_t h
@item pdf_real_t v
The third row of the matrix is @code{h v 1}.
@end table
@end deftp

@deftp {Data Type} pdf_matrix_t

A pointer to a @code{pdf_matrix_s} structure.

@end deftp


@deftp {Data Type} {struct pdf_rect_s}

This structure represents a rectangle. It is composed by the
coordinates for its four sides.

The rectangle sides should be horizontal and vertical and opposite
sides should be parallel.

@table @code
@item pdf_real_t left
@code{x} coordinate for the left points.
@item pdf_real_t top
@code{y} coordinate for the upper points.
@item pdf_real_t right
@code{x} coordinate for the right points.
@item pdf_real_t bottom
@code{y} coordinate for the bottom points.
@end table
@end deftp

@deftp {Data Type} pdf_rect_t

A pointer to a @code{pdf_rect_s} structure.

@end deftp

@deftp {Data Type} {struct pdf_quad_s}
This structure represents a quadrilateral. It is composed by four
corners (floating-point points).
@table @code
@item pdf_point_t tl
Top-left point.
@item pdf_point_t tr
Top-right point.
@item pdf_point_t bl
Bottom-left point.
@item pdf_point_t br
Bottom-right point.
@end table
@end deftp

@deftp {Data Type} pdf_quad_t

A pointer to a @code{pdf_quad_t} structure.

@end deftp

@deftp {Data Type} pdf_fp_func_t

Opaque type representing a Floating Point function.

@end deftp

@node Rounding Routines
@subsection Rounding Routines

@deftypefun pdf_real_t pdf_fp_floor (pdf_real_t @var{op})

Round @var{op} down to the nearest integer.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The rounded integer value. If @var{op} is integral or infinite,
@var{op} itself is returned.
@item Usage example
@example
pdf_real_t number;
pdf_u32_t rounded;

number = 1.2;
rounded = pdf_fp_floor (number);
/* rounded equals 1 */

number = 1.6;
rounded = pdf_fp_floor (number);
/* rounded equals 1 */

number = 2;
rounded = pdf_fp_floor (number);
/* rounded equals 2 */
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_ceil (pdf_real_t @var{op})

Round @var{op} up to the nearest integer.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The rounded integer value. If @var{op} is integral or infinite,
@var{op} itself is returned.
@item Usage example
@example
pdf_real_t number;
pdf_u32_t rounded;

number = 1.2;
rounded = pdf_fp_ceil (number);
/* rounded equals 2 */

number = 1.6;
rounded = pdf_fp_ceil (number);
/* rounded equals 2 */

number = 2;
rounded = pdf_fp_ceil (number);
/* rounded equals 2 */
@end example
@end table
@end deftypefun

@node Exponential and Logarithmic Routines
@subsection Exponential and Logarithmic Routines

@deftypefun pdf_real_t pdf_fp_exp (pdf_real_t @var{op})

Return the value of e (the base of natural logarithms) raised to the
power of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The value of e raised to the power of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_log (pdf_real_t @var{op})

Return the natural logarithm of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The natural logarithm of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_log10 (pdf_real_t @var{op})

Return the base 10 logarithm of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The base 10 logarithm of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Number Conversion Routines
@subsection Number Conversion Routines

@deftypefun pdf_status_t pdf_fp_string_to_real (const pdf_char_t *@var{string}, pdf_real_t *@var{result})

Convert a numeric string representation to a @code{pdf_real_t}
value. The string is scanned from left to right, taking into account
the data before the first invalid character.

@table @strong
@item Parameters
@table @var
@item string
A @code{NULL} terminated string.
@item result
The real variable where the result is stored.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The conversion was successful.
@item PDF_ERROR
No recognizable real value was found in the string.
@end table
@item Usage example
@example
pdf_real_t real;
pdf_char_t str[5];

strcpy (str, "1");
str[1] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */

strcpy (str, "1.0");
str[3] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */


strcpy (str, "1.0X");
str[4] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */

strcpy (str, "foo");
str[3] = 0;
if (pdf_fp_string_to_real (str, &real) == PDF_ERROR)
@{
   /* The code reach this point */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_fp_real_to_string (pdf_real_t @var{real}, pdf_char_t *@var{s}, pdf_size_t @var{max_length}, pdf_u32_t @var{precision})

Get a textual representation of a  @code{pdf_real_t} value.

@table @strong
@item Parameters
@table @var
@item real
The number to convert.
@item s
The string where to store the textual representation of
@var{real}. Note that this function adds a '\0' to the end of the
textual representation.
@item max_length
The maximum number of characters that @var{s} may contain.
@item precision
The number of decimal digits to include in the textual representation.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A textual representation of @var{real} was successfully written in
@var{s}.
@item PDF_ERROR
An error prevented to perform the conversion.
@end table
@item Usage example
@example
pdf_real_t real;
pdf_char_t s[9];

real = 1.123456;

pdf_fp_real_to_string (real, s, 9, 6);
/* s contains "1.123456" */

pdf_fp_real_to_string (real, s, 9, 3);
/* s contains "1.123" */

if (pdf_fp_real_to_string (real, s, 4, 3) == PDF_ERROR)
@{
    /* The code reach this point: not enough space in the string
       to hold the textual representation of the number with
       the specified precision */
@}
@end example
@end table
@end deftypefun

@node Trigonometric Routines
@subsection Trigonometric Routines

@deftypefun pdf_real_t pdf_fp_sin (pdf_real_t @var{op})

Return the sine of @var{op}, where @var{op} is given in radians.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
A real value between @code{-1} and @code{1}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_cos (pdf_real_t @var{op})

Return the cosine of @var{op}, where @var{op} is given in radians.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
A real value between @code{-1} and @code{1}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_atan2 (pdf_real_t @var{op1}, pdf_real_t @var{op2})

Return the arc tangent of the two values @var{op1} and @var{op2}. It
is similar to calculating the arc tangent of @code{op1 / op2} except
that the signs of both arguments are used to determine the quadrant of
the result.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The result in radians, wichi is between @code{-PDF_PI} and
@code{PDF_PI} (inclusive).
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Geometry Routines
@subsection Geometry Routines

@deftypefun pdf_status_t pdf_fp_matrix_concat (pdf_matrix_t @var{result}, pdf_matrix_t @var{matrix_1}, pdf_matrix_t @var{matrix_2})

Multiplies two matrices.

@table @strong
@item Parameters
@item result
Pointer to the matrix that will be filled with the result. It may be
a copy of @var{matrix_1} or @var{matrix_2}.
@item matrix_1
The first matrix to multiply.
@item matrix_2
The second matrix to multiply.
@item Returns
A PDF status code:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
There was an error performing the execution.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_invert (pdf_matrix_t @var{result}, pdf_matrix_t @var{matrix})

Calculate the inverse of a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a matrix that will store the inverted matrix. This
parameters can be a copy of @var{matrix}.
@item matrix
A pointer to a matrix used to calculate the inverse.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform (pdf_point_t @var{result}, const pdf_matrix_t @var{matrix}, const pdf_point_t @var{point})

Transform a point through a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a point to hold the result. This can be a copy of
@var{point}.
@item matrix
A pointer to the matrix used to perform the transformation.
@item point
A pointer to the point to transform.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation suceeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform_rect (pdf_rect_t @var{result}, const pdf_matrix_t @var{matrix}, const pdf_rect_t @var{rect})

Transform a rectangle through a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a rectangle to hold the result. This can be a copy of
@var{rect}.
@item matrix
A pointer to the matrix used to perform the transformation.
@item point
A pointer to the rectangle to transform.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation suceeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Other Maths Routines
@subsection Other Maths Routines

@deftypefun pdf_fp_abs (pdf_real_t @var{op})

Return the absolute value of the real number @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The absolute value of the operand.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_fp_sqrt (pdf_real_t @var{op})

Return the non-negative square root of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The square root of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Creation and Destruction of Functions
@subsection Creation and Destruction of Functions

@deftypefun pdf_status_t pdf_fp_func_0_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, const pdf_real_t @var{domain}[], const pdf_real_t @var{range}[], pdf_u32_t @var{size}[], pdf_u32_t @var{bps}, pdf_u32_t @var{order}, const pdf_real_t @var{encode}[], const pdf_real_t @var{decode}[], pdf_char_t *@var{samples}, pdf_size_t @var{samples_size}, pdf_fp_func_t *@var{function})

Create a new type 0 (sampled) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item size
Array of @code{m} positive integers containing the number of samples
in each input dimension in the samples table.
@item bps
The number of bits used to represent a sample in the samples
table. Valid values shall be @code{1}, @code{2}, @code{4}, @code{8},
@code{12}, @code{16}, @code{24} and @code{32}.
@item order
Order of interpolation between samples. Valid values shall be @code{1}
and @code{3}.
@item encode
Array of @code{2 * m} numbers specifying the linear mapping of input
values into the domain of the function's sample table.
@item decode
Array of @code{2 * n} numbers specifying the linear mapping of sample
values into the range appropriate for the function's output values.
@item samples
Buffer containing the samples table for the function.
@item samples_size
Size of the samples table.
@item function
A pointer to the variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_2_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, const pdf_real_t @var{domain}[], const pdf_real_t @var{range}[], pdf_real_t @var{N}, pdf_real_t @var{c0}[], pdf_real_t @var{c1}[], pdf_fp_func_t *@var{function})

Create a new type 2 (exponential interpolation) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item N
The interpolation exponent.
@item c0
An array of @code{n} numbers that shall define the function result
when @code{x = 0.0}.
@item c1
An array of n numbers that shall define the function return when
@code{x = 1.0}.
@item function
Pointer to a variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_3_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, const pdf_real_t @var{domain}[], const pdf_real_t @var{range}[], pdf_u32_t @var{k}, pdf_fp_func_t *@var{functions}, pdf_real_t @var{bounds}[], const pdf_u32_t @var{encode}[], pdf_fp_func_t *@var{function})

Create a new type 3 (stitching) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item k
Number of stitching functions.
@item functions
An array of @code{k} 1-input functions that shall make up the
stitching function. The output dimensionality of all functions shall
be the same, and compatible with the value of @var{range}.
@item bounds
An array of @code{k - 1} numbers that, in combination with
@var{domain}, shall define the intervals to which each function from
the @var{functions} parameter shall apply. @var{bounds} elements shall
be in order of increasing value, and each value shall be within the
domain defined by @var{domain}.
@item encode
An array of @code{2 * k} numbers that, taken in pairs, shall map each
subset of the domain defined by @var{domain} and the @var{bounds}
parameter to the domain of the corresponding function.
@item function
A pointer to a variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_4_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, pdf_real_t @var{domain}[], pdf_real_t @var{range}[], pdf_char_t *@var{code}, pdf_size_t @var{code_size}, pdf_size_t *@var{error_at}, pdf_fp_func_t *@var{function})

Create a new type 4 (postscript calculator) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item code
Memory buffer containing the postscript code to execute.
@item code_size
Size of @var{code}.
@item error_at
Pointer to a variable where it will put the current offset on error.
@item function
Pointer to a variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_destroy (pdf_fp_func_t @var{function})

Destroy a function.

@table @strong
@item Parameters
@table @var
@item function
A pointer to an initialized function.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The function was successfully destroyed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Evaluation of Functions
@subsection Evaluation of Functions

@deftypefun pdf_status_t pdf_fp_func_get_bounds (const pdf_fp_func_t @var{function}, pdf_i32_t *@var{in_dimensions}, pdf_i32_t *@var{out_dimensions})

Return the bounds of a given function.

@table @strong
@item Parameters
@table @var
@item function
An initialized function.
@item in_dimensions
Variable to hold the input dimensions of @var{function}.
@item out_dimensions
Variable to hold the output dimensions of @var{function}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@deftp {Constant} PDF_FP_FUNC_TYPE4_TRUE
Stand for true value in the debugging information structure.
@end deftp

@deftp {Constant} PDF_FP_FUNC_TYPE4_FALSE
Stand for false value in the debugging information structure.
@end deftp


@deftp {Data Type} {pdf_fp_func_debug_t}

This structure contains debugging data associated to the evaluation of a
function.

@table @code
@item type0
No information for type0 functions.
@item type2
No information for type2 functions.
@item type3
No information for type3 functions.
@item type4
@table @code
@item status
A PDF status value:
@table @code
@item PDF_ERROR
An unknown error ocurred.
@item PDF_EINVRANGE
Invalid range operand for the current operator..
@item PDF_EUNDERFLOW
Try to fetch an element from an empty stack.
@item PDF_EOVERFLOW
Overflow of stack.
@item PDF_EBADTYPE
Invalid type data for the current operator.
@item PDF_EMATH
Math error.
@end table
@item op
Offset in the source code in which the error ocurred.
@item stack_size
Size of the stack.
@item stack
Array of elements in the stack when the error ocurred. The first element
is the last pushed one. Each element is a double value or a boolean one.
@end table
@end table
@end deftp


@deftypefun pdf_status_t pdf_fp_func_eval (pdf_fp_func_t @var{function}, const pdf_real_t @var{in}[], pdf_real_t @var{out}[], pdf_fp_func_debug_t *@var{debug})

Evaluate a function.

@table @strong
@item Parameters
@table @var
@item function
The function to evaluate.
@item in
Array containing the input values for the function.
@item out
Array containing the output values from the function evaluation.
@item debug
A pointer to the structure will contain debug information.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The evaluation was successfully performed.
@item PDF_ERROR
Error while evaluating the function.
@item PDF_TYPE0
Error in a type0 function. The debug structure will contain more information.
@item PDF_TYPE2
Error in a type2 function. The debug structure will contain more information.
@item PDF_TYPE3
Error in a type3 function. The debug structure will contain more information.
@item PDF_TYPE4
Error in a type4 function. The debug structure will contain more information.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Encoded Text
@section Encoded Text

@menu
* Text Data Types::
* Creating and Destroying Text::
* Managing Text Properties::
* Managing Text Contents::
* Comparing Text Variables::
* Managing Host Encodings::
@end menu

@node Text Data Types
@subsection Text Data Types

@deftp {Data Type} {enum pdf_text_unicode_encoding_e}

Enumeration of supported Unicode encodings.

@table @code
@item PDF_TEXT_UTF8
UTF-8 encoding.
@item PDF_TEXT_UTF16_BE
Big Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_LE
Little Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_HE
Host Endian UTF-16 encoding (may be little-endian or big-endian).
@item PDF_TEXT_UTF32_BE
Big Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_LE
Little Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_HE
Host Endian UTF-32 encoding (may be little-endian or big-endian).
@end table
@end deftp


@deftp {Data Type} {pdf_text_unicode_options_e}

Enumeration of extra options to get the contents of a pdf_text_t in a given
UNICODE encoding (see function `pdf_text_get_unicode').

@table @code
@item PDF_TEXT_UNICODE_NO_OPTION (= 0)
No specific option
@item PDF_TEXT_UNICODE_WITH_BOM
Prepend Byte Order Marker to the UNICODE string.
@item PDF_TEXT_UTF16BE_WITH_LANGCODE
Insert language/country code information between the BOM (if required) and the
data. This option is ONLY applicable to UTF16BE. If specified in any other
encoding, the function will fail.
@item PDF_TEXT_UNICODE_WITH_NUL_SUFFIX
Append a NUL suffix to the Unicode string (1-byte NUL for UTF-8, 2-byte NUL for
UTF-16 and 4-byte NUL for UTF-32).
@end table
@end deftp



@deftp {Data Type} {enum pdf_text_filter_type_e}

Enumeration of supported filters in encoded text objects
(see function `pdf_text_filter').

@table @code
@item PDF_TEXT_FILTER_IDENTITY
Do not perform any transformation in the encoded text. It is a no-op.
@item PDF_TEXT_FILTER_LINE_ENDINGS
Normalize line endings.
@item PDF_TEXT_FILTER_UPPER_CASE
Makes all text upper case.
@item PDF_TEXT_FILTER_LOWER_CASE
Makes all text lower case.
@item PDF_TEXT_FILTER_TITLE_CASE
Makes all text title case.
@item PDF_TEXT_FILTER_REMOVE_AMP
Remove all single ampersands. This filter transform @code{&&} into
@code{&}.
@item PDF_TEXT_FILTER_NORM_WITH_FULL_WIDTH
Normalize with full width ASCII variants filter.
@item PDF_TEXT_FILTER_REMOVE_LINE_ENDINGS
Replace line endings with space characters.
@end table
@end deftp


@deftp {Data Type} pdf_text_t

A Unicode string, which must be considered as an opaque type. It contains the data
in UTF-32BE encoding, as well as any `ISO-639-1' country code and/or `ISO-3166-1 alpha-2'
language code applied. It also contains an internal list of word boundaries.

This data type must be initialized before being used, and destroyed afterwards.

@end deftp

@deftp {Data Type} pdf_text_host_encoding_t

This data type identifies an encoding used in a host (all the possible values
are host-dependent). There is no initialization/destruction requirement for
this data type.

@end deftp

@node Creating and Destroying Text
@subsection Creating and Destroying Text

@deftypefun pdf_status_t pdf_text_new (pdf_text_t *text)

Create a new text object containing no text.

@table @strong
@item Parameters
@table @var
@item text
A pointer to the new instance of text object.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The text object was successfully created.
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@item PDF_ERROR
Other error.
@end table
@item Usage Example
@example
pdf_text_t mytext;

pdf_text_new (&mytext);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_text_destroy (pdf_text_t text)

Destroy a text object and its contents.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@end table
@item Returns
The status of the destruction
@item Usage Example
@example
pdf_text_t mytext;

mytext = pdf_text_new ();
pdf_text_destroy(mytext);

@end example
@end table
@end deftypefun

@deftypefun pdf_text_t pdf_text_dup (const pdf_text_t @var{text})

Dup a new text object from a existing one.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@end table
@item Returns
A pointer to the newly created text object.
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

text1 = pdf_text_new ();
text2 = pdf_text_dup (text1);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_host (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const pdf_text_host_encoding_t @var{enc}, pdf_text_t *@var{text})

Create a new text object and initialize it with a given host encoded
string.

@table @strong
@item Parameters
@table @var
@item str
A multybyte string in some host encoding.
@item size
The length of @var{str}, in bytes.
@item enc
The host encoding with which @var{str} is encoded.
@item text
A pointer to the output text object
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@end table
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *he_string;
pdf_size_t  he_string_size;
pdf_text_host_encoding_t encoding;
pdf_status_t ret_code;

/* Obtain host encoding and text... */

/* And create text object with those contents */
ret_code = pdf_text_new_from_host(he_string, he_string_size,
                                  encoding,
                                  &text);
if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_pdf_string (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, pdf_char_t **@var{remaining_str}, pdf_size_t *@var{remaining_length}, pdf_text_t *@var{text})

Create a new text object and initialize it with a given `PDF string'
text representation. This `PDF string' can be either encoded in UTF-16BE, with
BOM and optional Country/Language code information, or in PDF Doc Encoding.

The Country/Language code marker is treated as end-of-text marker, so that a text object
handles only a given pair of country and language codes. This function must be used
inside a loop, so that the input string of data is splitted in chunks if more than
one language/code is available in the text (only if PDF string is encoded in
UTF-16BE).

@table @strong
@item Parameters
@table @var
@item str
A text representation of a PDF string.
@item size
The length of @var{str} in bytes
@item remaining_str
Returned pointer to the next chunk of data to process, if any.
@item remaining_length
Length of @var{remaining_str} in bytes
@item text
A pointer to the newly created text object.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@end table
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *pdf_string;
pdf_size_t  pdf_string_size;
pdf_char_t *remaining_str;
pdf_size_t remaining_size;
pdf_status_t ret_code;

/* Obtain PDF string... */

/* And create text object with those contents */
remaining_str = pdf_string;
remaining_length = pdf_string_size;
do
@{
  ret_code = pdf_text_new_from_host(remaining_str, remaining_length,
                                    &remaining_str, &remaining_length,
                                    &text);

  /* Do something with the chunk of string */

  pdf_text_destroy(text);
@}
while((ret_code == PDF_OK) && (remaining_length > 0));


@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_unicode (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const enum pdf_text_unicode_encoding_e @var{enc}, pdf_text_t *@var{text})

Create a new text object from a string of Unicode characters in a
given unicode encoding. The Unicode string can be given with or without BOM,
and there mustn't be any language/code information embedded in the string.

Note that for UTF-16BE strings two options are possible to create the
pdf_text_t object: treating it as a PDF string (so BOM is mandatory and
Language/Country code are optional) or treating it as a general Unicode
string (so BOM is optional and Language/Country code is not allowed).

@table @strong
@item Parameters
@table @var
@item str
A Unicode string.
@item size
The length of @var{ucs} in bytes.
@item enc
The Unicode encoding used by @var{ucs}.
@item text
A pointer to the newly created text object.
@end table
@item Returns
A pdf status value:
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *unicode_string;
pdf_size_t  unicode_string_size;
pdf_status_t ret_code;

/* Obtain unicode text... */

/* And create text object with those contents */
ret_code = pdf_text_new_from_unicode(unicode_string, unicode_string_size,
                                     PDF_TEXT_UTF16_BE,
                                     &text);
if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_u32 (const pdf_u32_t @var{number}, pdf_text_t *text)

Create a new text variable containing the textual representation of a
given integer.

@table @strong
@item Parameters
@table @var
@item number
An unsigned 32 bit number.
@item text
A pointer to the newly created text object.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@end table
@item Usage Example
@example
pdf_text_t text;
pdf_u32_t number;
pdf_status_t ret_code;

number = 24;
ret_code = pdf_text_new_from_u32 (number, &text);

if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@node Managing Text Properties
@subsection Managing Text Properties

@deftypefun {const pdf_char_t *} pdf_text_get_country (const pdf_text_t @var{text})

Return the `ISO-3166-1 alpha-2' country code associated with a text variable, as a
NUL-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the country associated with @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_country (text);
@end example
@end table
@end deftypefun

@deftypefun {const pdf_char_t *} pdf_text_get_language (const pdf_text_t @var{text})

Return the `ISO-639-1' language code associated with a text variable, as a
NUL-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the language associated with @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_language (text);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_country (pdf_text_t @var{text}, const pdf_char_t *@var{code})

Associate a text variable with a `ISO-3166-1 alpha-2' country code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A country code.
@end table
@item Returns
The status of the assignment.
@item Usage Example
@example
pdf_text_t text;
pdf_status_t ret_code;

/* ...create and manipulate `text' */

ret_code = pdf_text_set_country (text, "27");

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_language (pdf_text_t @var{text}, const pdf_char_t *@var{code})

Associate a text variable with a `ISO-639-1' language code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A language code.
@end table
@item Returns
The status of the assignment.
@item Usage Example
@example
pdf_text_t text;
pdf_status_t ret_code;

/* ...create and manipulate `text' */

ret_code = pdf_text_set_language (text, "10");
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_empty_p (const pdf_text_t @var{text})

Determine if a given text variable is empty (contains no text).

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The text variable contain no text.
@item PDF_FALSE
The text variable contain some text.
@end table
@item Usage Example
@example
pdf_text_t text;

/* ...initialize and manipulate `text'... */

if (pdf_text_empty_p (text))
@{
  /* `text' contains no text */
@}
@end example
@end table
@end deftypefun


@node Managing Text Contents
@subsection Managing Text Contents

@deftypefun pdf_status_t pdf_text_get_host (pdf_char_t **@var{contents}, pdf_size_t *@var{length}, const pdf_text_t @var{text}, const pdf_text_host_encoding_t @var{enc})

Get the contents of a text variable encoded in a given host encoding.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (May contain NUL bytes). Must be freed afterwards.
@item length
Output length of @var{contents}
@item text
A text variable.
@item enc
A host encoding supported by the host.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding_t encoding;
pdf_char_t *str;
pdf_size_t str_length;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_host (&str, &str_length, text, encoding);

pdf_dealloc(str);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_get_pdfdocenc (pdf_char_t **@var{contents}, const pdf_text_t @var{text})

Get the contents of a text variable encoded in PDF Doc Encoding,
and NUL-terminated.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (Can't contain NUL bytes). Must be freed afterwards.
@item text
A text variable.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_pdfdocenc (&str, text);

pdf_dealloc(str);

@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_text_get_unicode (pdf_char_t **@var{contents}, pdf_size_t *@var{length}, const pdf_text_t @var{text}, const enum pdf_text_unicode_encoding_e @var{enc}, const pdf_u32_t @var{options})

Get the contents of a text variable encoded in the specified
Unicode encoding. Additional options can be set in the request.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (May contain NUL bytes). Must be freed afterwards.
@item length
Output length of @var{contents}
@item text
A text variable.
@item enc
A given UNICODE encoding, specifying requested endianness.
@item options
Additional options that can be set, in the way: OPTION_1 | OPTION_2 | OPTION_3.
(see @code{pdf_text_unicode_options_e} data type)
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_size_t str_length;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_unicode (&str, &str_length,
                                 text,
                                 PDF_TEXT_UTF16_BE,
                                 (PDF_TEXT_UNICODE_WITH_BOM | PDF_TEXT_UTF16BE_WITH_LANGCODE));

pdf_dealloc(str);

@end example
@end table
@end deftypefun




@deftypefun {pdf_char_t *} pdf_text_get_hex (const pdf_text_t @var{text}, const pdf_char_t @var{delimiter})

Get the contents of a text variable encoded in ASCII format and represented in Hexadecimal format, separated by the character given in @var{delimiter} (usually ':').

@table @strong
@item Parameters
@table @var
@item text
A text variable
@item delimiter
A single ASCII char used as delimiter
@end table
@item Returns
A NUL-terminated string with the contents of the text object in hexadecimal representation. The string must be deallocated by the caller.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

str = pdf_text_get_hex (text, ':');

PDF_DEBUG_BASE("Internal representation of the string is: '%s'",str);

pdf_dealloc(str);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_host (pdf_text_t @var{text}, const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const pdf_text_host_encoding_t @var{enc})

Set a string encoded with some host encoding as the value of a text
variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with some host encoding.
@item enc
The length of @var{str}, in bytes.
@item enc
The host encoding used to encode @var{str}.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding_t encoding;
pdf_char_t *str;
pdf_size_t length;

/* ...initialize and manipulate `text', `encoding' and `str'... */
if (pdf_text_set_host (text, str, length, enc) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_pdfdocenc (pdf_text_t @var{text}, const pdf_char_t *@var{str})

Set a PDF Doc Encoding encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with PDF Doc Encoding, NUL terminated.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;

/* ...initialize and manipulate `text' and `str'... */
if (pdf_text_set_pdfdocenc (text, str) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_unicode (pdf_text_t @var{text}, const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const enum pdf_text_unicode_encoding_e @var{enc})

Set a Unicode encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A Unicode string without country/language data embedded.
@item size
The length of @var{str}, in bytes.
@item enc
The used Unicode encoding in @var{str}.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_size_t length;
enum pdf_text_unicode_encoding_e enc;

/* ...initialize and manipulate `text', `str' and `enc'... */
if (pdf_text_set_unicode (text, str, length, enc) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_concat (pdf_text_t @var{text1}, const pdf_text_t @var{text2}, const pdf_bool_t @var{override_langinfo})

Concatenate the contents of two text variables (@var{text1} first,
then @var{text2}) and store the result in @var{text}.

Warning! @var{override_langinfo} is not set and different country/language
codes are found within the text variables an error will be returned
(concatenation not possible). If @var{override_langinfo} is set, the country
 and language information is not checked.

@table @strong
@item Parameters
@table @var
@item text1
The first text variable to concatenate. The contents of this variable
are modified with the output of the concatenation.
@item text2
The second text variable to concatenate. The contents of this variable
are left unchanged.
@item override_langinfo
Flag to indicate if the language and country information must be checked
before performing the concatenation.
@end table
@item Returns
The status of the operation.
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

/* ...initialize `text1' and `text2'... */
if (pdf_text_concat (text1, text2, PDF_FALSE) != PDF_OK)
@{
   /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_replace (pdf_text_t @var{text}, const pdf_text_t @var{new_pattern}, const pdf_text_t @var{old_pattern})

Replace a fixed pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement text.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;
pdf_text_t new_pattern;
pdf_text_t old_pattern;

/* ...initialize `text', `new_pattern' and `old_pattern'... */
if (pdf_text_replace (text, new_pattern, new_pattern) != PDF_OK)
@{
  /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_replace_ascii (pdf_text_t @var{text}, const pdf_char_t *@var{new_pattern}, const pdf_char_t *@var{old_pattern})

Replace a fixed ASCII pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement ASCII string.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;
const pdf_char_t *new_pattern = "GNU/Linux";
const pdf_char_t *old_pattern = "Linux";

/* ...initialize `text'... */
if (pdf_text_replace_ascii (text, new_pattern, old_pattern) != PDF_OK)
@{
  /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_filter (pdf_text_t @var{text}, const pdf_u32_t @var{filter})

Filter the contents of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item filter
Filter to be run in @var{text}, in the way: FILTER_1 | FILTER_2 | FILTER_3.
(see @code{pdf_text_filter_type_e} data type).

Warning!! At most one case-related filter can be applied at a time.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;

/* ...initialize `text'... */

if (pdf_text_filter (text, (PDF_TEXT_FILTER_LOWER_CASE | PDF_TEXT_FILTER_REMOVE_AMP)) != PDF_OK)
@{
  /* Manage error */
@}
@end example
@end table
@end deftypefun


@node Comparing Text Variables
@subsection Comparing Text Variables

@deftypefun pdf_i32_t pdf_text_cmp (const pdf_text_t @var{text1}, const pdf_text_t @var{text2}, const pdf_bool_t @var{case_sensitive}, pdf_status_t *@var{p_ret_code})

Compare the contents of two text variables.

@table @strong
@item Parameters
@table @var
@item text1
A text variable.
@item text2
A text variable.
@item case_sensitive
A boolean value indicating if the comparison is case-sensitive:
@table @code
@item PDF_TRUE
Case sensitive.
@item PDF_FALSE
Case insensitive.
@end table
@item p_ret_code
Pointer to store the status of the comparison (an internal error could happen).
NULL can be passed, so that the return status is not considered.
@end table
@item Returns
An integer:
@table @code
@item -1
If text1 < text2
@item 0
If text1 = text2
@item +1
If text1 > text2
@end table
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

/* ...initialize `text1' and `text2'... */

switch (pdf_text_cmp (text1, text2, PDF_FALSE))
@{
 case -1:
 @{
   /* XXX */
   break;
 @}
 case 0:
 @{
   /* XXX */
   break;
 @}
 case +1:
 @{
   /* XXX */
   break;
 @}
@}
@end example
@end table
@end deftypefun

@node Managing Host Encodings
@subsection Managing Host Encodings

@deftypefun pdf_text_host_encoding_t pdf_text_get_host_encoding (void)

Return the host encoding configured by the user/system in the locale.

@table @strong
@item Parameters
None
@item Returns
The host encoding configured in the user's locale.
@item Usage Example
@example
pdf_text_host_encoding enc;

enc = pdf_text_get_host_encoding();

@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_text_check_host_encoding (const pdf_char_t *@var{encoding_name}, pdf_text_host_encoding_t *@var{p_encoding})

Check if a given encoding is available in the system as a host-encoding. If available, it will return PDF_OK and will fill in the pdf_text_host_encoding_t variable passed by reference.

@table @strong
@item Parameters
@table @var
@item encoding_name
Name of the encoding to check for.
@item p_encoding
Pointer to a pdf_text_host_encoding_t variable.
@end table
@item Returns
Returns PDF_OK if the encoding is available in the system as a host-encoding.
@item Usage Example
@example
pdf_text_host_encoding enc;

if(pdf_text_check_host_encoding((pdf_char_t *)"ascii-us",&enc) == PDF_OK)
  @{
    /* XXX */
  @}

@end example
@end table
@end deftypefun


@deftypefun pdf_text_host_encoding_t pdf_text_get_best_encoding (const pdf_text_t @var{text}, const pdf_text_host_encoding_t @var{preferred_encoding})

Return the best available host encoding to encode the contents of a
given text variable. A specified preferred encoding is selected if
there is no clear best encoding.

The ``best'' encoding is an encoding able to encode the bigger number
of characters of the unicode content of the given text variable, so the
function will check for Unicode encodings supported in the system.
@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item preferred_encoding
A text encoding supported by the host.
@end table
@item Returns
The best host encoding available to encode the contents of @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding pref;
pdf_text_host_encoding enc;

/* ...create and manipulate `text'... */

enc = pdf_text_get_best_encoding (text, pref);

@end example
@end table
@end deftypefun


@node Time Management
@section Time Management

@menu
* Time Related Data Types::
* Time Creation and Destruction::
* Managing Time Values::
* Getting Time Intervals::
* Time Comparison::
* Time Printing and Parsing::
* Getting the Current Time::
* Time Span Creation and Destruction::
* Managing Time Span Values::
* Time Span Comparison::
* Calendar Spans Management::
* Platform-specific functions::
@end menu

@node Time Related Data Types
@subsection Time Related Data Types

@deftp {Data Type} pdf_time_t
A variable of type @code{pdf_time_t} contains information about a
particular date and time.

Note that leap seconds are not considered.
@end deftp

@deftp {Data Type} pdf_time_span_t
A variable of type @code{pdf_time_span_t} represents a span of time.

@end deftp

@deftp {Data Type} struct pdf_time_cal_s
This structure holds information about a specific time represented in
calendar items: years, months, days, day of week, hours, minutes,
seconds and the relative offset with GMT.

The calendar can be represented in both UTC and local time. If the given GMT
offset is zero, the calendar fields come in UTC; if not zero, the calendar
fields come in a given local time.

@table @code
@item pdf_i32_t year
A year number. Negative values may be supported in some systems.
@item pdf_u32_t month
A month number. The valid range is @code{1..12}.
@item pdf_u32_t day
A day number. The valid range is @code{1..31}.
@item pdf_u32_t dow
Day of the week. The valid range is @code{1..7} (Monday to Sunday).
@item pdf_u32_t hour
An hour. The valid range is @code{0..23}.
@item pdf_u32_t minute
A minute. The valid range is @code{0..59}.
@item pdf_u32_t sec
A second. The valid range is @code{0..59}.
@item pdf_i32_t gmt_offset
A GMT offset, in seconds west of GMT.
@end table
@end deftp

@deftp {Data Type} struct pdf_time_cal_span_s
This structure holds information about a time span represented in
calendar items: years, months, days, hours, minutes and seconds.

@table @code
@item pdf_u32_t years
@item pdf_u32_t months
@item pdf_u32_t days
@item pdf_u32_t hours
@item pdf_u32_t minutes
@item pdf_u32_t seconds
@end table
@end deftp

@deftp {Data Type} {enum pdf_time_format_e}
Enumeration containing the several supported time formats used to
convert a time to a string representation or to parse a time from a
string representation.

@table @code
@item PDF_TIME_FORMAT_PDF
PDF date strings.
@item PDF_TIME_FORMAT_ISO_8601
ISO 8601 date and time strings.
@item PDF_TIME_FORMAT_UTC_ASN1
UTC ASN1 date.
@item PDF_TIME_FORMAT_GENERALIZED_ASN1
Generalized ASN1 date.
@end table
@end deftp

@node Time Creation and Destruction
@subsection Time Creation and Destruction

@deftypefun pdf_status_t pdf_time_new (pdf_time_t *@var{time})
Create a new time and set it to the Epoch: Jan 1 1970-01-01 00:00:00 UTC

@table @strong
@item Parameters
@table @var
@item time
The time object that will contain the newly created instance.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The time object was successfully instantiated.
@item PDF_ENOMEM
Not enough memory to perform the requested operation.
@end table
@item Usage example
@example
pdf_time_t mytime;

if (pdf_time_new (&mytime) != PDF_OK)
   @{
     /* Error */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_time_t pdf_time_dup (const pdf_time_t @var{orig})
Dup a new time variable from a given one, allocating memory.

@table @strong
@item Parameters

@table @var
@item orig
The time variable to be dupped. Should be a properly created time
variable.
@end table
@item Returns
A new time variable containing a copy of @var{orig} values.
@code{NULL} if there is an error.
@item Usage example
@example
pdf_time_t orig;
pdf_time_t new_time;

orig = pdf_time_new ();
new_time = pdf_time_dup (orig);

if (new_time == NULL)
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_destroy (pdf_time_t @var{time_var})
Destroy @var{time_var} and free all used memory.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to be destroyed. Should be a properly created time
variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@node Managing Time Values
@subsection Managing Time Values

@deftypefun pdf_status_t pdf_time_copy (const pdf_time_t @var{orig}, pdf_time_t @var{copy})
Copies the data from @var{orig} to @var{copy}.

@table @strong
@item Parameters
@table @var
@item orig
The time whose data is to be copied. Should be a properly created time variable.
@item copy
The time to receive the data from @var{orig}. Should be a properly
created time variable.

Note that any previous data is destroyed.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t orig;
pdf_time_t copy;

orig = pdf_time_new ();
copy = pdf_time_new ();

if (!pdf_time_copy (orig, copy))
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_clear (pdf_time_t @var{time_var})
Reset @var{time_var} to the newly created state. After this call
@var{time_var} will contain the same date as if returned by
@code{pdf_time_new}.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to clear. Should be a properly create time variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

/* ...manipulate `mytime'... */

pdf_time_clear (mytime);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_set_from_u32 (pdf_time_t @var{time_var}, pdf_u32_t @var{seconds})
This function will initialize @var{time_var} to the given Unix time (seconds since January 1st 1970) in UTC timescale.
The time is represented as a 32-bit unsigned integer.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to set. Should be a properly create time variable.
@item seconds
Seconds since January 1st 1970, 32-bit unsigned value.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_from_u32(mytime, 1217009657);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_from_i64 (pdf_time_t @var{time_var}, pdf_i64_t @var{seconds})
This function will initialize @var{time_var} to the given Unix time (seconds since January 1st 1970) in UTC timescale.
The time is represented as a pdf_i64_t integer.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to set. Should be a properly create time variable.
@item seconds
Seconds since January 1st 1970, pdf_i64_t variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;
pdf_i64_t  epoch = pdf_i64_new(0,1217009657);
mytime = pdf_time_new ();

pdf_time_set_from_i64(mytime, epoch);

@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_time_add_cal_span (pdf_time_t @var{time_var}, const struct pdf_time_cal_span_s *@var{p_cal_span})
Add the time span represented by the calendar span under the address in @var{p_cal_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_span
A pointer to a calendar span with valid values.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
The data in @var{*p_cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, &cal_span) == PDF_EBADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_cal_span (pdf_time_t @var{time_var}, const struct pdf_time_cal_span_s *@var{p_cal_span})
Subtract the time span represented by the calendar span under the address in @var{p_cal_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_span
A pointer to a calendar span with valid values.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
The data in @var{cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, &cal_span) == PDF_EBADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}

if (pdf_time_sub_cal_span (mytime, cal_span) == PDF_EBADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Jan 1 1970-01-01 00:00:00 */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_add_span (pdf_time_t @var{time_var}, const pdf_time_span_t @var{time_span})
Add the time span contained in @var{time_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_add_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_span (pdf_time_t @var{time_var}, const pdf_time_span_t @var{time_span})
Subtract the time span contained in @var{time_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_sub_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_local_cal (const pdf_time_t @var{time_var}, struct pdf_time_cal_s *@var{p_local_cal})
Fill @var{p_local_cal} with the local calendar time of @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_local_cal
A pointer to the time calendar structure that will hold the local time
of @var{time_var}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s cal;

/* ...create and manipulate `mytime'... */

pdf_time_get_local_cal (mytime, &cal);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_utc_cal (const pdf_time_t @var{time_var}, struct pdf_time_cal_s *@var{p_utc_cal})
Get the UTC calendar time of a given time variable.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_time
A pointer to the calendar time structure that will hold the UTC time of @var{time_var}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
sruct pdf_time_cal_s cal_time;

/* ...create and manipulate `mytime'... */

pdf_time_get_utc_cal (mytime, &cal_time);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_from_cal (pdf_time_t @var{time_var}, const struct pdf_time_cal_s *@var{p_cal_time})
Set the value of a time variable to a given calendar time.

@table @strong
@item Parameters

@table @var
@item time_var
A properl created time variable.
@item p_cal_time
A pointer to a calendar time structure.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
There is invalid data in the calendar structure @var{cal_time}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s mycaltime;

mytime = pdf_time_new ();

mycaltime.year = 2000;
mycaltime.month = 8;
mycaltime.day = 10;
mycaltime.dow = 0; /* This field is ignored by `pdf_time_from_cal' */
mycaltime.hour = 0;
mycaltime.minute = 0;
mycaltime.sec = 0;
mycaltime.gmt_offset = 1;

if (pdf_time_from_cal (mytime, &mycaltime) == PDF_EBADDATA)
@{
  /* Bad data in `mycaltime' */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_local_offset (pdf_time_t @var{time_var})
Set the local time offset of @var{time_var} to the one used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_set_local_offset (time);
@end example
@end table
@end deftypefun

@node Getting Time Intervals
@subsection Getting Time Intervals

@deftypefun pdf_status_t pdf_time_diff_cal (const pdf_time_t @var{time1}, const pdf_time_t @var{time2}, struct pdf_time_cal_span_s *@var{p_cal_span})
Calculate the time span that goes from @var{time1} to @var{time2} and
store it in @var{p_cal_span}.

Note that the highest possible distribution inside @var{p_cal_span} is used.
@table @strong
@item Parameters

@table @var
@item time1
The beginning of the time interval (inclusive).
@item time2
The end of the time interval (exclusive).
@item p_cal_span
Pointer to the calendar time span structure that will hold the time span that
goes between @var{time1} and @var{time2}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time_begin;
pdf_time_t time_end;
struct pdf_time_cal_span_s cal_span;

/* ...create and manipulate `time_begin' and `time_end' */

pdf_time_diff (time_begin, time_end, &cal_span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_diff (const pdf_time_t @var{time1}, const pdf_time_t @var{time2}, pdf_time_span_t *@var{p_time_span})
Calculate the time span between two dates.

@table @strong
@item Parameters

@table @var
@item time1
The beginning time. Should be a properly created time.
@item time2
The ending time. Should be a properly created time.
@item p_time_span
The pointer to the time span variable that will hold the difference between
@var{time1} and @var{time2}. Should be a properly created time
span. Any previous content of @var{*p_time_span} will be destroyed.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;
pdf_time_span_t time_span;

/* ...create and manipulate `time1', `time2' and `time_span'... */

pdf_time_diff (time1, time2, &time_span);
@end example
@end table
@end deftypefun

@node Time Comparison
@subsection Time Comparison

@deftypefun pdf_i32_t pdf_time_cmp (const pdf_time_t @var{time1}, const pdf_time_t @var{time2})
Compares two times.

@table @strong
@item Parameters

@table @var
@item time1
The first time to compare.
Should be a properly created time variable.
@item time2
The second time to compare.
Should be a properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item -1
If @var{time1} precedes @var{time2}.
@item 0
If @var{time1} and @var{time2} contain the same time.
@item 1
If @var{time2} precedes @var{time1}.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;

time1 = pdf_time_new ();
time2 = pdf_time_new ();

/* ...manipulate `time1' and `time2'... */

switch (pdf_time_cmp (time1, time2))
@{
  case -1:
  @{
    /* `time1' precedes `time2' */
    break;
  @}
  case 0:
  @{
    /* `time1' contain the same time than `time2' */
    break;
  @}
  case 1:
  @{
    /* `time2' precedes `time1' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Time Printing and Parsing
@subsection Time Printing and Parsing

@deftypefun pdf_char_t* pdf_time_to_string (const pdf_time_t @var{time_var}, const enum pdf_time_format_e @var{time_format}, pdf_bool_t @var{include_trailing_apostrophe})
Create a string representation of a given time.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_format
The format to use when creating the string representation of
@var{time}.
@item include_trailing_apostrophe
Append an apostrophe after the GMT offset minutes field, if
present.  Note that this parameter is ignored if @var{time_format} is
not @code{PDF_TIME_FORMAT_PDF}.
@end table

@item Returns
The string representation of @var{time}. Must be deallocated by the caller of the function explicitly with pdf_dealloc().
@code{NULL} if there is an error.

@item Usage example
@example
pdf_time_t mytime;
pdf_char_t *mytime_str;

/* ...create and manipulate `mytime'... */

mytime_str = pdf_time_to_string (mytime, PDF_TIME_FORMAT_PDF);

pdf_dealloc(mytime_str);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_from_string (pdf_time_t @var{time_var}, const pdf_char_t *@var{time_str}, const enum pdf_time_format_e @var{time_format}, pdf_bool_t @var{require_trailing_apostrophe})
Get a string containing a time specification in some format and fill a
time variable with the parsed values.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.

@item time_str
A null-terminated string representation of a time.
@item time_format
The format indicating how to parse @var{time_str}.
@item require_trailing_apostrophe
If this argument is @code{PDF_TRUE} a PDF date specification
containing minutes should be followed by an APOSTROPHE character (').

If @var{time_format} is not @code{PDF_TIME_FORMAT_PDF} then this
argument is ignored.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Error while parsing @var{time_str} according to @var{time_format}.
@end table

@item Usage example
@example
pdf_time_t mytime;
char time_str[] = "D:20090813210000+00'00"; /* 13-August-2009, 21:00
                                               GMT 0 */

mytime = pdf_time_new ();
if (pdf_time_from_string (mytime,
                          time_str,
                          PDF_TIME_FORMAT_PDF) == PDF_EBADDATA)
@{
  /* Error while parsing `time_str' according to `PDF_TIME_FORMAT_PDF' */
@}
@end example
@end table
@end deftypefun

@node Getting the Current Time
@subsection Getting the Current Time

@deftypefun pdf_status_t pdf_time_set_to_current_local_time (pdf_time_t @var{time_var})
Set the value of @var{time_var} to the current local time used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_local_time (mytime);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_to_current_utc_time (pdf_time_t @var{time_var})
Set the value of @var{time_var} to the current UTC time used by the operating system.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_utc_time (mytime);
@end example
@end table
@end deftypefun

@node Time Span Creation and Destruction
@subsection Time Span Creation and Destruction

@deftypefun pdf_time_span_t pdf_time_span_new (void)

Allocate and return a new time span variable. The time span is
initialized with a zero value (zero seconds).

@table @strong
@item Parameters

None.

@item Returns
The newly created time span variable or @code{NULL} if there is an
error.
@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
@end example
@end table
@end deftypefun

@deftypefun pdf_time_span_t pdf_time_span_dup (const pdf_time_span_t @var{span})

Allocate and dup a new time span from an existing one. The new time
span has the same value as the base time span.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns
The newly created time span variable.
@item Usage example
@example
pdf_time_span_t span;
pdf_time_span_t new_span;

/* ...create and manipulate `span'... */

new_span = pdf_time_span_dup (span);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_span_destroy (pdf_time_span_t *@var{p_span})

Destroy a time span variable freeing all used memory.

@table @strong
@item Parameters

@table @var
@item p_span
The pointer to the time span variable to be destroyed.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table
@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_destroy (span);
@end example
@end table
@end deftypefun

@node Managing Time Span Values
@subsection Managing Time Span Values

@deftypefun pdf_status_t pdf_time_span_set (pdf_time_span_t *@var{p_span}, const pdf_i32_t @var{high_value}, const pdf_u32_t @var{low_value})

Set the value of a time span. The internal representation of the time
span is 64 bits long (signed).

@table @strong
@item Parameters

@table @var
@item p_span
A pointer to a properly created time span variable.
@item high_value
The high (signed) part of the time span value.
@item low_value
The low (unsigned) part of the time span value.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage exaple
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
pdf_time_span_set (&span, (1 << 31), 10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_set_from_i32 (pdf_time_span_t *@var{p_span}, const pdf_i32_t @var{seconds})

Set the value of a time span from a 32 bits signed number.

@table @strong
@item Parameters

@table @var
@item p_span
A pointer to a properly created time span variable.
@item seconds
A signed 32 bits number.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_create ();
pdf_time_span_set_from_i32 (&span, -10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_negate (pdf_time_span_t *@var{p_span})

Make a positive time span into a negative one or make a negative time
span into a positive one.

@table @strong
@item Parameters

@table @var
@item span
A pointer to a properly created time span variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_negate (span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_add (const pdf_time_span_t @var{span1}, const pdf_time_span_t @var{span2}, pdf_time_span_t *@var{p_result})

Add two time spans and store the result in another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to add.
@item span2
The second time span to add.
@item p_result
The pointer to the time span holding the result of the add operation. Any previous
content is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t result;

/* ...create and manipulate `span1', `span2' and `result'... */
pdf_time_span_add (span1, span2, &result);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_copy (const pdf_time_span_t @var{orig}, pdf_time_span_t *@var{p_dest})

Copy the value of a time span into another time span.

@table @strong
@item Parameters

@table @var
@item orig
The origin time span.
@item p_dest
The pointer to the time span variable that will hold the value of @var{orig}. Any
previous value is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span_orig;
pdf_time_span_t span_dest;

/* ...create and manipulate `span_orig' and `span_dest'... */

pdf_time_span_copy (span_orig, span_dest);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_diff (const pdf_time_span_t @var{span1}, const pdf_time_span_t @var{span2}, pdf_time_span_t *@var{p_result})

Difference two time spans and store the result (maybe negative) into
another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to diff.
@item span2
The second time span to diff.
@item p_result
The result of the diff operation. Any previous value of the time span
is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t span_diff;

/* ...create and manipulate `span1', `span2' and `span3' */

pdf_time_span_diff (span1, span2, span_diff);
@end example
@end table
@end deftypefun

@deftypefun pdf_i64_t pdf_time_span_to_secs (const pdf_time_span_t @var{span})

Get the value of a time span in seconds.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns
The value of the time span in seconds.
A negative value is returned if the time span is negative.
@item Usage example
@example
pdf_time_span_t span;
pdf_i32_t num_seconds;

/* ...create and manipulate `span'... */

num_seconds = pdf_time_span_to_secs (span);
@end example
@end table
@end deftypefun

@node Time Span Comparison
@subsection Time Span Comparison

@deftypefun pdf_i32_t pdf_time_span_cmp (const pdf_time_span_t @var{span1}, const pdf_time_span_t @var{span2})

Compare the length two time spans.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to compare.
@item span2
The second time span to compare.
@end table

@item Returns
A status value:
@table @code
@item -1
The length of @var{span1} is shorter than the length of @var{span2}.
@item 0
The lengts of @var{span1} and @var{span2} are equal.
@item +1
The length of @var{span1} is greater than the length of @var{span2}.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;

/* ...create and manipulate `span1' and `span2'... */
switch (pdf_time_span_cmp (span1, span2))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal to the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Calendar Spans Management
@subsection  Calendar Spans Management

@deftypefun pdf_status_t pdf_time_add_cal_span_with_base (const struct pdf_time_cal_span_s *@var{p_span1}, const struct pdf_time_cal_span_s *@var{p_span2}, const pdf_time_t @var{base_time}, struct pdf_time_cal_span_s *@var{p_result})

Add two calendar spans. Since the calendar spans are relative (some
years has more days than another) the calendar spans are first
resolved from a base time.

@table @strong
@item Parameters

@table @var
@item p_span1
The pointer to the first calendar span to add.
@item p_span2
The pointer to the second calendar span to add.
@item base_time
The base time to use.
@item p_result
Pointer to the calendar span to store the result of the add operation.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span1;
struct pdf_time_cal_span_s cal_span2;
struct pdf_time_cal_span_s cal_result;

/* ...create and initialize `mytime', `cal_span1'
 *    and `cal_span2'...
 */

if (pdf_time_add_cal_span_with_base (&cal_span1,
                                     &cal_span2,
                                     mytime,
                                     &cal_result) == PDF_EBADDATA)
@{
  /* Invalid data in `cal_span1' or `cal_span2' */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_i32_t pdf_time_cal_span_cmp (const struct pdf_time_cal_span_s *@var{p_span1}, const struct pdf_time_cal_span_s *@var{p_span2}, const pdf_time_t @var{base_time}, pdf_status_t *p_ret_code)

Compare two calendar spans previously resolved with a given base time.

@table @strong
@item Parameters

@table @var
@item p_span1
The pointer to the first calendar span to be compared.
@item p_span2
The pointer to the second calendar span to be compared.
@item base_time
The used base time. Should be a correctly created time variable.
@item p_ret_code
Pointer to a status variable to store any error happened in the function.
@end table

@item Returns

@table @code
@item -1
Given the base time, the time interval defined by @var{p_span2} is
greater in length than the time interval defined by @var{p_span1}.
@item 0
Given the base time, the time inveral defined by @var{p_span1} is equal
in length than the time interval defined by @var{p_span2}.
@item +1
Given the base time, the time interval defined by @var{p_span1} is
greater in length than the time interval defined by @var{p_span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;

/* ...create and manipulate `mytime', `span1' and `span2'... */

switch (pdf_time_cal_span_cmp (&span1, &span2, mytime))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal than the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_cal_span_diff (const struct pdf_time_cal_span_s *@var{p_span1}, const struct pdf_time_cal_span_s *@var{p_span2}, const pdf_time_t @var{base_time}, struct pdf_time_cal_span_s *@var{p_result})

Compute the difference between two calendar spans relative to a given
base time and store it in a given calendar span.

@table @strong
@item Parameters

@table @var
@item p_span1
The pointer to the first calendar span to diff.
@item p_span2
The pointer to the second calendar span to diff.
@item base_time
The base time. Should be a correctly created time variable.
@item p_result
Pointer to the calendar structure holding the result of the difference.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;
struct pdf_time_cal_span_s result;

/* ...create and manipulate `span1', `span2' and
 *    `result'...
 */

if (pdf_time_cal_span_diff (&span1,
                            &span2,
                            mytime,
                            &result) == PDF_EBADDATA)
@{
  /* Invalid data in `span1' or `span2' */
@}
@end example
@end table
@end deftypefun

@node Platform-specific functions
@subsection Platform-specific functions

@deftypefun pdf_status_t pdf_time_w32_set_from_filetime (pdf_time_t @var{time_var}, const FILETIME *@var{p_filetime})
This function will initialize @var{time_var} to the given Filetime epoch in UTC timescale.

This function is only available in Windows OS.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to set. Should be a properly create time variable.
@item p_filetime
Pointer to a valid FILETIME structure, containing 100-nanosecond intervals since 1 January 1601.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;
FILETIME filetime;
mytime = pdf_time_new ();

/* do stuff to get the FILETIME */

pdf_time_w32_set_from_filetime(mytime, &filetime);

@end example
@end table
@end deftypefun



@node The Filesystem Module
@section The Filesystem Module

@menu
* Filesystem Concepts::
* Filesystem Interfaces::
* The Filesystem Interface::
* The File Interface::
* The Filesystem Implementation Interface::
* The Filesystem Definition Interface::
@end menu

@node Filesystem Concepts
@subsection Filesystem Concepts

Filesystem objects provides access to file system services in an
abstract way, letting the library client to define filesystems for
other classes of devices. Open files are readable or writeable file
items in a filesystem. Path names are named locations identifying
files or folders.

In the GNU PDF Library a filesystem object (of type @code{pdf_fsys_t}) is
an implementation of the file system services for a specific class of
devices. The filesystem object provides the functionality to open
files, read and write data from/to open files, create and delete
folders, rename files, manage file and folder permissions, etc.

By implementing the functions defined in the Filesystem Implementation
Interface the client can define and use its own filesystems. In this
way a high level of abstraction is achieved in the library code that
uses the filesystem services: the library is able to read the contents
of a PDF file from a file stored in the local filesystem, from a
network webdav based filesystem, an http server or a compressed image.

The GNU PDF Library provides the default @emph{disk} filesystem
implementation for each supported plattform.

Conceptually speaking a filesystem contain a tree (or several
trees in some filesystem implementations supporting several
volumes) of @emph{filesystem items}.

Each time has a type and several properties. The client can ask the
filesystem for the properties of a given item identified by a path
name.

An open file object (of type @code{pdf_fsys_file_t}) represent a readable
and/or writable file in a filesystem. Open files are associated with a
given filesystem and any filesystem can maintain an arbitrary number
of open files (this may depend on the specific filesystem
implementation).

The client can read and write data from/to an open file using the
@code{pdf_fsys_file_*} functions. The implementation of the open files
then call to the appropriate functionality of the filesystem managing
the file.

The client should close any opened file calling the appropriate
function on the underlying filesystem.

There is not an explicit data type for an @emph{open folder} in the GNU
PDF Library. Instead, folders are referred using @emph{path names}.

The Filesystem Interface provides functions to create, delete and
rename folders.

Both files and folders in a filesystem can be referred using a string
locator: a @emph{path name}. Path names are implemented using PDF
strings. Several path names can refer to the same file or folder.

Both the encoding and the format of the contents of a path name
depends on the specific filesystem implementation. The default disk
filesystem provided by the GNU PDF Library uses the textual device
idependent file specifications described in the PDF Reference (section
3.10). The interpretation of those path names depend in the specific
plattform where the library is running. See XXX for more information
about the disk filesystem path names.

@node Filesystem Interfaces
@subsection Filesystem Interfaces

This section describes several interfaces that can be found in the
Filesystem module. There is an internal interface filesystem
implementors can implement to define a new filesystem. It is called
the @emph{Filesystem Implementation Interface}. A @emph{Filesystem Definition
Interface} allow users to register the implementation functions into a
filesystem variable. There are also two interfaces implemented by the
Filesystem module allowing clients to access the module functionality:
the @emph{Filesystem Interface}, used to manage several filesystem
aspects, and the @emph{File Interface}, that provides functionalities
related to open files, such as reading and writing information.

@node The Filesystem Interface
@subsection The Filesystem Interface

The Filesystem Interface is implemented by the Filesystem module and
provides access to some filesystem functionalities in a filesystem
implementation independent way.

The functionality covered by the Filesystem Interface includes:

@itemize @bullet
@item
Folder management.
@item
Folder contents management.
@item
Volume-level flush operations.
@item
Read In Advance (RIA) capabilities.
@item
Storage properties management (free space, etc).
@item
Management of filesystem items (rename, remove, flags, etc).
@end itemize

Note that not all the filesystem implementations support these
operations. Read In Advance capabilities, for example, are usually
implemented in slow file system devices such as network
filesystems. When a specific filesystem implementation does not support
a functionality in the Filesystem Interface then the specific call
becomes a no-op.

@menu
* Filesystem Data Types::
* Getting File System Properties::
* Folder Management::
* Getting File System Item Properties::
@end menu

@node Filesystem Data Types
@subsubsection Filesystem Data Types

The following data types are defined and provided to the client by the
Filesystem Module.

@deftp {Data Type} pdf_fsys_t
An opaque type representing a filesystem.
@end deftp


@deftp {Data Type} struct pdf_fsys_item_props_s
This structure holds information about a filesystem item (a file or a
directory).

@table @code
@item pdf_bool_t is_hidden
@item pdf_bool_t is_readable
@item pdf_bool_t is_writable
@item pdf_time_t creation_date
@item pdf_time_t modification_date
@item pdf_u32_t file_size_high
@item pdf_u32_t file_size_low
@item pdf_u32_t folder_size
@end table
@end deftp

@node Getting File System Properties
@subsubsection Getting File System Properties

@deftypefun pdf_i64_t pdf_fsys_get_free_space (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Get the free storage space in the volume containing @var{path_name}.

@table @strong
@item Parameters
@table @var
@item file_system
A filesystem. If @code{NULL} then the default filesystem is used.
@item path_name
A path name.
@end table
@item Returns
A 64-bit value containing the remaining free space in the volume
containing @var{path_name}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Folder Management
@subsubsection Folder Management

@deftypefun pdf_status_t pdf_fsys_create_folder (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name})

Create a folder named @var{path_name}.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
The path name of the folder to be created.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The folder was successfully created.
@item PDF_EBADNAME
The specified @var{path_name} is incorrect.
@item PDF_EBADPERMS
The client does not have permissions to create the folder.
@item PDF_ERROR
Any other error condition.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_get_folder_contents (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name}, pdf_list_t @var{item_list})

Get a list with the path names of the items contained in a given folder.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
The path name of a folder.
@item item_list
An output list variable to hold the path names of the items contained
in the folder.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed.
@item PDF_EBADNAME
@var{path_name} does not name a folder in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to read the contents of the folder.
@item PDF_ERROR
Any other error condition.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_get_parent (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name}, pdf_text_t @var{parent_path})

Get the path name of the father of a given item in the filesystem.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
The path name of an item in the filesystem.
@item parent_path
Output text variable to hold the path of the parent of the item
identified by @var{path_name}. If @var{path_name} is the root
directory then @code{NULL} is returned in @var{parent_path}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The path name of the parent of the item was successfully stored in
@var{parent_path}.
@item PDF_EBADNAME
@var{path_name} does not name a valid item in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to get the parent of the specified
item.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_remove_folder (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name})

Remove an empty folder from the filesystem.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A path name of an empty folder in the filesystem.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The folder was successfully removed.
@item PDF_EBADNAME
@var{path_name} does not name a folder in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to remove the folder.
@item PDF_ERROR
Any other error.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Getting File System Item Properties
@subsubsection Getting File System Item Properties

The following functions provides access to generic properties of
filesystem items (both files and directories).

@deftypefun pdf_status_t pdf_fsys_get_item_props (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name}, struct pdf_fsys_item_props_s *@var{item_props})

Get the properties of a filesystem item identified by a path name.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A pdf string containing the path name of the filesystem item.
@item item_props
The address of a structure to hold the properties of the filesystem
item.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid path name.
@item PDF_EBADPERMS
The client does not have enough permissions to read the requested item.
@end table
@item Usage example
@example
struct pdf_fsys_item_props_s item_props;
pdf_status_t ret;
pdf_text_t path;

ret =  pdf_text_new_from_unicode ("/path/to/foo",
                                  12, PDF_TEXT_UTF8,
                                  &path);
/* Get the properties for the item */
pdf_status_t ret = pdf_fsys_get_item_props (NULL, path, &item_props);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_item_props_to_hash (const struct pdf_fsys_item_props_s @var{item_props}, pdf_hash_t @var{props_hash})

Get a PDF hash variable containing the properties of a filesystem
item.

The key-value pairs returned in the hash variable are the following:

@table @code
@item isHidden
Boolean value.
@item isReadable
Boolean value.
@item isWritable
Boolean value.
@item creationDate
Text value containing a PDF style date string.
@item modDate
Text value containing a PDF style date string.
@item fileSizeHigh
32bit unsigned integer value.
@item fileSizeLow
32bit unsigned integer value.
@item folderSize
32bit unsigned integer value.
@item creatorCode
32bit unsigned integer value.
@item versionMajor
32bit unsigned integer value.
@item versionMinor
32bit unsigned integer value.
@item isCheckedOut
Boolean value.
@item isPublished
Boolean value.
@end table

@table @strong
@item Parameters
@table @var
@item item_props
A filesystem item properties structure.
@item props_hash
A PDF hash variable. It will be filled with the properties of the
item.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded and the properties were stored in the hash
variable.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_p (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Determine if a given item, identified by a path name, exists in a given
filesystem.

@table @strong
@item Parameters
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A path name.
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The specified item exists in the filesystem.
@item PDF_FALSE
The specified item does not exist in the filesystem or the client does not
have enough permissions to be able to read it.
@end table
@item Usage example
@example
pdf_bool_t ret;
pdf_status_t status;
pdf_text_t path;

status = pdf_text_new_from_unicode ("/path/to/foo",
                                    12, PDF_TEXT_UTF8,
                                    &path);
/* Test whether the path to /path/to/foo is a valid path to foo */
pdf_bool_t ret = pdf_fsys_item_p (NULL, path);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_readable_p (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Determine if a given filesystem item, identified by a path name, is
readable.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A valid path name of an existing filesytem item.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The filesystem item is readable.
@item PDF_FALSE
The filesystem item is not readable.
@end table
@item Usage example
@example
pdf_status_t status;
pdf_text_t path;

status = pdf_text_new_from_unicode ("/path/to/foo",
                                    12, PDF_TEXT_UTF8,
                                    &path);
/* Determine if the item is readable */
pdf_bool_t ret = pdf_fsys_item_readable_p (NULL, path);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_writable_p (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Determine if a given filesystem item, identified by a path name, is
writable.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A valid path name of an existing filesystem item.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The filesystem item is writable.
@item PDF_FALSE
The filesystem item is not writable.
@end table
@item Usage example
@example
pdf_status_t status;
pdf_text_t path;

status = pdf_text_new_from_unicode ("/path/to/foo",
                                    12, PDF_TEXT_UTF8,
                                    &path);
/* Determine if the item is writable */
pdf_bool_t ret = pdf_fsys_item_writable_p (NULL, path);
@end example
@end table
@end deftypefun

@node The File Interface
@subsection The File Interface

The File Interface is implemented by the filesystem module and
provides access to filesystem functionality related with open files,
such as writing and reading data to/from a specific file.

Note that open file variables (@code{pdf_fsys_file_t}) contain a
reference to its underlying filesystem implementation, so the client
should only provide a correctly initialized (opened) file variable to
the @code{pdf_fsys_file_*} functions.

The functionality covered by the File Interface includes:

@itemize @bullet
@item
Synchronous Input/Output.
@item
Asynchronoous Input/Output (not to be confused with RIA. See above).
@item
File-level flush operations.
@item
File positioning management.
@item
File size management.
@item
File flags (status) management.
@end itemize

@menu
* File Data Types::
* Opening Files::
* File Properties Management::
* Comparing Files::
* Managing File Positions::
* Changing the Size of a File::
* Synchronous Input/Output::
* Read in Advance::
* Closing and Reopening Files::
@end menu



@node File Data Types
@subsubsection File Data Types

The following file-related data types are defined and provided to the
client by the Filesystem Module.

@deftp {Data Type} pdf_fsys_file_t
An opaque type representing an open file. The client can perform
several operations in the file using the @code{pdf_fsys_file_t} as a
reference.
@end deftp

@deftp {Data Type} {enum pdf_fsys_file_mode_e}

The mode used when opening a file in a filesystem. The available modes
are described in the following list.

@table @code
@item PDF_FSYS_OPEN_MODE_READ
The file is opened in read-only mode. The file should exist in the
filesystem.
@item PDF_FSYS_OPEN_MODE_WRITE
The file is opened in write-only mode. The file is truncated to 0
size (any previous contents are lost) if the file exists and it is
created if it does not exist.
@item PDF_FSYS_OPEN_MODE_RW
The file is opened in read/write mode. The file should exist in the
filesystem.
@item
@end table
@end deftp


@node Opening Files
@subsubsection Opening Files

@deftypefun pdf_status_t pdf_fsys_file_open (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name}, const enum pdf_fsys_file_mode_e @var{mode}, pdf_fsys_file_t *@var{file})

Open a file in @var{filesystem} identified by @var{path_name} using
the specified @var{mode} and store a new open file variable in
@var{file}.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A path name that identifies the file to be opened. The format and
encoding of this text variable depends on the underlying filesystem
implementation.
@item mode
The open mode to use to open the file.
@item file
The output file variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The file was successfully opened and stored in the @var{file}
variable.
@item PDF_EBADNAME
The path name specified in @var{path_name} does not identify an existing
file in the filesystem.
@item PDF_EBADPERMS
The client does not have permission to open the specified file using the
specified mode.
@item PDF_ENOMEM
Not enough memory.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_open_tmp (const pdf_fsys_t @var{filesystem}, pdf_fsys_file_t *@var{file})

Create a temporary file in @var{filesystem} and open it.

The temporary file is opened with mode @code{PDF_FSYS_OPEN_MODE_RW}
and stored in @var{file}.  The file will be automatically deleted with
it is closed.

Note that while the filesystem implementation may also delete the file
when the client application exits, it is not guaranteed.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item file
The output file variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The file was successfully opened and stored in the @var{file}
variable.  If the filesystem implementation does not support this
functionality then @code{NULL} is stored in @var{file}.
@item PDF_ENOMEM
Not enough memory.
@item PDF_ERROR
It was not possible to create the temporary file.
@end table
@item Usage example
@example
pdf_fsys_file_t tmpfile;
pdf_size_t written;

/* Open a temporary file and write some contents to it.  */
pdf_fsys_file_open_tmp (NULL, &tmpfile);
pdf_fsys_file_write (tmpfile, "Temporary data", 14, &written);

/* Close the file.  This deletes it from the filesystem.  */
pdf_fsys_file_close (tmpfile);
@end example
@end table
@end deftypefun

@node File Properties Management
@subsubsection File Properties Management

The following functions provides access to several properties of open
files.

@deftypefun pdf_size_t pdf_fsys_file_get_size (pdf_fsys_file_t @var{file})

Get the size (in number of octects) of a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
The size of the file in octects.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_fsys_t pdf_fsys_file_get_filesystem (pdf_fsys_file_t @var{file})

Get the filesystem associated with a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open fiile.
@end table
@item Returns
The filesystem associated with @var{file}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun {enum pdf_fsys_file_mode_e} pdf_fsys_file_get_mode (pdf_fsys_file_t @var{file})

Return the access mode used to open a given file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A mode value if successful, otherwise returns -1.
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_status_t status;
pdf_text_t path;

status = pdf_text_new_from_unicode ("/path/to/foo",
                                    12, PDF_TEXT_UTF8,
                                    &path);
ret = pdf_fsys_file_open (NULL, path, PDF_FSYS_OPEN_MODE_READ, file);

enum pdf_fsys_file_mode_e mode;
mode = pdf_fsys_file_get_mode(file);
@end example
@end table
@end deftypefun

@deftypefun pdf_text_t pdf_fsys_file_get_url (pdf_fsys_file_t @var{file})

Get a text variable containing a valid URL to refer to a given open
file. Note that for some filesystems could be not possible to build a
valid URL.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF text variable containing a valid URL that can be used to refer
to the open file.

If the filesystem does not support URLs then an empty string is
returned.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_set_mode (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{new_mode})

Update the mode of a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_mode
The new mode to set for the file.
@end table
@item Returns
Returns PDF_OK if the mode is set to the new mode, otherwise returns
an appropriate pdf_status_t error.
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The mode provided was invalid.
@item PDF_ERROR
General failure, most applicable to Win32.
@end table
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_status_t status;
pdf_text_t path;

status = pdf_text_new_from_unicode ("/path/to/foo",
                                    12, PDF_TEXT_UTF8,
                                    &path);
ret = pdf_fsys_file_open (NULL, path, PDF_FSYS_OPEN_MODE_WRITE, file);

enum pdf_fsys_file_mode_e mode = PDF_FSYS_OPEN_MODE_READ;
ret = pdf_fsys_file_set_mode(file, mode);
@end example
@end table
@end deftypefun

@node Comparing Files
@subsubsection Comparing Files

The following functions allow to compare files.

@deftypefun pdf_bool_t pdf_fsys_file_same_p (pdf_fsys_file_t @var{file}, pdf_text_t @var{path})

Determine whether a given open file is the same file as a given file
identified by a file path.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item path
A file path.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
Both files are the same file.
@item PDF_FALSE
The files are not the same file, or the given pathname does not identify
a file in the underlying filesystem.
@end table
@item Usage example
@example
pdf_bool_t ret;
pdf_fsys_file_t file; /* some pre-initialized file variable */
pdf_status_t status;
pdf_text_t other_path;

status = pdf_text_new_from_unicode ("/path/to/baz",
                                    12, PDF_TEXT_UTF8,
                                    &other_path);
ret = pdf_fsys_file_same_p (file, other_path);
@end example
@end table
@end deftypefun

@node Managing File Positions
@subsubsection Managing File Positions

The following functions allow to move the input/output pointer of a
buffer file (its ``current position'').

@deftypefun pdf_status_t pdf_fsys_file_get_pos (pdf_fsys_file_t @var{file}, pdf_size_t *@var{pos})

Get the current position (in octects) in a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item pos
The address of a @code{pdf_size_t} variable.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed.
@item PDF_ERROR
The function call failed due to an error.
@end table
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_status_t status;
pdf_text_t path;

status = pdf_text_new_from_unicode ("/path/to/foo",
                                    12, PDF_TEXT_UTF8,
                                    &path);
ret = pdf_fsys_file_open (NULL, path, PDF_FSYS_OPEN_MODE_WRITE, file);

pdf_size_t pos = 20;
ret = pdf_fsys_file_get_pos(file, pos);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_set_pos (pdf_fsys_file_t @var{file}, pdf_size_t @var{new_pos})

Set the current position in a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_pos
The new position of the file.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid new position.
@item PDF_EBADPERMS
The client does not have enough permissions to change the current file
position.
@end table
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_status_t status;
pdf_text_t path;

status = pdf_text_new_from_unicode ("/path/to/foo",
                                    12, PDF_TEXT_UTF8,
                                    &path);
ret = pdf_fsys_file_open (NULL, path, PDF_FSYS_OPEN_MODE_WRITE, file);

pdf_size_t pos = 20;
ret = pdf_fsys_file_set_pos(file, pos);
@end example
@end table
@end deftypefun

@node Changing the Size of a File
@subsubsection Changing the Size of a File


@deftypefun pdf_bool_t pdf_fsys_file_can_set_size_p (pdf_fsys_file_t @var{file}, pdf_size_t @var{size})

Determine if a given open file is resizeable to a given size.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item size
The new size for the file in octects.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The file can be resized to the given size.
@item PDF_FALSE
The file cannot be resized to the given size.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_set_size (pdf_fsys_file_t @var{file}, pdf_size_t @var{size})

Resize a given file to a given new size measured in octects.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_size
The new size for the file. If it is bigger than the previous size then
the file is augmented to that size. If it is shorter than the previous
size then the file gets truncated.
@end table
@item Returns
A PDF size value indicating the new size of the file. It should match
the requested new size, or is @code{0} if there is an error.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Synchronous Input/Output
@subsubsection Synchronous Input/Output

The following functions provides synchronous input/output for open
files.


@deftypefun pdf_status_t pdf_fsys_file_read (pdf_fsys_file_t @var{file}, pdf_char_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{read_bytes})

Synchronously read data from an open file item.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item buf
The buffer to hold the read data.
@item bytes
The number of octects to read.
@item read_bytes
The number of octects actually read.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
All the requested bytes were successfully read into @var{buf}.
@item PDF_EBADDATA
The file element or a given pointer is invalid.
@item PDF_EEOF
An end of file condition occurred.
@item PDF_ERROR
An error prevented to read the bytes.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_fsys_file_write (pdf_fsys_file_t @var{file}, pdf_char_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{written_bytes})

Synchronously write data to an open file item.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item buf
A pointer to memory containing the data to write into the file.
@item bytes
The number of octects to write.
@item written_bytes
The number of octects actually written.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
All the requested bytes were successfully written to @var{file}.
@item PDF_EBADDATA
The file element or a given pointer is invalid.
@item PDF_ENOMEM
A disk full condition ocurred.
@item PDF_ERROR
An error prevented to write the bytes.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_fsys_file_flush (pdf_fsys_file_t @var{file})

Flush all the written data for the specified file.

@table @strong
@item Parameters
@table @var
@item file
An open file variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The open file was flushed successfully.
@item PDF_EBADDATA
Bad function parameters to underlying @code{write()}.
@item PDF_EAGAIN
Try again.
@item PDF_ERROR
There was an error flushing the open file.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Read in Advance
@subsubsection Read in Advance

When working with slow filesystems (such as network filesystems) it is
useful to be able to request parts of the file in advance.

@deftypefun pdf_status_t pdf_fsys_file_request_ria (pdf_fsys_file_t @var{file}, pdf_size_t @var{offset}, pdf_size_t @var{count})

Request a Read-In-Advance operation in a given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function is a no-op.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item offset
The beginning of the requested block.
@item count
The size (in octects) of the requested block.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
An error occurred.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_has_ria (pdf_fsys_file_t @var{file})

Determine whether the filesystem is performing some RIA operation for
the given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function always return @code{PDF_FALSE}.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The filesystem is performing some RIA operation in the given file.
@item PDF_FALSE
There is not an outstanding RIA operation in the given file.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_cancel_ria (pdf_fsys_file_t @var{file})

Cancel any pending RIA operation in a given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function is a no-op.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Any pending RIA operation was cancelled.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Closing and Reopening Files
@subsubsection Closing and Reopening Files

The following functions allow to close an open file or to reopen it
using another file mode.

@deftypefun pdf_status_t pdf_fsys_file_close (pdf_fsys_file_t @var{file})

Close a given open file. Any pending output data is flushed before to
close the file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The file was successfully closed.
@item PDF_ERROR
There was an error closing the file.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_reopen (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{mode})

Reopen a given open file with a given mode.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item mode
A file mode.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The file was successfully reopened using the new mode.
@item PDF_EBADPERMS
The client does not have enough permissions to open the file using the
specified mode. The open file is now closed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node The Filesystem Implementation Interface
@subsection The Filesystem Implementation Interface

The filesystem implementation interface is a set of functions that are
installed in a @code{pdf_fsys_t} variable in order to provide its
functionality. By implementing those functions the client can provide
a filesystem for some (physical or logical) storage device: a webdav
directory, a read-only http filesystem, etc.

Note that the functions conforming the Implementation Interface are
not intended to be directly invoked by clients. Clients can access to
the functionality of the filesystem using indirect ways:

@itemize @bullet
@item
Making calls to the Filesystem Interface.
@item
Making calls to the File Interface.
@end itemize

The implementation of both interfaces then makes use of the Filesystem
Implementation Interface in order to honour the petition.

@menu
* File System Interface Implementation::
* File Interface Implementation::
@end menu

@node File System Interface Implementation
@subsubsection File System Interface Implementation

@deftp {Data Type} {pdf_status_t (*pdf_fsys_init_fn_t) (void **@var{data})}

Filesystem callback called to initialize the filesystem internal
state, if any.

This callback is called by the @code{pdf_fsys_create} function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_cleanup_fn_t) (void *@var{data})}

Filesystem callback called to cleanup the filesystem internal state,
if any.

This callback is called by the @code{pdf_fsys_destroy} function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_open_fn_t) (pdf_text_t @var{path_name}, enum pdf_fsys_file_mode_e @var{mode}, pdf_fsys_file_t *@var{file})}

Filesystem callback called to open a file identified by the path
@var{path_name} in the mode specified by @var{mode}. A new
@code{pdf_fsys_file_t} is created and stored in @var{file}.

This callback is called by the @code{pdf_file_fsys_open} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_open_tmp_fn_t) (pdf_fsys_file_t *@var{file})}

Filesystem callback called to create a temporary file, to open it in
read/write mode and to store it in @var{file}.

This callback is called by the @code{pdf_fsys_file_open_tmp} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_close_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to close a given file identified by the
open file variable @var{file}. The output buffers of the file are
flushed before to close it.

This callback is called by the @code{pdf_fsys_close} filesystem
interface function.
@end deftp

The following callbacks are defined to provide folder management:
creation, deletion and modification of folders in the filesystem and
retrieval of folder contents.

@deftp {Data Type} {pdf_status_t (*pdf_fsys_create_folder_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to create a folder identified by the
@var{path_name} path name.

This callback is called by the @code{pdf_fsys_create_folder}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_folder_contents_fn_t) (pdf_text_t @var{path_name}, pdf_list_t @var{item_list})}

Filesystem callback used to get the contents of a specified folder as
a list of path names.

This callback is called by the @code{pdf_fsys_get_folder_contents}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_parent_fn_t) (pdf_text_t @var{path_name}, pdf_text_t @var{parent_path})}

Filesystem callback used to get the path name of the father of a given
item in a filesystem. If @var{path_name} is the root directory then
NULL is returned in @var{parent_path}.

This callback is called by the @code{pdf_fsys_get_parent} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_remove_folder_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to remove an empty folder identified by
@var{path_name}.

This callback is called by the @code{pdf_fsys_remove_folder}
filesystem interface function.
@end deftp

The following callbacks are defined to provide synchronous
input/output in open files.


@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_read_fn_t) (pdf_fsys_file_t @var{file}, pdf_char_t*@var{buf}, pdf_size_t @var{bytes}, pdf_size_t*@var{read_bytes})}

Filesystem callback used to synchronously read data from an open file
item.

This callback is called by the @code{pdf_fsys_file_read} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_write_fn_t) (pdf_fsys_file_t @var{file}, pdf_char_t*@var{buf}, pdf_size_t @var{bytes}, pdf_size_t*@var{written_bytes})}
Filesystem callback used to synchronously write data to an open file
item.

This callback is called by the @code{pdf_fsys_file_write} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_flush_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to flush all the written data for the
specified file.

This callback is called by the @code{pdf_fsys_file_flush} file
interface function.
@end deftp

The following callbacks are defined to provide access to several
filesystem item properties. The file system items are addressed using
path names.

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_item_props_fn_t) (pdf_text_t @var{path_name}, struct pdf_fsys_item_props_s *@var{props})}

Filesystem callback used to get the properties of a named filesystem
item.

This callback is called by the @code{pdf_fsys_get_item_props}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_size_t (*pdf_fsys_get_free_space_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to get the free storage space in the volume
containing @var{path_name}.

This callback is called by the @code{pdf_fsys_get_free_space} file
system interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_p_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given item,
identified by a path name, exists in a given filesystem.

This callback is called by the @code{pdf_fsys_item_p} file system
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_readable_p_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given filesystem
item, identified by a path name, is readable.

This callback is called by the @code{pdf_fsys_item_readable_p}
file system interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_writable_p_fn_t) (pdf_fsys_t @var{filename}, pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given filesystem
item, identified by a path name, is writeable.

This callback is called by the @code{pdf_fsys_item_writeable_p} file
system interface function.
@end deftp

@node File Interface Implementation
@subsubsection File Interface Implementation

The following callbacks are defined to provide access to several file
properties.

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_can_set_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to determine if it is possible to set the
size of a given file to an especified value.

The callback should return a PDF bool value specifying if it is
possible to perform the operation.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_get_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to get the logical size of a file (in
octects).

The callback should return a PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed and the logical size of the
file was stored in @var{pos}.
@item PDF_BADPERMS
The client does not have enough permissions to get the logical size of
@var{file}.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to set the logical size of a file (in
octects).

The callback should return a PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed and the logical size of the
file was changed.
@item PDF_BADPERMS
The client does not have enough permissions to set the logical size of
@var{file}.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_get_pos_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t *@var{pos})}

Filesystem callback used to get the current position in a given file.

The callback should return a PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed and the current position in
@var{file} was stored in @var{pos}.
@end table

This callback is called by the @code{pdf_fsys_file_get_pos} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_pos_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to set the current position in a given file.

The callback should return a PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed and the current position in
n@var{file} was set to @var{pos}.
@end table

This callback is called by the @code{pdf_fsys_file_set_pos} file
interface function.
@end deftp

@deftp {Data Type} {enum pdf_fsys_file_mode_e (*pdf_fsys_file_get_mode_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to get the open mode of a given open file.

This callback is called by the @code{pdf_fsys_file_get_mode} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_mode_fn_t) (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{new_mode})}

Filesystem callback used to update the mode of a given open file with
a given set of file modes.

This callback is called by the @code{pdf_fsys_file_set_mode} file
interface function.
@end deftp

@deftp {Data Type} {pdf_text_t (*pdf_fsys_file_get_url_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to get a URL pointing to a given open file.

This callback is called by the @code{pdf_fsys_file_get_url} file
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_same_p_fn_t) (pdf_fsys_file_t @var{file}, pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given open file is the
same file as a given file identified by a file path.

This callback is called by the @code{pdf_fsys_file_same_p} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_request_ria_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{offset}, pdf_size_t @var{count})}

Filesystem callback used to request a Read-In-Advance operation in a
given open file.

This callback is called by the @code{pdf_fsys_file_request_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_has_ria_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to determine whether the filesystem is
performing some RIA operation for the given open file.

This callback is called by the @code{pdf_fsys_file_has_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_cancel_ria_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to cancel any pending RIA operation in a
given open file.

This callback is called by the @code{pdf_fsys_file_cancel_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_close_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to close a given open file.

This callback is called by the @code{pdf_fsys_file_close} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_reopen_fn_t) (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{mode})}

Filesystem callback used to reopen a given open file with a
given mode.

This callback is called by the @code{pdf_fsys_file_reopen} file
interface function.
@end deftp

@node The Filesystem Definition Interface
@subsection The Filesystem Definition Interface

The Filesystem Definition Interface is implemented by the Filesystem
module and provides functionality to provide an implementation of a
filesystem. A @code{pdf_fsys_t} should be properly defined before to
use it.

The Filesystem Definition Interface defines the following elements:

@itemize @bullet
@item
The function types conforming the Filesystem Implementation Interface.
@item
Installation functions to register implementation functions into a
filesystem variable.
@end itemize

@menu
* File System Definition Data Types::
* File System Definition Functions::
@end menu

@node File System Definition Data Types
@subsubsection File System Definition Data Types

@deftp {Data Type} struct pdf_fsys_impl_s

Structure containing the callbacks to a concrete file system
implementation.

The members of the structure are the following:

@table @code
@item pdf_fsys_init_fn init_fn
@item pdf_fsys_cleanup_fn cleanup_fn
@item pdf_fsys_open_fn_t open_fn
@item pdf_fsys_close_fn_t c close_fn
@item pdf_fsys_create_folder_fn_t create_folder_fn
@item pdf_fsys_get_folder_contents_fn_t get_folder_contents_fn
@item pdf_fsys_get_parent_fn_t get_parent_fn
@item pdf_fsys_remove_folder_fn_t remove_folder_fn
@item pdf_fsys_file_read_fn_t file_read_fn
@item pdf_fsys_file_write_fn_t file_write_fn
@item pdf_fsys_file_flush_fn_t fiile_flush_fn
@item pdf_fsys_get_item_props_fn_t get_item_props_fn
@item pdf_fsys_get_free_space_fn_t get_free_space_fn
@item pdf_fsys_item_p_fn_t item_p_fn
@item pdf_fsys_item_readable_p_fn_t item_readable_p_fn
@item pdf_fsys_item_writable_p_fn_t item_writable_p_fn
@item pdf_fsys_get_temp_path_name_fn_t get_temp_path_name_fn
@item pdf_fsys_file_can_set_size_fn_t file_can_set_size_fn
@item pdf_fsys_file_get_size_fn_t file_get_size_fn
@item pdf_fsys_file_set_size_fn_t file_set_size_fn
@item pdf_fsys_file_get_pos_fn_t file_get_pos_fn
@item pdf_fsys_file_set_pos_fn_t file_set_pos_fn
@item pdf_fsys_file_get_mode_fn_t file_get_mode_fn
@item pdf_fsys_file_set_mode_fn_t file_set_mode_fn
@item pdf_fsys_file_get_url_fn_t file_get_url_fn
@item pdf_fsys_file_same_p_fn_t file_same_p_fn
@item pdf_fsys_file_request_ria_fn_t file_request_ria_fn
@item pdf_fsys_file_has_ria_fn_t file_has_ria_fn
@item pdf_fsys_file_cancel_ria_fn_t file_cancel_ria_fn
@item pdf_fsys_file_close_fn_t file_close_fn
@item pdf_fsys_file_reopen_fn_t file_reopen_fn
@end table
@end deftp

@node File System Definition Functions
@subsubsection File System Definition Functions

@deftypefun pdf_fsys_t pdf_fsys_create (struct pdf_fsys_impl_s @var{implementation})

Create and return a new filesystem variable that will use a given
implementation.

@table @strong
@item Parameters
@table @var
@item implementation
A filesystem implementation.
@end table
@item Returns
A fileystem variable.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_destroy (pdf_fsys_t @var{filesystem})

Destroy a filesystem freein all used resources.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The filesystem was successfully destroyed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node The Tokeniser
@section The Tokeniser

The tokeniser module provides functions to:

@itemize @minus
@item Read PDF lexical tokens from a base layer stream
@item Write PDF lexical tokens into a base layer stream
@end itemize

@menu
* Tokeniser data types::
* Creation and destruction of tokenisers::
* Reading tokens::
* Writing tokens::
* Creating and destroying tokens::
* Accessing token attributes::
@end menu

@node Tokeniser data types
@subsection Tokeniser data types

@deftp {Data Type} pdf_token_t
A PDF token.
@end deftp

@deftp {Data Type} {enum pdf_token_type_e}
The type of a PDF token.

Valid values are:

@table @code
@item PDF_TOKEN_INTEGER
A PDF integer value.
@item PDF_TOKEN_REAL
A PDF real value (a floating-point number).
@item PDF_TOKEN_STRING
A PDF string.
@item PDF_TOKEN_NAME
A PDF name.
@item PDF_TOKEN_COMMENT
A PDF comment.
@item PDF_TOKEN_KEYWORD
A keyword, i.e., any string of regular characters such as ``null''
or ``R'' that is not matched as another type.
@item PDF_TOKEN_DICT_START
The ``<<'' operator, which marks the beginning of a dictionary.
@item PDF_TOKEN_DICT_END
The ``>>'' operator, which marks the end of a dictionary.
@item PDF_TOKEN_ARRAY_START
The ``['' operator, which marks the beginning of an array.
@item PDF_TOKEN_ARRAY_END
The ``]'' operator, which marks the end of an array.
@item PDF_TOKEN_PROC_START
The ``@{'' operator, which marks the beginning of a procedure.
@item PDF_TOKEN_PROC_END
The ``@}'' operator, which marks the end of a procedure.
@end table
@end deftp

@deftp {Data Type} pdf_token_reader_t
A token reader that operates on a reading base layer stream and provides
a stream of PDF tokens.
@end deftp

@deftp {Data Type} pdf_token_writer_t
A token writer that operates on a writing base layer stream,
generating the textual representation of a PDF token.
@end deftp

@node Creation and destruction of tokenisers
@subsection Creation and destruction of tokenisers

@deftypefun pdf_status_t pdf_token_reader_new (pdf_stm_t @var{stm}, pdf_token_reader_t *@var{reader})

Create a new token reader operating a given reading stream.

@table @strong
@item Parameters
@table @var
@item stm
A reading stream.
@item reader
A pointer to a token reader.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The reader was successfully created.
@item PDF_EBADDATA
@var{stm} is not a reading stream.
@item PDF_ENOMEM
Not enough memory to create the reader.
@item PDF_ERROR
An error prevented to perform the operation.
@end table
@item Usage example
@example
pdf_stm_t stream;
pdf_token_reader_t reader;

/* Open a file stream */
XXX

/* Create the token reader */
switch (pdf_token_reader_new (stream, &reader))
@{
   case PDF_BADDATA:
   @{
      /* STREAM is not a valid reading stream */
      break;
   @}
   case PDF_ENOMEM:
   @{
      /* Not enough memory to create the reader */
      break;
   @}
   case PDF_ERROR:
   @{
      /* Some other error prevented the creation of
         the reader */
      break;
   @}
   default:
   @{
      /* Success */
      break;
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_writer_new (pdf_stm_t @var{stm}, pdf_token_writer_t *@var{writer})

Create a new token writer operating a given reading stream.

@table @strong
@item Parameters
@table @var
@item stm
A writing stream.
@item writer
A pointer to a token writer.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The writer was successfully created.
@item PDF_EBADDATA
@var{stm} is not a writing stream.
@item PDF_ENOMEM
Not enough memory to create the writer.
@item PDF_ERROR
An error prevented to perform the operation.
@end table
@item Usage example
@example
pdf_stm_t stream;
pdf_token_writer_t writer;

/* Open a file stream */
XXX

/* Create the token writer */
switch (pdf_token_writer_new (stream, &writer))
@{
   case PDF_BADDATA:
   @{
      /* STREAM is not a valid writing stream */
      break;
   @}
   case PDF_ENOMEM:
   @{
      /* Not enough memory to create the writer */
      break;
   @}
   case PDF_ERROR:
   @{
      /* Any other error prevented the creation of
         the writer */
      break;
   @}
   default:
   @{
      /* Success */
      break;
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_reader_destroy (pdf_token_reader_t @var{reader})

Destroy a token reader freeing any used resources.

@table @strong
@item Parameters
@table @var
@item reader
The reader to destroy.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The token reader was destroyed.
@item PDF_EBADDATA
@var{reader} was NULL.
@end table
@item Usage example
@example
pdf_token_reader_t reader;

/* Create a reader */
XXX
/* Destroy the reader */
pdf_token_reader_destroy (reader);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_writer_destroy (pdf_token_writer_t @var{writer})

Destroy a token writer, freeing any used resources.

@table @strong
@item Parameters
@table @var
@item writer
The writer to destroy.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The token writer was destroyed.
@item PDF_EBADDATA
@var{writer} was NULL.
@end table
@item Usage example
@example
pdf_token_writer_t writer;

/* Create a writer */
XXX
/* Destroy the writer */
pdf_token_writer_destroy (writer);
@end example
@end table
@end deftypefun

@node Reading tokens
@subsection Reading tokens

@deftypefun pdf_status_t pdf_token_read (pdf_token_reader_t @var{reader}, pdf_u32_t @var{flags}, pdf_token_t *@var{token})

Read a token from a token reader.

@table @strong
@item Parameters
@table @var
@item reader
A token reader.
@item flags
A bitmask specifying a combination of these flags:
@table @code
@item PDF_TOKEN_NO_NAME_ESCAPES
Don't treat ``#'' as a special character when reading name tokens
(this flag should be used when reading PDF 1.1 files).
@item PDF_TOKEN_RET_COMMENTS
Return comments as tokens (rather than ignoring them).
@item PDF_TOKEN_END_AT_STREAM
Assume that a ``stream'' keyword token was just read, find the beginning
of the corresponding stream, and return PDF_EEOF when successful
(i.e., when the input stream is positioned after the first line feed).
@end table
@item token
A pointer to a pdf_token_t that will hold the read token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EAGAIN
It's not possible to read a full token now.
Since one may have been partially read, the operation should be repeated
with the same flags when data becomes available.
@item PDF_EEOF
Reached the end of the input stream (at a valid position).
@item PDF_EBADFILE
The stream violates the PDF specifications.
@item PDF_EIMPLLIMIT
It's not possible to read the next token without exceeding an
implementation limit (e.g., the token is too long).
@item PDF_ERROR
An unspecified error occurred.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_reader_reset (pdf_token_reader_t @var{reader})

Reset the state of the token reader.

@table @strong
@item Parameters
@table @var
@item reader
A token reader.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@end table
@end deftypefun

@node Writing tokens
@subsection Writing tokens

@deftypefun pdf_status_t pdf_token_write (pdf_token_writer_t @var{writer}, pdf_u32_t @var{flags}, pdf_token_t @var{token})

Write a given token using a given token writer.

@table @strong
@item Parameters
@table @var
@item writer
A token writer.
@item flags
A bitmask specifying a combination of these flags:
@table @code
@item PDF_TOKEN_NO_NAME_ESCAPES
Don't escape special characters using ``#'' when writing name tokens
(this flag should be used when writing PDF 1.1 files).
@item PDF_TOKEN_HEX_STRINGS
Write strings in hexadecimal encoding.
@item PDF_TOKEN_READABLE_STRINGS
Encode strings in a human-readable way
(i.e., in hexadecimal or with special characters escaped).
@end table
@item token
A PDF token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EAGAIN
It's not possible to write a full token now.
Since it may have been partially written, the operation must be repeated
with the same arguments when the stream becomes writable.
@item PDF_EBADDATA
One of the arguments is invalid. This may be caused by an invalid token
(e.g., one that contains unrepresentable characters).
@item PDF_ERROR
An unspecified error occurred.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_writer_reset (pdf_token_writer_t @var{writer})

Reset the state of the token writer.

@table @strong
@item Parameters
@table @var
@item reader
A token writer.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@end table
@end deftypefun

@node Creating and destroying tokens
@subsection Creating and destroying tokens

@deftypefun pdf_status_t pdf_token_integer_new (pdf_i32_t @var{value}, pdf_token_t *@var{token})

Create an integer token.

@table @strong
@item Parameters
@table @var
@item value
The numeric value for the token.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_real_new (pdf_real_t @var{value}, pdf_token_t *@var{token})

Create a real (floating-point number) token.

@table @strong
@item Parameters
@table @var
@item value
The numeric value for the token.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_string_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a string token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the string.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_name_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a name token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the name.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_keyword_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a keyword token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the keyword.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_comment_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a comment token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the keyword.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_valueless_new (enum pdf_token_type_e @var{type}, pdf_token_t *@var{token})

Create a token of one of the valueless types (PDF_TOKEN_DICT_START,
PDF_TOKEN_DICT_END, PDF_TOKEN_ARRAY_START, PDF_TOKEN_ARRAY_END,
PDF_TOKEN_PROC_START, or PDF_TOKEN_PROC_END).

@table @strong
@item Parameters
@table @var
@item type
The type of token to create.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
The given type is not valid for this constructor.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_dup (const pdf_token_t @var{old}, pdf_token_t *@var{new})

Create a copy of the given token.

@table @strong
@item Parameters
@table @var
@item old
The token to copy.
@item new
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_destroy (pdf_token_t @var{token})

Destroy the given token, freeing any memory it used.

@table @strong
@item Parameters
@table @var
@item old
The token to copy.
@item new
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@end table

@end deftypefun

@node Accessing token attributes
@subsection Accessing token attributes

@deftypefun {enum pdf_token_type_e} pdf_token_get_type (pdf_token_t @var{token})

Get the type of a given token.

@table @strong
@item Parameters
@table @var
@item token
A token.
@end table
@item Returns
The type of the given token.
@item Usage example
@example
pdf_token_t token;
pdf_token_reader_t reader;

/* ... */

/* Read a name */
if (pdf_token_read (reader, &token) != PDF_OK)
@{
   /* Error */
@}
if (pdf_token_get_type (token) != PDF_TOKEN_NAME)
@{
   /* We were expecting a name */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_token_equal_p (const pdf_token_t @var{token1}, const pdf_token_t @var{token2})

Determines whether the given tokens are equivalent.

@table @strong
@item Parameters
@table @var
@item token1
A token.
@item token2
Another token.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The given tokens are equal.
@item PDF_FALSE
The tokens are not equal.
@end table
@end table

@end deftypefun

@deftypefun pdf_i32_t pdf_token_get_integer_value (const pdf_token_t @var{token})

Returns the value associated with a given integer token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_INTEGER.
@end table
@item Returns
The token's value.
@end table

@end deftypefun

@deftypefun pdf_real_t pdf_token_get_real_value (const pdf_token_t @var{token})

Returns the value associated with a given real token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_REAL.
@end table
@item Returns
The token's value.
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_string_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given string token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_STRING.
@end table
@item Returns
A pointer to the data, which will be valid until the token is destroyed.
The data is @strong{not} null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_string_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given string token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_STRING.
@end table
@item Returns
The string's size, in octets.
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_name_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given name token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_NAME.
@end table
@item Returns
A pointer to the name data, which will be valid until the token is destroyed.
The data is null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_name_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given name token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_NAME.
@end table
@item Returns
The name's size, in octets (excluding the terminating null byte).
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_keyword_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given keyword token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_KEYWORD.
@end table
@item Returns
A pointer to the data, which will be valid until the token is destroyed.
The data is null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_keyword_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given keyword token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_KEYWORD.
@end table
@item Returns
The keyword's size, in octets (excluding the terminating null byte).
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_comment_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given comment token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_COMMENT.
@end table
@item Returns
A pointer to the data, which will be valid until the token is destroyed.
The data is @strong{not} null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_comment_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given comment token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_COMMENT.
@end table
@item Returns
The comment's size, in octets.
@end table

@end deftypefun

@node Encryption
@section Encryption

This section describes related to encryption functions.

@menu
* Creating and destroying Ciphers::
* Encryption and decryption::
* Message digest functions::
* Utilities::
@end menu


@node Creating and destroying Ciphers
@subsection Creating and destroying Ciphers

@deftp {Data Type} {enum pdf_crypt_cipher_algo_e}
An algorithm provided. It contains low level functions of the algorithm
implementation.

@table @code
@item PDF_CRYPT_CIPHER_ALGO_AESV2
Use AES algorithm with a key of 128 bits to encrypt the data.
@item PDF_CRYPT_CIPHER_ALGO_V2
Use ARC4 algorithm.
@end table
@end deftp

@deftp {Data Type} {pdf_crypt_cipher_t}
A cipher. It contains data which is required between several calls to
functions.
@end deftp

@deftypefun pdf_status_t pdf_crypt_cipher_new (enum pdf_crypt_cipher_algo_e @var{algorithm}, pdf_crypt_cipher_t *@var{cipher})

Create a new cipher.

@table @strong
@item Parameters
@table @var
@item algorithm
The algorithm the cipher will use in order to encrypt or decrypt data.
@item cipher
A pointer to @code{pdf_crypt_cipher_t} variable where it will put the cipher.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
A error ocurred when trying to create the cipher.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_cipher_t cipher;

st = pdf_crypt_cipher_new (PDF_CRYPT_CIPHER_ALG_AESV2, &cipher);

if (st != PDF_OK)
@{
   /* Error */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_destroy (pdf_crypt_cipher_t @var{cipher})

Destroy a cipher.

@table @strong
@item Parameters
@table @var
@item cipher
The cipher you want destroy. It must have been created with
@code{pdf_crypt_cipher_new} functions previously.
@end table
@item Returns
@table @code
A PDF status value:
@item PDF_OK
Operation successful
@item PDF_ERROR
A error ocurred when trying to destroy the cipher.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_crypt_cipher_new (PDF_CRYPT_CIPHER_ALG_AESV2, &cipher);
pdf_crypt_cipher_destroy (cipher);
@end example
@end table
@end deftypefun


@node Encryption and decryption
@subsection Encryption and decryption

@deftypefun pdf_status_t pdf_crypt_cipher_setkey (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{key}, pdf_size_t @var{size})

Set the key which will be used to encrypt and decrypt data.

@table @strong
@item Parameters
@table @var
@item cipher
A pointer to a cipher created previously.
@item key
A pointer to memory where the key is stored.
@item size
The length of the key in bytes. Note that some algorithms could require
a fixed length of key.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Invalid argument. The @var{size} parameter is not supported by the
cipher.
@item PDF_ERROR
A error ocurred while trying to set the key.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_cipher_t cipher;
pdf_char_t key[16];

/* ... */
st = pdf_crypt_cipher_setkey (&cipher, key, sizeof(key));

if (st != PDF_OK)
@{
   /* Error */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_encrypt (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size}, pdf_size_t *@var{result_size})

Encrypt a buffer. The ciphered text will be put in @var{out}.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item out
A pointer to the output buffer.
@item out_size
Size reserved for the output buffer in bytes. The function will fail if
it is not too large to contain the output.
@item in
A pointer to input buffer.
@item in_size
The length of the input buffer in bytes. I must be greater than
zero. Some algorithms requires than IN_SIZE to be multiple of a fixed
integer.
@item result_size
A pointer where it will put the real size of the output buffer. This
size will be lesser or equal than out_size.
@end table
@item Returns
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_status_t st;
pdf_char_t *out;
pdf_char_t *in;
pdf_size_t out_size;
pdf_size_t in_size;

/* ... */
out_size = pdf_crypt_cipher_encrypt_size (cipher, in, in_size);
out = pdf_alloc (out_size);

st = pdf_crypt_cipher_encrypt (cipher, out, out_size, in, in_size, &out_size);

if (st != PDF_OK)
@{
  /* Error*/
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_decrypt (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size}, pdf_size_t *@var{result_size})

Decrypt a buffer. The plain text will be put in @var{out}.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item out
A pointer to the output buffer.
@item out_size
Size reserved for the output buffer in bytes. The function will fail if
it is not too large to contain the output.
@item in
A pointer to input buffer.
@item in_size
The length of the input buffer in bytes. It must be greater than zero.
@item result_size
A pointer where it will put the real size of the output buffer. This size
will be lesser or equal than out_size.
@end table
@item Returns
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_status_t st;
pdf_char_t *out;
pdf_char_t *in;
pdf_size_t out_size;
pdf_size_t in_size;

/* ... */
out_size = pdf_crypt_cipher_decrypt_size (cipher, in, in_size);
out = pdf_alloc (out_size);

st = pdf_crypt_crypt_decrypt (cipher, out, out_size, in, in_size, &out_size);

if (st != PDF_OK)
@{
  /* Error*/
@}
@end example
@end table
@end deftypefun

@node Message digest functions
@subsection Message digest functions

@deftp {Data Type} {enum pdf_crypt_md_algo_e}
An algorithm provided. It contains low level functions of the algorithm
implementation.

@table @code
@item PDF_CRYPT_MD_MD5
Use the md5 algorithm.
@end table
@end deftp

@deftp {Data Type} {pdf_crypt_md_t}
A message-digest descriptor.
@end deftp



@deftypefun pdf_status_t pdf_crypt_md_new (enum pdf_crypt_md_algo_e @var{algo}, pdf_crypt_md_t  *@var{md})

Create a message-digest descriptor for an algorithm.

@table @strong
@item Parameters
@table @var
@item md
A pointer to the pdf_crypt_md_t.
@item algo
Algorithm which be used to hashing.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_md_t md;

st = pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

if (st != PDF_OK)
@{
   /* Error /*
@}
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_crypt_md_write (pdf_crypt_md_t @var{md}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size})

Pass a buffer to the message-digest handler in order to compute its digest.

@table @strong
@item Parameters
@table @var
@item md
A message-digest descriptor.
@item in
A pointer to the input buffer.
@item in_size
Size of the input buffer in bytes.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Bad parameter. The size of the output buffer is wrong.
@end table
@item Usage example
@example
pdf_crypt_md_t md;
pdf_char_t *in;
pdf_size_t in_size;
pdf_status_t st;

/* ...Prepare IN and IN_SIZE variables */

pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

st = pdf_crypt_md_hash (md, in, in_size);

if (st != PDF_OK)
@{
   /* Error */
@}

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_crypt_md_read (pdf_crypt_md_t @var{md}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size})

Read the computed digest value from a message-digest descriptor.

@table @strong
@item Parameters
@table @var
@item md
A message-digest descriptor.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Bad parameter. The size of the output buffer is wrong.
@end table
@item Usage example
@example
pdf_crypt_md_t md;
pdf_char_t *out;
pdf_size_t out_size;
pdf_status_t st;

pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

/* ...Write the buffer into descriptor here... */

st = pdf_crypt_md_read (md, out, out_size);

if (st != PDF_OK)
@{
   /* Error */
@}

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_crypt_md_destroy (pdf_crypt_md_t  @var{md})

Destroy a message-digest descriptor.

@table @strong
@item Parameters
@table @var
@item md
An message-digest descriptor.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_md_t md;

st = pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

/* ... /*

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun


@node Utilities
@subsection Utilities

@deftypefun pdf_status_t pdf_crypt_nonce (pdf_char_t *@var{buffer}, pdf_size_t @var{size})

Fill a buffer with random bytes.

@table @strong
@item Parameters
@table @var
@item buffer
Buffer which be filled.
@item size
Size of the buffer in bytes.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_char_t buffer[16];

pdf_crypt_nonce (buffer, sizeof(buffer));
@end example
@end table
@end deftypefun



@node Object Layer
@chapter Object Layer

@menu
* Object Layer Overview::
* PDF Objects::
* Object Documents::
@end menu

@node Object Layer Overview
@section Overview

In its more fundamental structure, a PDF document is conformed by a
collection of PDF objects organized in a certain way.  @dfn{PDF
objects} can be of several data types:

@table @dfn
@item Scalars
Scalar values are integer and real numbers and booleans (true, false).
@item Names
Name objects are atoms made out of a sequence of printable
characters.  They are finished by a null octet.

The characters of the string making up the name do not contribute to
the meaning of the name.
@item Strings
Strings are sequences of octects.  Note that the octects contained in
a PDF string are not restricted to the printable ASCII subset.  In
particular the null octet (@code{00H}) can be part of a string and it
is not used to to finalize it like in some programming languages.

The interpretation of the contents of a string depends of the selected
encoding and other factors.   Usually the UTF-8 encoding of ISO-16000
is used.
@item Arrays
Arrays are collections of objects that are arranged sequentially.
Unlike the arrays in most programming languages, PDF arrays does not
need to be homogeneous: the same array can contain objects of several
types including other arrays.
@item Dictionaries
Dictionaries are a set of @dfn{key-value pairs}.  Like arrays, they
are heterogeneous.  Unlike arrays, the objects contained in
dictionaries are usually accessed using the value of a key.  They are
like the associative arrays of some programming languages.

Both arrays and dictionaries are @dfn{containers}, meaning that they
can contain other objects.
@item Streams
Streams are like strings, but they are unrestrained (no limitation on
its size) and are accompanied by a descriptor dictionary.  The
descriptor contains information about the stream, like its size and
how its contents should be filtered when read.
@item Indirect References
An indirect reference is a way to refer to some indirect object (XXX:
xref).
@end table

By using container objects it is possible to build arbitrary
structures made out of objects.  A PDF document is a hierarchy of
objects arranged following some conventions.

@float Figure,fig:object-hierarchy
@image{gnupdf-figures/object-hierarchy}
@caption{Hierarchy of objects in a PDF document.}
@end float

The dictionary at the top of the hierarchy is known as the @dfn{root
dictionary}.  Any other object in the document shall be accessible
from the root dictionary.  The only exception is the optional
@dfn{information dictionary}.  If it exists it contains
meta-information about the document: software that made the document,
author, etc.

@quotation Note
The use of this layer can lead to non-well conformed PDF documents:
not every PDF object document define a document.  The client should be
careful when using this layer. In contrast the @ref{Document Layer}
provides a convenient API to manipulate PDF files while maintaining
its structural integrity.
@end quotation

@node PDF Objects
@section PDF Objects

PDF objects are the fundamental bricks used in PDF documents.  This
section describes data types and functions to create, destroy and
manipulate all kind of PDF objects: numbers, booleans, names, strings,
streams and the @code{null} object.

@menu
* Object Data Types::
* Generic Functions to Manipulate Objects::
* Object Strong References::
* Compressibility of Objects::
* Object Collections::
* Real Objects::
* Integer Objects::
* Boolean Objects::
* Name Objects::
* String Objects::
* Array Objects::
* Dictionary Objects::
* Stream Objects::
* Null Object::
@end menu

@node Object Data Types
@subsection Object Data Types

@deftp {Data Type} pdf_obj_t
Opaque type representing a PDF Object.

Despite being opaque, the user shall be aware that a @code{pdf_obj_t}
variable containing a direct scalar object shall be considered as the
object itself (its value).  Otherwise the variable shall be considered
as a ``reference''.
@end deftp

@deftp {Data Type} {enum pdf_obj_type_e}
Enumeration of the supported types of PDF objects:

@table @code
@item PDF_OBJ_REAL
Real objects denote quantities in the real domain, such as @code{3,14}
and @code{1,00000}.

@xref{Real Objects}.
@item PDF_OBJ_INTEGER
Integer objects denote quantities in the integer domain, such as
@code{3} and @code{1}.

@xref{Integer Objects}.
@item PDF_OBJ_BOOLEAN
Possible values are @dfn{true} and @dfn{false}.

@xref{Boolean Objects}.
@item PDF_OBJ_NAME
A PDF name is an atomic symbol uniquely defined by a sequence of
regular characters.  It does not have internal structure.

@xref{Name Objects}.
@item PDF_OBJ_STRING
A PDF string is a sequence of bytes whose values are in the range
@code{0-255}.

@xref{String Objects}.
@item PDF_OBJ_ARRAY
A heterogeneous array of PDF objects.

@xref{Array Objects}.
@item PDF_OBJ_DICT
A dictionary is a collection of key-value pairs.  Unlike the
postscript dictionaries the key should be a Name Object, while the
value is a PDF object of any type.

@xref{Dictionary Objects}.
@item PDF_OBJ_STREAM

@xref{Stream Objects}.
@item PDF_OBJ_NULL
The Null object has a type and a value that are unequal to those of
any other object.

@xref{Null Object}.
@end table
@end deftp

@deftp {Data Type} pdf_obj_id_t
A positive integer representing the identification number of a PDF
object.  An object ID uniquely represents an object into an object
document.
@end deftp

@deftp {Data Type} {pdf_obj_gen_t}
A non-negative number representing the generation number of a PDF object.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_obj_enum_fn_t) (pdf_obj_t @var{obj}, pdf_obj_t @var{value}, void *@var{client_data})}

Callback used in @code{pdf_obj_enum} that is called for every directly
contained object in a composite PDF object (array, dictionary,
stream).

@table @strong
@item Parameters
@table @var
@item obj
The meaning of this parameter depends on the type of @var{obj}:
@table @strong
@item Array
An array element.
@item Dictionary
A key.
@item Stream
The stream's dictionary.
@end table
@item value
The meaning of this parameter depends on the type of @var{obj}:
@table @strong
@item Array
The Null object.
@item Dictionary
A value.
@item Stream
The Null object.
@end table
@end table
@item Returns
A PDF status value.
@end table
@end deftp

@deftp {Data Type} pdf_obj_col_t
Opaque type representing an object collection into an object document.

@xref{Object Collections}.
@end deftp

@deftp {Data Type} {enum pdf_obj_stm_open_mode_e}

Open modes for PDF stream objects.

@table @code
@item PDF_OBJ_STM_OPEN_MODE_RAW
The data will be decrypted but not filtered.
@item PDF_OBJ_STM_OPEN_MODE_UNFILTERED
The data wont be filtered nor decrypted.
@item PDF_OBJ_STM_OPEN_MODE_FILTERED
The data will be both decrypted and filtered.
@end table
@end deftp

@node Generic Functions to Manipulate Objects
@subsection Generic Functions to Manipulate Objects

The following functions can be called on any @code{pdf_obj_t} variable
regardless its type.  But note that the effects of the call may vary
depending on the object type.

@deftypefun pdf_status_t pdf_obj_copy (pdf_obj_t @var{source}, pdf_obj_doc_t @var{dest_doc}, pdf_bool_t @var{copy_indirect}, pdf_obj_t *@var{dest})

Copy a PDF object from one document to another.
The destination document can be the same than the document associated
with @var{source}.

This operation sets the dirty flag of @var{dest_doc} if the copied
object is not a direct scalar.

@table @strong
@item Parameters
@table @var
@item source
The PDF object to copy.
@item dest_doc
The object document that will hold the copied object.
@item copy_indirect
A boolean value:
@table @code
@item PDF_TRUE
All indirectly referenced objects in @var{source} are copied to
@var{dest_doc}.
@item PDF_FALSE
The indirectly referenced objects in @var{source} are not copied to
@var{dest_doc}.  The corresponding entries in @var{source} will be
missing in @var{dest}.
@end table
@item dest
A PDF object to hold the copied object.
@end table
@item Returns
A PDF status value
@table @code
@item PDF_OK
The copy was successfully performed.
@item PDF_ENOMEM
Not enough memory to perform the copy.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{dest} is undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj1;
pdf_obj_t obj2;

...

/* Make a copy of 'obj1' in 'obj2' in the same object document
   'doc' */
if (pdf_obj_copy (obj1, doc, PDF_TRUE, &obj2)
    != PDF_ERROR_)
@{
   /* 'obj2' now contains a copy of 'obj1'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_destroy (pdf_obj_t @var{obj})

Destroy a PDF object @var{obj}.

This function is a nop if @var{obj} is a direct scalar type or the
Null object.

If @var{obj} is a composite object (array, dictionary, stream) then
any directly referenced object is also destroyed. The indirectly
referenced objects are not destroyed.  Note that this is a recursive
rule: a string directly contained in a dictionary that is in turn
directly contained in an array will be destroyed if the top-level
array is destroyed.

The root dictionary of an object document can not be destroyed.

This operation sets the dirty flag of the document containing the
object.

@table @strong
@item Parameters
@table @var
@item obj
The PDF object to destroy.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object was successfully destroyed.  The value of @var{obj} is now
undefined and shall not be used.
@item PDF_ERROR
An error prevented to complete the operation.  The value of @var{obj}
is now undefined and shall not be used.
@item PDF_EINVOP
The user requested to destroy the root dictionary of the object
document.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t info_dict;

...

/* Destroy the info dictionary of an object document */
pdf_obj_doc_get_info_dict (doc, &info_dict);
pdf_obj_destroy (info_dict);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_enum (pdf_obj_t @var{obj}, pdf_obj_enum_fn_t @var{enum_cb}, void *@var{client_data})

Enumerate all the elements of a PDF object by calling a
client-provided callback function.

@table @strong
@item Parameters
@table @var
@item obj
The PDF object whose elements are going to be enumerated. The specific
semantics of @code{pdf_obj_enum} depend on the type of this object:

@table @strong
@item Scalar or a string
The function does nothing and returns @code{PDF_OK}.
@item Dictionary
@var{enum_cb} is called for every key-value, passing the key as the
first argument and the value as the second argument. The enumeration
order is undefined.
@item Array
@var{enum_cb} is called for every element contained in the array,
passing the value as the first argument and the Null object as the second
argument.

The enumeration order is ascending with the index of the array.
@item Stream
@var{enum_cb} is called once with the stream dictionary as the first
parameter and the Null object as the second parameter.
@end table
@end table
@item Returns
A PDF status value, that is the AND logical value of the values
returned by the enumeration procedure, considering @code{PDF_OK} as
true and @code{<> PDF_OK} as false.
@item Usage example
@example
/* Callback function */
pdf_bool_t
my_enum_callback (pdf_obj_t obj,
                  pdf_obj_t value,
                  void *client_data)
@{
   /* Process the callback... */
@}

...

/* Perform an enumeration of the elements of some
   object */
if (pdf_obj_enum (obj, my_enum_callback, NULL))
@{
   /* All the calls to 'my_enum_callback' returned PDF_OK */
@}
else
@{
   /* Some call to 'my_enum_callback' returned <> PDF_OK */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_equal_p (pdf_obj_t @var{obj1}, pdf_obj_t @var{obj2})

Test whether two PDF objects are equal.

Two PDF objects are equal when all the following conditions are
satisfied:

@itemize @minus
@item They are both direct objects or indirect objects.
@item They have the same type.
@item If they are indirect, they share the same generation number and has the same object number.
@item If they are scalars, they have the same value.
@item If they are non-scalar, they reference the same value.
@end itemize

@table @strong
@item Parameters
@table @var
@item obj1
The first PDF object to compare.
@item obj2
The second PDF object to compare.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The PDF objects are equal.
@item PDF_FALSE
The PDF objects are not equal.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj1;
pdf_obj_t obj2;

...

/* Compare integers */
pdf_obj_integer_new (doc, PDF_TRUE, 10, &obj1);
pdf_obj_integer_new (doc, PDF_FALSE, 20, &obj2);
pdf_obj_equal_p (obj1, obj2); /* Returns PDF_FALSE */
pdf_obj_destroy (obj1);
pdf_obj_destroy (obj2);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_get_doc (pdf_obj_t @var{obj}, pdf_obj_doc_t *@var{doc})

Gets the object document associated with a given PDF object
@var{obj}.

This is a nop for direct scalar objects, since they are not associated
with an object document.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@item doc
A pointer to a @var{pdf_obj_doc_t} variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object document was stored in @var{doc}.
@item PDF_EINVOBJ
The specified object @var{obj} is a scalar object.
@item PDF_ERROR
An error prevented the operation to complete.  The value of
@var{doc} is now undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

...

if (pdf_obj_get_doc (obj, &doc)
    != PDF_ERROR)
@{
   /* 'doc' contains a reference to the object document containing
      'obj'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_get_generation (pdf_obj_t @var{obj}, pdf_obj_gen_t *@var{gen_number})

Get the generation number of a given indirect PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
An indirect PDF object.
@item gen_number
A pointer to a @code{pdf_obj_gen_t} variable to hold the generation number.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The generation number was stored in @var{gen_number}.
@item PDF_EINVOBJ
@var{obj} is not an indirect object.  Any previous contents of
@var{gen_number} are left untouched.
@item PDF_ERROR
An error prevented to complete the operation.  The value of
@var{gen_number} is invalid and shall not be used.
@end table
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_gen_t gen_number;

...

if (pdf_obj_get_generation (obj, &gen_number)
    == PDF_OK)
@{
   /* 'gen_number' contains the generation number of 'obj'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_get_id (pdf_obj_t @var{obj}, pdf_obj_id_t *@var{id_number})

Get the identification number of a given indirect PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
An indirect PDF object.
@item id_number
A pointer to a @code{pdf_obj_id_t} variable to hold the id number.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The identification number of @var{obj} was stored in @var{id_number}.
@item PDF_EINVOBJ
@var{obj} is not an indirect object.  The previous value of
@var{id_number} remains.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{id_number} is invalid and shall not be used.
@end table
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_id_t id_number;

...

if (pdf_obj_get_id (obj, &id_number)
    == PDF_OK)
@{
   /* 'id_number' contains the identification
      number of 'obj'. */
@}
@end example
@end table
@end deftypefun

@deftypefun enum pdf_obj_type_e pdf_obj_get_type (pdf_obj_t @var{obj})

Get the type of a given PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
The type of @var{obj}.
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

...

/* Create an integer object */
pdf_obj_integer_new (doc, PDF_FALSE, 10, &obj);

/* Get its type */
pdf_obj_get_type (obj);  /* Returns PDF_OBJ_INTEGER */
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_compressed_p (pdf_obj_t @var{obj})

Determine if a given PDF object @var{obj} is compressed (i.e. it is
contained in an object collection).

@xref{Object Collections}.
@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The object @var{obj} is compressed.
@item PDF_FALSE
The object @var{obj} is not compressed.
@end table
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_col_t objcol;

...

/* Add 'obj' to an object collection. */
pdf_obj_col_add_obj (objcol, obj);

/* The following call returns PDF_TRUE */
pdf_obj_compressed_p (obj);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_indirect_p (pdf_obj_t @var{obj})

Determine if a given PDF object @var{obj} is indirect.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The object @var{obj} is indirect.
@item PDF_FALSE
The object @var{obj} is direct.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj_direct;
pdf_obj_t obj_indirect;

...

/* Create an indirect object */
pdf_obj_integer_new (doc, PDF_TRUE, 10, &obj_indirect);
pdf_obj_indirect_p (obj_indirect); /* Returns PDF_TRUE */

/* Create a direct object */
pdf_obj_integer_new (doc, PDF_FALSE, 10, &obj_direct);
pdf_obj_indirect_p (obj_direct); /* Returns PDF_FALSE */
@end example
@end table
@end deftypefun

@node Object Strong References
@subsection Object Strong References

Every PDF object (but direct scalars) contained in an object document
features an @dfn{acquire counter} whose value is initially @code{0}.
The garbage collector (@pxref{Garbage collection in object documents})
never destroys unmarked objects with an acquire counter of 1 or more.

@deftypefun pdf_status_t pdf_obj_acquire (pdf_obj_t @var{obj})

Create a strong reference for @var{obj} in its container document by
incrementing its acquire counter by one.  For direct scalars this
operation is a nop.

@float Figure,fig:acquire-counters
@image{gnupdf-figures/acquire-counters}
@caption{Acquire counters in PDF objects.}
@end float

The above figure shows a container object @code{A} containing two
objects @code{B} and @code{C}.  The acquire counter of @code{B} is
@code{1}, meaning that someone acquired the object via the
@code{pdf_obj_t} variable.  If the object @code{A} is garbage
collected then @code{C} will be also collected, but @code{B} won't.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The strong reference was created or the request was ignored.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

/* Get an object from a document */
pdf_obj_doc_get_obj (doc, 10, &obj);

/* Create a strong reference for the object in `doc' */
pdf_obj_acquire (obj);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_release (pdf_obj_t @var{obj})

Remove a strong reference from the PDF object @var{obj} by decreasing
its acquire counter by one.

For direct scalars this operation is a nop.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The strong reference was destroyed or the operation was ignored.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

/* Get an object from a document */
pdf_obj_doc_get_obj (doc, 10, &obj);

/* Create a strong reference for the object in `doc'.  Its acquire
counter is increased to 1.  */
pdf_obj_acquire (obj);

/* Remove a strong reference for the object in `doc'.  Its acquire
   counter is decreased to 0.  */
pdf_obj_release (obj);
@end example
@end table
@end deftypefun

@node Compressibility of Objects
@subsection Compressibility of Objects

A PDF object is compressible if any of the following conditions are
true:

@itemize @minus
@item It is an indirect object.
@item It has a generation number of zero.
@item It is not a stream.
@item It has not been explicitly marked as incompressible with @code{pdf_obj_set_compressibility}.
@end itemize

A compressible object is suitable to be contained in an object
collection.  @xref{Object Collections}.

@deftypefun pdf_bool_t pdf_obj_get_compressibility (pdf_obj_t @var{obj})

Test if a given PDF object @var{obj} is compressible. Only
compressible objects can be added to an object collection.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The object is compressible.
@item PDF_FALSE
The object is not compressible.
@end table
@item Usage example
@example
pdf_obj_t obj;

...

/* Check the compressibility of a PDF object */
if (pdf_obj_get_compressibility (obj))
@{
   /* The object 'obj' is compressible. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_set_compressibility (pdf_obj_t @var{obj}, pdf_bool_t @var{compressible_p})

Set the compressibility attribute of the PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@item compressible_p
A boolean value.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The compressibility of @var{obj} was set according to
@var{compressible_p}.
@item PDF_EINVOBJ
@var{obj} cannot be compressed.
@item PDF_ERROR
Some error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_t obj;

...

/* Set the compressibility of 'obj' to true */
pdf_obj_set_compressibility (obj, PDF_TRUE);

/* Set it back to false */
pdf_obj_set_compressibility (obj, PDF_FALSE);
@end example
@end table
@end deftypefun

@node Object Collections
@subsection Object Collections

Sometimes a group of objects are related in a way they acquire
``locality'', meaning that if one of those objects is read it is very
likely that the other objects will be read as well.  An example is the
collection of objects containing the contents of a page: you need to
read them all to render the page.

It is possible to pack several PDF objects in a compressed stream in
the object document on disk.  An @dfn{object collection} can be
translated into one or several of such compressed streams.

An object can be declared as part of one (and just one) object
collection.  Only compressible objects can be added to a collection.

@deftypefun pdf_status_t pdf_obj_col_new (pdf_obj_doc_t @var{doc}, pdf_obj_col_t *@var{col})

Create a new object collection in the specified object document @var{doc}.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item col
A pointer to a @var{pdf_obj_col_t} variable that will contain the new
object collection.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object collection was created and a reference to it was stored in
@var{col}.
@item PDF_ERROR
An error prevented the operation to complete.  The value of @var{col}
is undefined and shall not be used.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_col_t col1;
pdf_obj_col_t col2;

...

/* Create some object collections */
pdf_obj_col_new (doc, &col1);
pdf_obj_col_new (doc, &col2);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_col_enum (pdf_obj_col_t @var{col}, pdf_obj_enum_fn_t @var{enum_cb}, void *@var{client_data})

Enumerate all the PDF objects contained in the given object collection
@var{col}.

@table @strong
@item Parameters
@table @var
@item col
An object collection.
@item enum_cb
The callback function.
@item client_data
Pointer passed to the callback function.
@end table
@item Returns
A PDF status value, that is the AND logical value of the values
returned by the enumeration procedure, considering @code{PDF_OK} as
true and @code{<> PDF_OK} as false.
@item Usage example
@example
/* Callback function */
pdf_bool_t
my_enum_callback (pdf_obj_t obj,
                  pdf_obj_t value,
                  void *client_data)
@{
   /* Process the callback... */
@}

...

/* Perform an enumeration of the objects contained in some object
   collection 'col'. */
if (pdf_obj_col_enum (col, my_enum_callback, NULL)
    == PDF_OK)
@{
   /* All the calls to 'my_enum_callback' returned PDF_OK */
@}
else
@{
   /* Some call to 'my_enum_callback' returned <> PDF_OK */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_col_equal_p (pdf_obj_col_t @var{col1}, pdf_obj_col_t @var{col2})

Test whether two PDF object collections are the same collection.

@table @strong
@item Parameters
@table @var
@item col1
The first collection to compare.
@item col2
The second collection to compare.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The collections are the same.
@item PDF_FALSE
The collections are not the same.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_col_t col1;
pdf_obj_col_t col2;

...

/* Create two object collections and compare them */
pdf_obj_col_new (doc, &col1);
pdf_obj_col_new (doc, &col2);

pdf_obj_col_equal_p (col1, col2); /* Returns PDF_FALSE */
pdf_obj_col_equal_p (col1, col1); /* Returns PDF_TRUE */
@end example
@end table
@end deftypefun

@deftypefun pdf_u32_t pdf_obj_col_size (pdf_obj_col_t @var{col})

Get the number of PDF objects contained in the object collection
@var{col}.

@table @strong
@item Parameters
@table @var
@item col
An object collection.
@end table
@item Returns
The number of objects contained in @var{col}.
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_col_t col;
pdf_obj_t obj1;
pdf_obj_t obj2;

...

/* Create an object collection and put some objects in it. */
pdf_obj_col_new (doc, &col);
pdf_obj_col_add_obj (objcol, obj1);
pdf_obj_col_add_obj (objcol, obj2);

/* Get the number of objects */
pdf_obj_col_size (objcol);  /* Should return 2 */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_col_add_obj (pdf_obj_col_t @var{col}, pdf_obj_t @var{obj})

Add an object @var{obj} to a collection @var{col}. The given object
should be compressible.

This operation sets the dirty flag of the document containing the
object collection.

@table @strong
@item Parameters
@table @var
@item col
An object collection.
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object @var{obj} was successfully added into the object collection
@var{col}.
@item PDF_EINVOBJ
The object @var{obj} is not compressible.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_col_t col;
pdf_obj_t obj;

...

/* Add an object into an object collection */
pdf_obj_col_add_obj (col, obj);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_col_remove_obj (pdf_obj_t @var{obj})

Remove a given PDF object @var{obj} from its containing object
collection. If the object is not contained in an object collection
then this operation is a nop.

This operation sets the dirty flag of the document containing the
object collection.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object was successfully dissociated from any containing object
collection.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_col_t col;

...

pdf_obj_col_add_obj (col, obj);

/* After the next sentence 'obj' won't be associated with 'col'
   anymore */
pdf_obj_col_remove_obj (obj);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_get_col (pdf_obj_t @var{obj}, pdf_obj_col_t *@var{col})

Get the containing object collection containing a given PDF object
@var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@item col
A pointer to a @code{pdf_obj_col_t} value containing the returned
object collection.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object collection containing @var{obj}, or @code{NULL} if there is
no one, was stored in @var{col}.
@item PDF_EINVOBJ
@var{obj} is not a compressible object.  The value in @var{col} is
undefined and shall not be used.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_col_t col;
pdf_obj_t obj;

...

pdf_obj_col_new (doc, &col);
pdf_obj_col_add_obj (col, obj);

pdf_obj_get_col (obj); /* Returns 'col' */
pdf_obj_col_remove_obj (obj);
pdf_obj_get_col (obj); /* Returns NULL */
@end example
@end table
@end deftypefun

@node Real Objects
@subsection Real Objects

PDF real objects are quantities in the real domain.  They are defined by
range and precision.  Usually represented in fixed point rather than
floating point.

@deftypefun pdf_status_t pdf_obj_real_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_real_t @var{value}, pdf_obj_t *@var{obj})

Create a new Real object in the given document @var{doc} and store
it in @var{obj}.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The initial value for the object.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A new object of type real was created in @var{doc} and stored in
@var{obj}.
@item PDF_ERROR
An error prevented the operation to complete.  The value in @var{obj}
shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t real_obj_1;
pdf_obj_t real_obj_2;

/* Create some real objects */
if (pdf_obj_real_new (doc, PDF_FALSE, 3.14, &real_obj_1)
    != PDF_OK)
@{
   /* Error creating real object */
@}

if (pdf_obj_real_new (doc, PDF_FALSE, 2.7182, &real_obj_2)
    != PDF_OK)
@{
   /* Error creating real object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_real_value (pdf_obj_t @var{obj}, pdf_real_t *@var{value})

Get the value of a PDF Real object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@item value
A pointer to a @var{pdf_real_t} variable to store the result.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The real value stored in @var{obj} was successfully stored in
@var{value}.
@item PDF_EINVOBJ
The object @var{obj} is not a Real object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{value} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t real_obj;
pdf_real_t result;

if (pdf_obj_real_new (doc, PDF_FALSE, 3.14, &real_obj)
    != PDF_OK)
@{
   /* Error creating Real object */
@}
else
@{
   if (pdf_obj_real_value (real_obj, &result)
       != PDF_OK)
   @{
      /* Error getting the Real value */
   @}
   else
   @{
      /* result equals to 3.14 */
   @}
@}
@end example
@end table
@end deftypefun

@node Integer Objects
@subsection Integer Objects

The PDF integer objects are quantities in the integer domain.  They
are limited by an implementation limit (@pxref{Implementation
Limits}).

@deftypefun pdf_status_t pdf_obj_integer_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_i32_t @var{value}, pdf_obj_t *@var{obj})

Create a new Integer object in the given document @var{doc} and store
it in @var{obj}.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The initial value for the object.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A new integer object was successfully created in @var{doc} and stored
in @var{obj}.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{obj} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t integer_obj_1;
pdf_obj_t integer_obj_2;

/* Create some integer objects */
if (pdf_obj_integer_new (doc, PDF_FALSE, 10, &integer_obj_1)
    != PDF_OK)
@{
   /* Error creating integer object */
@}

if (pdf_obj_integer_new (doc, PDF_FALSE, -10, &integer_obj_2)
    != PDF_OK)
@{
   /* Error creating integer object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_integer_value (pdf_obj_t @var{obj}, pdf_i32_t *@var{value})

Get the value of a PDF Integer object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@item value
A pointer to a @var{pdf_i32_t} variable to store the result.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The integer value of @var{obj} was stored in @var{value}.
@item PDF_EINVOBJ
The object @var{obj} is not an Integer object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{value} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t integer_obj;
pdf_i32_t result;

if (pdf_obj_integer_new (doc, PDF_FALSE, 10, &integer_obj)
    != PDF_OK)
@{
   /* Error creating Integer object */
@}
else
@{
   if (pdf_obj_integer_value (integer_obj, &result)
       != PDF_OK)
   @{
      /* Error getting the Integer value */
   @}
   else
   @{
      /* result equals to 10 */
   @}
@}
@end example
@end table
@end deftypefun

@node Boolean Objects
@subsection Boolean Objects

Boolean objects can hold just two values:

@itemize @minus
@item @code{true}
@item @code{false}
@end itemize

Can be used as values of array elements, values of dictionary entries
and as operators in the postscript calculator functions (type 4
functions).

@deftypefun pdf_status_t pdf_obj_boolean_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_bool_t @var{value}, pdf_obj_t *@var{obj})

Create a new Boolean object in the given document @var{doc} and store it
in @var{obj}.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The initial value for the object.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A new boolean object was created in @var{doc} and stored in @var{obj}.
@item PDF_ERROR
An error prevented the operation to complete.  The value in @var{obj}
shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t boolean_obj_1;
pdf_obj_t boolean_obj_2;

/* Create some Boolean objects */
if (pdf_obj_boolean_new (doc, PDF_FALSE, PDF_TRUE, &boolean_obj_1)
    != PDF_OK)
@{
   /* Error creating boolean object */
@}

if (pdf_obj_boolean_new (doc, PDF_FALSE, PDF_FALSE, &boolean_obj_2)
    != PDF_OK)
@{
   /* Error creating boolean object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_boolean_value (pdf_obj_t @var{obj}, pdf_bool_t *@var{value})

Get the value of a PDF boolean object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@item value
A pointer to a @var{pdf_bool_t} variable to store the result.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The boolean value of @var{obj} was successfully stored in
@var{value}.
@item PDF_EINVOBJ
The object @var{obj} is not a boolean object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{value} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t boolean_obj;
pdf_bool_t result;

if (pdf_obj_boolean_new (doc, PDF_FALSE, PDF_TRUE, &boolean_obj)
    != PDF_OK)
@{
   /* Error creating Boolean object */
@}
else
@{
   if (pdf_obj_boolean_value (boolean_obj, &result)
       != PDF_OK)
   @{
      /* Error getting the Boolean value */
   @}
   else
   @{
      /* result equals to PDF_TRUE */
   @}
@}
@end example
@end table
@end deftypefun

@node Name Objects
@subsection Name Objects

A PDF name object is an atomic symbol uniquely defined by a sequence
of regular characters.  It does not have internal structure.

@deftypefun pdf_status_t pdf_obj_name_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_char_t *@var{value}, pdf_obj_t *@var{obj})

Create a new Name object in the given document @var{doc} and store it
in @var{obj}.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The null-terminated string value for the object.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A new name object was successfully created in @var{doc} and stored in
@var{obj}.
@item PDF_EBADDATA
Invalid value in @var{value}.
@item PDF_ERROR
An error prevented the operation to complete.  The value in @var{doc}
shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t name_obj_1;
pdf_obj_t name_obj_2;

/* Create some Name objects */
if (pdf_obj_name_new (doc, PDF_FALSE, "FooBar", &name_obj_1)
    != PDF_OK)
@{
   /* Error creating name object */
@}

if (pdf_obj_name_new (doc, PDF_FALSE, "BazFoo", &name_obj_2)
    != PDF_OK)
@{
   /* Error creating name object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_name_size (pdf_obj_t @var{obj}, pdf_size_t *@var{size})

Return the size of the PDF name @var{obj} (i.e. the number of
characters composing it).

Note that the initial slash character (@code{/}) is not included in
the count.

The size of the @code{/} name (without any character after the slash)
is @code{0}.
@table @strong
@item Parameters
@table @var
@item obj
A PDF name object.
@item size
A pointer to a @var{pdf_size_t} variable to hold the size of
@var{obj} in octects.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The size of @var{obj} was stored in @var{size}.
@item PDF_EINVOBJ
@var{obj} is not a name object.  The value in @var{size} is
unchenged.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{size} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t name;

...


pdf_obj_name_new (doc, PDF_FALSE, "Foo", &name);
pdf_obj_name_size (name); /* Should return 3 */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_name_value (pdf_obj_t @var{obj}, pdf_char_t *@var{buf})

Get the value of a PDF Name object in the buffer pointed by
@var{buf}.  There should be enough space in @var{buf} to hold the
value (the user can get the size of the name object using
@code{pdf_obj_name_size}).

The value of the name object does not include the ``/'' prefix.

@table @strong
@item Parameters
@table @var
@item obj
A PDF name object.
@item buf
A memory buffer to store the result.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The string representing the name value of @var{obj} was successfully
stored in @var{value}.
@item PDF_EINVOBJ
The object @var{obj} is not a name object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{buf} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t name_obj;
pdf_char_t *name;

if (pdf_obj_name_new (doc, PDF_FALSE, "FooBar", &name_obj)
    != PDF_OK)
@{
   /* Error creating Name object */
@}
else
@{
   name = malloc (pdf_obj_name_size (name_obj));

   if (pdf_obj_name_value (name_obj, name)
       != PDF_OK)
   @{
      /* Error getting the Name value */
   @}
   else
   @{
      /* 'name' equals to "FooBar" */
   @}
@}
@end example
@end table
@end deftypefun

@node String Objects
@subsection String Objects

A PDF string object is a sequence of bytes in the range @code{0-255}.
They are not @code{NULL}-terminated.

@deftypefun pdf_status_t pdf_obj_string_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_char_t *@var{str}, pdf_size_t @var{str_size}, pdf_obj_t *@var{obj})

Create a new String object in the given document @var{doc} and store it
in @var{obj}.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item str
The string value. Note that this is not a @code{NULL} terminated
string, since PDF strings can held arbitrary binary data. The data
pointed by @var{str} is copied internally.
@item str_size
The size of @var{str}, in bytes.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A new string object was successfully created in @var{doc} and stored
in @var{obj}.
@item PDF_ERROR
An error prevented the operation to complete.  The value in @var{obj}
shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t str;

/* Create a new String PDF object */
if (pdf_obj_string_new (doc, PDF_FALSE, "f\233o", 3, &str)
    != PDF_OK)
@{
   /* Error creating the String object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_string_size (pdf_obj_t @var{obj}, pdf_size_t *@var{size})

Return the size of the PDF string @var{obj} (i.e. the number of
octects composing it).

@table @strong
@item Parameters
@table @var
@item obj
A PDF string object.
@item size
A pointer to a @var{pdf_size_t} variable to hold the size of
@var{obj}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The size of @var{obj} in octects was stored in @var{size}.
@item PDF_EINVOBJ
@var{obj} is not a string object.
@item PDF_ERROR
An error prevented the operation to complete.  The value in @var{size}
is undefined and shall not be used.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t str_obj;

...

pdf_obj_string_new (doc, PDF_FALSE, "foo", 3, &str_obj);
pdf_obj_string_size (str_obj); /* Returns 3 */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_string_value (pdf_obj_t @var{obj}, pdf_char_t *@var{buf})

Get the value of a PDF String object in the buffer pointed by
@var{buf}.  There should be enough space in @var{buf} to hold the
value (the user can get the size of the string using
@code{pdf_obj_string_size}).

@table @strong
@item Parameters
@table @var
@item obj
A PDF string object.
@item buf
A memory buffer to store the result.
@item
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The value of the string object was successfully stored in @var{buf}.
@item PDF_EINVOBJ
The object @var{obj} is not a String object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{buf} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t str_obj;
pdf_char_t *str;

if (pdf_obj_string_new (doc, PDF_FALSE, "foo bar baz", 11, &name_obj)
    != PDF_OK)
@{
   /* Error creating the String object */
@}
else
@{
   str = malloc (pdf_obj_string_size (str_obj));

   if (pdf_obj_string_value (str_obj, str)
       != PDF_OK)
   @{
      /* Error getting the String value */
   @}
   else
   @{
      /* 'str' contains "foo bar baz" */
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_string_hex_p (pdf_obj_t @var{obj})

Return the hex flag of the String object @var{obj}. A String object
with the hex flag set to true is saved in an hexadecimal form.

If @var{obj} is not a string object then @code{PDF_FALSE} is
returned.

@table @strong
@item Parameters
@table @var
@item obj
A PDF String object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The string will be saved in hexadecimal form.
@item PDF_FALSE
The string won't be saved in hexadecimal form.
@end table
@item Usage example
@example
pdf_obj_t str;

if (pdf_obj_string_hex_p (str))
@{
   /* The hex flag of 'str' is set */
@}
else
@{
   /* The hex flag of 'str' is not set */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_string_hex_set (pdf_obj_t @var{obj}, pdf_bool_t @var{hex_p})

Set the hex flag of the String object @var{obj}. A String object
with the hex flag set to true is saved in an hexadecimal form.

@table @strong
@item Parameters
@table @var
@item obj
A PDF String object.
@item hex_p
The new value of the hex flag for @var{obj}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The hex flag of @var{obj} was set to @var{hex_p}.
@item PDF_EINVOBJ
@var{obj} is not a string object.
@item PDF_ERROR
An error prevented the operation to complete.  The hex flag of the
document shall be considered unchanged.
@end table
@item Usage example
@example
pdf_obj_t str;

/* Reverse the hex flag of 'str' */
pdf_obj_string_hex_set (!pdf_obj_string_hex_p (str));
@end example
@end table
@end deftypefun

@node Array Objects
@subsection Array Objects

A PDF array is a one-dimensional collection of objects arranged
sequentially.  The objects can be of any type.

@deftypefun pdf_status_t pdf_obj_array_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_size_t @var{array_size}, pdf_obj_t *@var{obj})

Create a new Array object in the given object document @var{doc} and
store it in @var{obj}.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item array_size
The number of elements of the new array.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The array object was created and stored into @var{obj}.
@item PDF_ENOMEM
Not enough memory.  The value of @var{obj} shall be considered
invalid.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{obj} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t array;

...

/* Create an indirect array object to initially
   held 10 elements */
if (pdf_obj_array_new (doc, PDF_TRUE, 10, &array)
    == PDF_OK)
@{
   /* The object was successfully created */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_get (pdf_obj_t @var{array}, pdf_size_t @var{index}, pdf_obj_t *@var{obj})

Get the @var{index}th element of the given array and store it into
@var{obj}.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into the array.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the result.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The @var{index}th object was stored into @var{obj}.
@item PDF_EBADDATA
The specified @var{index} is invalid.  The value of @var{obj} is
untouched.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{obj} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_obj_t elem;
pdf_size_t index;

...

/* Iterate through the first 5 objects of 'array' */
for (index = 0; index < 5; index++)
@{
   if (pdf_obj_array_get (array, index, &elem)
       == PDF_OK)
   @{
      /* Use 'elem' */
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_set (pdf_obj_t @var{array}, pdf_size_t @var{index}, pdf_obj_t @var{obj})

Set the @var{index}th element of the array to the given object
@var{obj}.  The object @var{obj} and the array @var{array} should be
associated with the same object document.  A non-scalar direct object
cannot be inserted in more than one container.

If @var{index} equals to the array size then the object is inserted at
the end.

The previous object occupying the @var{index}th position is no longer
referenced by the array.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into the array.
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The element was inserted at the specified position.
@item PDF_EINVOBJ
The object @var{obj} is a non-scalar direct object already contained
in another object or the object belongs to other document.
@item PDF_EBADDATA
The specified @var{index} is invalid.
@item PDF_ERROR
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t array;
pdf_obj_t elem;
pdf_size_t index;

...

/* Insert numbers as the first 10 elements of the array */
for (index = 0; index < 10; index++)
@{
   pdf_obj_integer_new (doc,
                        PDF_FALSE,
                        (pdf_u32_t) index,
                        &elem);

   if (pdf_obj_array_set (array, index, elem) == PDF_OK)
   @{
      /* Element inserted into the array. */
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_size (pdf_obj_t @var{array}, pdf_size_t *@var{size})

Get the number of elements contained in @var{array}.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item size
A pointer to a PDF size variable to hold the number of objects
contained in @var{array}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The size of @var{array} was stored in @var{size}.
@item PDF_EINVOBJ
@var{array} is not an array object.  The value in @var{size} is left
untouched.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{size} is undefined.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_size_t array_size;
pdf_size_t index;

...

/* Iterate through the element of the array */
pdf_obj_array_size (array, &array_size);
for (index = 0; index < array_size; index++)
@{
   /* Do something */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_array_weak_p (pdf_obj_t @var{array}, pdf_size_t @var{index})

Determine if the @var{index}th element of @var{array} is a weak
reference.

A weak reference changes the way the garbage collection works.
@xref{Garbage collection in object documents}.

This function returns @code{PDF_FALSE} if @var{array} is not an array
object and if @var{index} is out of bounds.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into @var{array}.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The element at @var{index} is a weak reference.
@item PDF_FALSE
The element at @var{index} is not a weak reference.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_size_t index;
pdf_size_t array_size;

...

/* Determine if some element of array has a weak reference */
pdf_obj_array_size (array, &array_size);
for (index = 0; index < array_size; index++)
@{
   if (pdf_obj_array_weak_p (array, index))
   @{
      /* The index-th element has a weak reference */
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_array_weak_set (pdf_obj_t @var{array}, pdf_size_t @var{index}, pdf_bool_t @var{weak_p})

Set if the @var{index}th element of @var{array} is a weak reference.

The effect of this call when @var{weak_p} is @code{PDF_FALSE} is to
remove the effect of a previous call with @var{weak_p} set to
@code{PDF_TRUE}.  In particular it does not set a strong reference to
the object occupying the @var{index}th position in the array.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into @var{array}.
@item weak_p
A boolean value.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The weak reference was (un)set in the element occupying the
@var{index}th position into @var{array}.
@item PDF_EINVOBJ
@var{array} is not an array object.
@item PDF_EBADDATA
The specified @var{index} is out of bounds.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_size_t index;
pdf_size_t array_size;

...

/* Remove any weak reference in 'array' */
pdf_obj_array_size (array, &array_size);
for (index = 0; index < array_size; index++)
@{
   pdf_obj_array_weak_set (array, index, PDF_FALSE);
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_remove (pdf_obj_t @var{array}, pdf_obj_t @var{obj})

Find the first element equal to @var{obj} and remove it from the
array.

Note that it is not safe to call @code{pdf_obj_array_remove} while
executing a @code{pdf_obj_enum}.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item obj
The PDF object to remove from the array.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
@var{obj} was found and removed from the array.
@item PDF_EINVOBJ
@var{array} is not an array object.
@item PDF_EBADDATA
@var{obj} was not contained in the array.
@item PDF_ERROR
Some error prevented to complete the operation.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_obj_t elem;

...

/* Remove the third element of the array */
pdf_obj_array_get (array, 2, &elem);
if (pdf_obj_array_remove (array, elem) == PDF_OK)
@{
   /* The element was removed from the array */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_remove_at (pdf_obj_t @var{array}, pdf_size_t @var{index})

Find the @var{index}th element and remove it from the array.

Note that it not safe to call @code{pdf_obj_array_remove_at} while
executing a @code{pdf_obj_enum}.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
The index of the element to remove from the array.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The requested element was found and removed from the array.
@item PDF_EINVOBJ
@var{array} is not an array object.
@item PDF_EBADDATA
The specified @var{index} is invalid.
@item PDF_ERROR
Some error prevented to complete the operation.
@end table
@item Usage example
@example
pdf_obj_t array;

...

/* Remove the third element of the array */
if (pdf_obj_array_remove_at (array, 3) == PDF_OK)
@{
   /* The element was removed */
@}
@end example
@end table
@end deftypefun

@node Dictionary Objects
@subsection Dictionary Objects

A PDF dictionary is an associative table containing pairs of objects.
The first object of each pair is a name object.  The type of the
second object in the pair is unrestricted.

A dictionary entry whose value is null is equivalent to an absent
entry.

@deftypefun pdf_status_t pdf_obj_dict_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_obj_t *@var{obj})

Create a new PDF Dictionary object.

@table @strong
@table @var
@item doc
An object document.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
An empty dictionary object was created and stored in @var{obj}.
@item PDF_ENOMEM
Not enough memory to create the object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{obj} shall be considered undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;

...

/* Create an empty dictionary object */
if (pdf_obj_dict_new (doc, PDF_TRUE, &dict)
    == PDF_OK)
@{
   /* Dictionary object created and stored in 'dict'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_get (pdf_obj_t @var{dict}, pdf_obj_t @var{key}, pdf_obj_t *@var{obj})

Get the value associated with @var{key} in @var{dict} and store it in
@var{obj}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@item obj
A pointer to @code{pdf_obj_t} to store the value associated with
@var{key}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A copy of the value associated with @var{key} was stored in @var{obj}.
@item PDF_EINVOBJ
@var{key} is not a name object or @var{dict} is not a dictionary
object.
@item PDF_EBADDATA
@var{key} is not in the dictionary or it is not a name object.
@item PDF_ERROR
An error prevented the operation to complete.  The value in @var{obj}
shall be considered undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t key;
pdf_obj_t value;

...

/* Get the value associated with "/Foo" */
pdf_obj_name_new (doc, PDF_FALSE, "Foo", &key);
if (pdf_obj_dict_get (dict, key, &value) == PDF_OK)
@{
   /* The object associated with "/Foo" in the dictionary is
      now in 'foo'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_get_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key}, pdf_obj_t *@var{obj})

Get the value associated with @var{key} in @var{dict} and store it in
@var{obj}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A string containing the name of the key, without the preceding slash
character.
@item obj
A pointer to @code{pdf_obj_t} to store the value associated with
@var{key}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A copy of the value associated with @var{key} was stored in @var{obj}.
@item PDF_EBADDATA
@var{key} is not in the dictionary.
@item PDF_ERROR
An error prevented the operation to complete.  The value in @var{obj}
shall be considered undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t value;

...

/* Get the value associated with "/Foo" */
if (pdf_obj_dict_get (dict, "Foo", &value) == PDF_OK)
@{
   /* The object associated with "/Foo" in the dictionary is
      now in 'foo'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_set (pdf_obj_t @var{dict}, pdf_obj_t @var{key}, pdf_obj_t @var{val})

Set @var{val} as the new value for @var{key} in the PDF dictionary
@var{dict}.

If the entry do not exist then it is added.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@item val
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The value associated with @var{key} in @var{dict} was set to
@var{val}.
@item PDF_EINVOBJ
@var{key} is not a name object or @var{dict} is not a
dictionary object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{val} is undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t key;
pdf_obj_t value;

...

/* Create a dictionary and insert a key-value pair
   into it: /Age -> 29. */
pdf_obj_dict_new (doc, PDF_TRUE, &dict);

pdf_obj_name_new (doc, PDF_FALSE, "Age", &key);
pdf_obj_integer_new (doc, PDF_FALSE, 29, &value);

if (pdf_obj_dict_set (dict, key, value) == PDF_OK)
@{
   /* The pair key-value was inserted in 'dict'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_set_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key}, pdf_obj_t @var{val})

Set @var{val} as the new value for @var{key} in the PDF dictionary
@var{dict}.

If the entry do not exist then it is added.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A string containing the name of the key, without the preceding slash
character.
@item val
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The value associated with @var{key} in @var{dict} was set to
@item PDF_EINVOBJ
@var{dict} is not a dictionary object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{val} is undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t root_dict;
pdf_obj_t pages_dict;

...

/* Create a /Pages entry in the root dictionary, as an indirect
   object, containing an empty dictionary. */
pdf_obj_doc_get_root (doc, &root_dir);
pdf_obj_dict_new (doc, PDF_TRUE, &pages_dict);

if (pdf_obj_dict_set_str (root_dir, "/Pages", pages_dict)
    != PDF_ERROR)
@{
   /* The root dictionary now contains a /Pages entry
      whose value is an object reference pointing to the
      indirect dictionary 'pages'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_remove (pdf_obj_t @var{dict}, pdf_obj_t @var{key})

Remove a key-value pair from a dictionary. If @var{key} is not found
in @var{dict} then this is a no-op.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
@var{key} was found in the dictionary and the pair was removed.
@item PDF_EINVOBJ
Either @var{dict} is not a dictionary object or @var{key} is not a
name object.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Remove the "/Foo" entry from 'dict', if it exists */
pdf_obj_name_new (doc, PDF_FALSE, "Foo", &key);

if (pdf_obj_dict_remove (dict, key) == PDF_OK)
@{
   /* The entry, provided it was present, was removed from
      the dictionary. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_remove_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key})

Remove a key-value pair from a dictionary. If @var{key} is not found
in @var{dict} then this is a no-op.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A string containing the textual representation of a PDF Name.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
@var{key} was found in the dictionary and the pair was removed.
@item PDF_EINVOBJ
@var{dict} is not a dictionary object.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;

...

/* Remove the "/Foo" entry from 'dict', if it exists */
if (pdf_obj_dict_remove (dict, "Foo") == PDF_OK)
@{
   /* The entry, provided it was present, was removed from
      the dictionary. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_key_p (pdf_obj_t @var{dict}, pdf_obj_t @var{key})

Determine if a given name object is a key into @var{dict}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A PDF Name object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a key-value pair into @var{dict}.
@item PDF_FALSE
@var{key} is not in a key-value pair into @var{dict}, or @var{dict}
is not a dictionary object, or @var{key} is not a name object.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t key;
pdf_obj_t value;

...

pdf_obj_integer_new (doc, PDF_FALSE, 10, &value);
pdf_obj_dict_set_str (dict, "Foo", value);

pdf_obj_dict_key_str_p (dict, "Foo", value); /* Returns PDF_TRUE */
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_key_str_p (pdf_obj_t @var{dict}, pdf_char_t *@var{key})

Determine if a given @var{key} string is a key into @var{dict}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A string containing the string representation of a PDF Name.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a key-value pair into @var{dict}.
@item PDF_FALSE
@var{key} is not in a key-value pair into @var{dict}, or @var{dict} is
not a dictionary object.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t value;

...

pdf_obj_integer_new (doc, PDF_FALSE, 10, &value);

pdf_obj_dict_set_str (dict, "Foo", value);

pdf_obj_dict_key_p (dict, key, value); /* Returns PDF_TRUE */
pdf_obj_dict_key_p (dict, value, key); /* Returns PDF_FALSE */
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_weak_p (pdf_obj_t @var{dict}, pdf_obj_t @var{key})

Determine if a given @var{key} object is a weak reference in @var{dict}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A PDF Name object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a weak reference into @var{dict}.
@item PDF_FALSE
@var{key} is not a weak reference into @var{dict}, or @var{key} does
not exist in the dictionary, or @var{dict} is not a dictionary object,
or @var{key} is not a name object.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Determine if the entry "/Foo" has a weak reference in 'dict' */
pdf_obj_name_new (doc, PDF_FALSE, "Foo", &key);

pdf_obj_dict_weak_p (dict, key);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_weak_str_p (pdf_obj_t @var{dict}, pdf_char_t *@var{key})

Determine if a given @var{key} object is a weak reference in @var{dict}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A string containing the string representation of a PDF Name.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a weak reference into @var{dict}.
@item PDF_FALSE
@var{key} is not a weak reference into @var{dict}, or @var{key} does
not exist in the dictionary, or @var{dict} is not a dictionary object.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Determine if the entry "/Foo" has a weak reference in 'dict' */
pdf_obj_dict_weak_p (dict, "Foo");
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_weak_set (pdf_obj_t @var{dict}, pdf_obj_t @var{key}, pdf_bool_t @var{weak_p})

Set the @var{weak_p} attribute of @var{key} in @var{dict}.  Any
key-value pair with @code{weak_p == PDF_TRUE} has a weak reference.
@xref{Garbage collection in object documents}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@item weak_p
The new value for the weak attribute of the key-value pair.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The weak attribute for the pair was set to @var{weak_p}.
@item PDF_EINVOBJ
Either @var{dict} is not a PDF dictionary object or @var{key} is not a
PDF name object.
@item PDF_ERROR
Some error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Set the weak attribute of the key-value pair in
   'dict' with key "/Foo". */
pdf_obj_name_new (doc, PDF_FALSE, "Foo", &key);

pdf_obj_dict_weak_set (dict, key, PDF_TRUE);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_weak_set_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key}, pdf_bool_t @var{weak_p})

Set the @var{weak_p} attribute of @var{key} in @var{dict}. Any
key-value pair with @code{weak_p == PDF_TRUE} has a weak reference.
@xref{Garbage collection in object documents}.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A string containing the string representation of a PDF name.
@item weak_p
The new value for the weak attribute of the key.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The weak attribute for the pair was set to @var{weak_p}.
@item PDF_EINVOBJ
@var{dict} is not a PDF dictionary object.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;

...

/* Set the weak attribute of the key-value pair in
   'dict' with key "/Foo". */
pdf_obj_dict_weak_set (dict, "Foo", PDF_TRUE);
@end example
@end table
@end deftypefun

@node Stream Objects
@subsection Stream Objects

A PDF stream object is an arbitrary long sequence of bytes
characterized by a set of properties.  The properties of a stream
object are specified by a dictionary that appears just before the
stream in the PDF file.

Unlike strings, a stream can be read incrementally and can be of
unlimited length.

All streams must be indirect objects while the dictionary describing
the stream must be a direct object.

@deftypefun pdf_status_t pdf_obj_stream_new (pdf_obj_doc_t @var{doc}, pdf_stm_t @var{stm}, pdf_size_t @var{size}, pdf_obj_t @var{attrs_dict}, pdf_obj_t *@var{obj})

Create a new PDF Stream object.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item stm
A base layer stream that will be used to retrieve the data for the
stream object. @xref{Filtered Streams}.  The contents of this stream
will be copied to an internal storage by this call.
@item size
The number of octects to read from @var{stm}.  If this parameter is
zero then read from the stream until it gets exhausted.
@item attrs_dict
Dictionary containing keys that will be copied to the dictionary
describing the newly created stream. If this dictionary
contains a list of filters then those filters are applied in inverse
order to the data read from @var{stm}.

Note that any @code{/Length} key present in @var{stm} will be ignored.

See the PDF specification for the expected content of the stream
dictionary.
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The stream object was successfully created, and a reference to it was
stored in @var{obj}.
@item PDF_EINVOBJ
@var{stm} is not a stream object or @var{attr_dict} is not a
dictionary object.
@item PDF_ENOMEM
Not enough memory to create the object.
@item PDF_ERROR
Some error prevented the creation of the stream object.  The reference
stored @var{obj} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t dict;
pdf_obj_t stream;
pdf_obj_t filter_array;
pdf_string_t data_file_path;
pdf_fsys_file_t data_file;
pdf_stm_t stm;

...

/* Create a filter array */
pdf_obj_string_new (doc, PDF_FALSE, "ASCII85Decode");
pdf_obj_string_new (doc, PDF_FALSE, "LZWDecode");

pdf_obj_array_new (doc, PDF_FALSE, 2, &filter_array);
pdf_obj_array_set (filter_array, 0, ascii85_label);
pdf_obj_array_set (filter_array, 1, lzw_label);

/* Create the dictionary */
pdf_obj_dict_new (doc, PDF_FALSE, &dict);
pdf_obj_dict_set_str (dict, "Filter", filter_array);

/* Open a filtered stream to a file containing the data to be
   stored in the object stream */
pdf_text_new_from_unicode ("/path/to/data",
                           14, PDF_TEXT_UTF8,
                           &data_file_path);
pdf_fsys_file_open (NULL, data_file_path, PDF_FSYS_OPEN_MODE_READ, data_file);
pdf_stm_file_new (data_file,
                  0,
                  0, /* Use the default cache size */
                  PDF_STM_READ,
                  &stm);

/* Create the stream object */
if (pdf_obj_stream_new (doc,
                        stm,
                        0, /* Exhaust the stream */
                        dict,
                        &stream) != PDF_OK)
@{
   /* Some error prevented the creation of the stream */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_stream_dict (pdf_obj_t @var{stream}, pdf_obj_t *@var{dict})

Get the stream dictionary associated with @var{stream}.

@table @strong
@item Parameters
@table @var
@item stream
A stream object.
@item dict
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.  The returned object shall not be destroyed nor modified by
the caller.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The dictionary describing @var{stream} is now stored in @var{obj}.
@item PDF_EINVOBJ
@var{stream} is not a stream object.
@item PDF_ERROR
An error prevented the operation to complete.  The value of @var{dict}
shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_t stream;
pdf_obj_t stream_dict;

/* Create a stream object... */

if (pdf_obj_stream_dict (stream, &stream_dict) != PDF_OK)
@{
   /* Error getting the stream dictionary */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_stream_length (pdf_obj_t @var{stream}, pdf_off_t *@var{length})

Get the size of the encoded stream in octects.

@table @strong
@item Parameters
@table @var
@item stream
A stream object.
@item length
A pointer to a @var{pdf_size_t} variable to hold the returned value.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The length of the encoded stream is stored in @var{length}.
@item PDF_EINVOBJ
@var{stream} is not a stream object.
@item PDF_ERROR
An error prevented the operation to complete.  The value of
@var{length} shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_t stream;
pdf_off_t stream_length;

...

/* Get the length of the stream, in octects */
pdf_obj_stream_length (stream, &stream_length);
@end example
@end table
@end deftypefun

@deftypefun pdf_off_t pdf_obj_stream_pos (pdf_obj_t @var{stream})

Get the offset of the beginning of @var{stream}'s data in the PDF
file.

You can use this call only after saving the object in a PDF file.

@table @strong
@item Parameters
@table @var
@item stream
A Stream object.
@end table
@item Returns
The offset (in octects) of the beginning of the stream data: the
position just after the @code{stream} keyword.  If the returned number
is @code{0} then an error occurred.
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t stream;
pdf_off_t stream_offset;

...

/* Try to get the offset without previously
   saving the object document */
if (stream_offset (stream) == 0)
@{
   /* Error: document was not saved before to
      call pdf_obj_stream_pos */
@}

/* Save the object document */
pdf_obj_doc_save (doc, NULL, PDF_OBJ_DOC_SAVE_FULL, save_params);

/* Get the offset where the data of the stream was
   stored */
if (stream_offset (stream) == 0)
@{
   /* Error obtaining the offset of the stream */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_stream_open (pdf_obj_t @var{stream}, enum pdf_obj_stm_open_mode_e @var{mode}, pdf_stm_t *@var{stm})

Create a base layer stream to read the contents of
@var{stream}. The base layer stream @var{stm} is positioning at the
beginning of the data contained in @var{stream}.

The configuration of the filter chain in @var{stm} depends on the
opening mode in @var{mode}.

The client is responsible to close the stream @var{stm}.
@table @strong
@item Parameters
@table @var
@item stream
A Stream object.
@item mode
Mode used to open the stream. @xref{Object Data Types}.
@item stm
A pointer to a @var{pdf_stm_t} variable holding the returned base
layer stream.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A filtered stream was opened to read the contents of @var{stream}.
@item PDF_EINVOBJ
@var{stream} is not a stream object.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_ERROR
An error prevented the operation to complete.  The value of @var{stm}
shall be considered invalid.
@end table
@item Usage example
@example
pdf_obj_t stream;
pdf_stm_t stm;

...

/* Get a filtered stream to read the contents
   of 'stream' */
if (pdf_obj_stream_open (stream,
                         PDF_OBJ_STM_OPEN_MODE_FILTERED,
                         &stm) != PDF_OK)
@{
   /* Error opening the stream */
@}
@end example
@end table
@end deftypefun

@node Null Object
@subsection Null Object

A PDF null object has a type and a value that are unequal to those of
any other object.  There is only one possible value for this object
type: the @code{null} keyword.

An indirect object reference to a nonexistant object is a reference to
the null object.

@deftypefun pdf_status_t pdf_obj_null_new (pdf_obj_t *@var{obj})

Create a direct Null object.

@table @strong
@table @var
@item obj
A pointer to a @code{pdf_obj_t} variable to store the newly created
object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Object Documents
@section Object Documents

At the syntactic level any PDF document can be viewed as a collection
of objects organized in a certain way.

An object document can be associated with a file system file
(@pxref{The Filesystem Module}).

@menu
* Object Document Data Types::
* Opening and Closing Object Documents::
* Managing Object Document Properties::
* Retrieving and Storing Objects::
* Garbage collection in object documents::
@end menu

@node Object Document Data Types
@subsection Object Document Data Types

@deftp {Data Type} pdf_obj_doc_t
Opaque type representing an object level document.
@end deftp

@deftp {Data Type} {struct pdf_obj_doc_save_params_s}

Parameters used when saving an object document.

@table @code
@item pdf_char_t *header
A complete header string, like
@example
%FOO-1.0
@end example
@item pdf_char_t *crypt_key
An encryption key if the security of the document is activated.
@item pdf_size_t crypt_key_size
Size of @code{crypt_key}.
@item struct pdf_pm_s *progress_monitor
A pointer to a progress monitor, or @code{NULL}.
@item void *monitor_client_data
Client-specific data for the progress monitor callbacks.
@end table
@end deftp

@deftp {Data Type} {struct pdf_obj_doc_ctx_s}

Structure to contain a localization of an error in the contents of an
object document.

@table @code
@item pdf_off_t line
Line number.
@item pdf_char_t *error_description
Description of the error.
@end table
@end deftp

@node Opening and Closing Object Documents
@subsection Opening and Closing Object Documents

@deftypefun pdf_status_t pdf_obj_doc_new (pdf_u32_t @var{flags}, pdf_obj_doc_t *@var{doc})

Create an empty object document.

The newly created object document contains an empty root dictionary
and an optional empty Document Information Dictionary.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to a @code{pdf_obj_doc_t} variable.
@item flags
An integer value containing the ORed value of zero or more
flags. Valid flags are:
@table @code
@item PDF_OBJ_DOC_CREATE_INFO_DIR
Create an empty @dfn{Document Information Dictionary} in the object
document as an indirect dictionary.  The Info dictionary will be
referenced in the document trailer.
@end table
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object document was successfully created.
@item PDF_ERROR
Error creating the object document. The reference stored in @var{doc}
becomes invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t mydoc;

if (pdf_obj_doc_new (PDF_OBJ_DOC_CREATE_INFO_DIR,
                     &mydoc) == PDF_ERROR)
@{
   /* Error creating the object document */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_open (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path}, pdf_char_t *@var{header_string}, pdf_obj_doc_ctx_s *@var{ctx}, pdf_obj_doc_t *@var{doc})

Open a document object from a file.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem implementation. If this parameter is @code{NULL} then the
default disk filesystem is used.  @xref{The Filesystem Module}.
@item path
The path to the file containing the object document.
@item header_string
A string like @code{"%PDF-"}.  The string should appear as the first
content of the specified file.  The string can be empty.
@item ctx
Pointer to a @code{pdf_obj_doc_ctx_s} structure that will contain the
localization of an error in the document if some arises.  If it is
@code{NULL} then it won't be used.
@item doc
A pointer to a @code{pdf_obj_doc_t} variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object document was correctly loaded from @var{path} and stored in
@var{doc}.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_EBADNAME
The path specified in @var{path} is not correct.
@item PDF_EBADPERMS
The file in @var{path} could not be read due to a lack of permissions.
@item PDF_EBADFILE
Parser error while interpreting the contents of the file in
@var{path}.  Information about the location of the error can be found
in @var{ctx} if it was specified.
@item PDF_EIMPLLIMIT
Some implementation limit was exceeded.  For example, there is a limit
in the number of PDF objects that can be contained in an object
document. @xref{Implementation Limits}.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{doc} is undefined and should not be used.
@end table
@item Usage example
@example
pdf_text_t file_path;
pdf_obj_doc_t doc;

/* Open a PDF object document from /foo/bar.pdf */
pdf_text_new_from_unicode ("/foo/bar.pdf",
                           12,
                           PDF_TEXT_UTF8,
                           &file_path);

if (pdf_obj_doc_open (NULL, /* Use the default filesystem */
                      file_path,
                      "%PDF-",
                      &doc) != PDF_OK)
@{
   /* Error opening /foo/bar.pdf */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_close (pdf_obj_doc_t @var{doc})

Close an object document.

If the dirty flag of the object document is set then the contents are
saved before closing.  The performed saving operation is equivalent to
a call to @code{pdf_obj_doc_save} with @code{NULL} flags.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object document has been closed.  The value of @var{doc} should be
considered invalid and shall not be used.
@item PDF_ERROR
Error while closing the object document.  The reference in @var{doc}
should be considered invalid and shall not be used.
@end table
@item Usage example
@example
pdf_obj_doc_t mydoc;

/* Close an object document... */

if (pdf_obj_doc_close (mydoc) != PDF_OK)
@{
   /* Error closing the object document */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_save (pdf_obj_doc_t @var{doc}, pdf_fsys_file_t @var{file}, pdf_u32_t @var{flags}, struct pdf_obj_doc_save_params_s @var{params})

Save a document to a file.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item file
A fsys open file (opened for write) used to write the document data
into.

If this parameter is @code{NULL} then the file associated with
@var{doc} is used for the save operation.
@item flags
An ORed value of the following defined flags:
@table @code
@item PDF_OBJ_DOC_SAVE_DONT_CREATE_CR
Do not create a cross reference table (or stream) when saving the document.
@item PDF_OBJ_DOC_SAVE_FULL
Do a ``full save'', writing all the objects instead of just the
modified ones.  This option recreates the whole file with all the
objects with a generation number of 0.
@end table
@item params
A @code{pdf_obj_doc_save_params_s} structure containing the parameters
of the save operation.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object document was saved properly.
@item PDF_ERROR
An error prevented the document to be saved.  The value of @var{doc}
is still valid.
@end table
@item Usage example
@example
struct pdf_obj_doc_save_params_s save_params;
pdf_obj_doc_t doc;

/* Open an object document 'doc'... */

/* Fill in the save parameters */
save_params.header = "%PDF-1.6";
/* No encryption */
save_params.crypt_key = NULL;
save_params.crypt_key_size = 0;
/* Do not use a progress monitor */
save_params.progress_monitor = NULL;
save_params.monitor_client_data = NULL;

/* Save the document in its associated file */
if (pdf_obj_doc_save (doc,
                      NULL, /* Use the associated file */
                      PDF_OBJ_DOC_SAVE_FULL,
                      save_params) != PDF_OK)
@{
   /* Error saving the object document */
@}
@end example
@end table
@end deftypefun

@node Managing Object Document Properties
@subsection Managing Object Document Properties

@deftypefun pdf_status_t pdf_obj_doc_get_id (pdf_obj_doc_t @var{doc}, pdf_obj_t *@var{instance_id}, pdf_obj_t *@var{permanent_id})

Return two ID byte arrays identifying the object document.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item instance_id
A pointer to a string object to hold the returned instance id. If the
document does not have a instance id then the null object is returned.
@item permanent_id
A pointer to a string object to hold the returned permanent id. If the
document does not have a instance id then the null object is returned.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The document id was correctly stored into @var{instance_id} and
@var{permanent_id}.
@item PDF_ERROR
Some error prevented the operation to complete.  The value of
@var{instance_id} and @var{permanent_id} is undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t instance_id;
pdf_obj_t permanent_id;

/* Create an object document ... */

if (pdf_obj_doc_get_id (doc,
                        &instance_id,
                        &permanent_id) != PDF_ERROR)
@{
   if (pdf_obj_get_type (instance_id)
       != PDF_OBJ_NULL)
   @{
      /* 'instance_id' is a PDF string object containing the
         instance ID of the document */
   @}

   if (pdf_obj_get_type (permanent_id)
       != PDF_OBJ_NULL)
   @{
      /* 'permanent_id' is a PDF string object containing the
         permanent ID of the document */
   @}
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_set_id (pdf_obj_doc_t @var{doc}, pdf_obj_t @var{instance_id}, pdf_obj_t @var{permanent_id})

Set the two ID byte arrays identifying the object document @var{doc}.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item instance_id
A string object with the new instance id.
@item permanent_id
A string object with the new permanent id.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The new instance id and permanent id were set in @var{doc}.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t instance_id;
pdf_obj_t permanent_id;

/* Create an object document and instance_id, permanent_id... */

if (pdf_obj_doc_set_id (doc,
                        instance_id,
                        permanent_id) != PDF_ERROR)
@{
    /* The instance Id and permanent Id of the document were set.  */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_set_dirty (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{dirty_p})

Explicitly set the dirty flag of the object document @var{doc} to
@var{dirty_p}.

If the dirty flag of a document is set then its contents are saved
before the document is closed.  Note that if the dirty flag of the
document is cleared using this function then any modified data will be
lost upon closing.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item dirty_p
Boolean value.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The dirty flag was properly set.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_text_t file_path;
pdf_obj_t catalog;
pdf_obj_t foo_value;

/* Open an object document */
pdf_text_new_from_unicode ("/foo/bar.pdf",
                           12,
                           PDF_TEXT_UTF8,
                           &file_path);

pdf_obj_doc_open (NULL, /* Use the default filesystem */
                  file_path,
                  "%PDF-",
                  &doc);

/* Modify the object document by adding a /Foo entry to
   the catalog. This operation will set the dirty flag of
   the document. */
pdf_obj_doc_get_root (doc, &catalog);
pdf_obj_integer_new (doc, PDF_FALSE, 10, &foo_value);
pdf_obj_dict_put_str (catalog, "Foo", foo_value);

/* Clear the dirty flag of the document. */
pdf_obj_doc_set_dirty (doc, PDF_FALSE);

/* Close the document.  The /Foo entry in the catalog dictionary is
   lost, since the document is not saved. */
pdf_obj_doc_close (doc);
@end example
@end table
@end deftypefun

@node Retrieving and Storing Objects
@subsection Retrieving and Storing Objects

A PDF object document contains two special objects that can be
accessed using specific-purpose functions:

@itemize @minus
@item The @dfn{Document Information Dictionary}.  It is optional.
@item The @dfn{root object}, that is the catalog dictionary in a well-formed PDF document.  It is mandatory.
@end itemize

Any other indirect object contained in the object document can be
accessed using an object identifier.

@deftypefun pdf_status_t pdf_obj_doc_get_info_dict (pdf_obj_doc_t @var{doc}, pdf_obj_t *@var{info_dict})

Return the Document Information Dictionary of the object document.  If
the object document does not contain an info dictionary then the
@code{null} object is returned.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item info_dict
A pointer to a @code{pdf_obj_t} variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
If the object document features an Info dictionary it was stored in
@var{info_dict}.  Otherwise the @code{null} object was stored in
@var{info_dict}.
@item PDF_ERROR
Error while getting the Info dictionary of the document object.  The
value in @var{info_dict} should be considered undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t info_dict;

/* Get the Document Information Dictionary of the
   object document. */
if (pdf_obj_doc_get_info_dict (doc, &info_dict)
    != PDF_ERROR)
@{
   if (pdf_obj_get_type (info_dict) != PDF_OBJ_NULL)
   @{
      /* The info dictionary of the document is stored in
         'info_dict'. */
   @}
   else
   @{
      /* The object document does not feature an info
         dictionary. */
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_set_info_dict (pdf_obj_doc_t @var{doc}, pdf_obj_t @var{info_dict}

Set @var{info_dict} as the Document Information Dictionary of
@var{doc}.

@var{info_dict} should be an indirect dictionary object.  If it is
associated with a different document then a deep copy is performed
before to set it as the Document Information Dictionary of
@var{doc}.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item info_dict
An indirect dictionary object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The dictionary @var{info_dict} was set as the new Document Information
Dictionary of @var{doc}.
@item PDF_EINVOBJ
The specified object @var{info_dict} is not of the proper type.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t info_dict;

/* Create an object document without an info dictionary */
pdf_obj_doc_new (0, &doc);

/* Create an info dictionary */
pdf_obj_dict_new (doc, PDF_TRUE, &info_dict);

/* Set it as the new info dictionary in 'doc' */
if (pdf_obj_doc_set_info_dict (doc, info_dict)
    == PDF_OK)
@{
   /* 'info_dict' is now the Document Information Dictionary of
      'doc' */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_get_root (pdf_obj_doc_t @var{doc}, pdf_obj_t *@var{root_dict})

Get the root object (maybe the catalog of a well-formed PDF document)
of the object document @var{doc} and store it in @var{root_dict}.

@table @strong
@item Parameters
@table @code
@item doc
An object document.
@item obj
A pointer to a @code{pdf_obj_t} variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The root object has been stored in @var{root_dict}.
@item PDF_ERROR
Error while getting the root object of the document.  The value of
@var{root_dict} is invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t root_dict;

/* Get the root object of an object document */
if (pdf_obj_doc_get_root (doc, &root_dict)
    != PDF_ERROR)
@{
   /* 'root_dict' contains the root dictionary of the
      object document. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_doc_get_obj (pdf_obj_doc_t @var{doc}, pdf_obj_id_t @var{obj_id}, pdf_obj_t *@var{obj})

Get an object from @var{doc} given its @var{obj_id} and store it in
@var{obj}. Note that the object with the latest generation number in
the document is returned.

Any previous content of @var{obj} is lost.
@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item obj_id
The object identifier of the desired object.
@item obj
A pointer to a @code{pdf_obj_t} variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object was stored in @var{obj}.
@item PDF_ERROR
Error while getting the object.  The value of @var{obj} is invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t pages_dict;

/* Get the pages dictionary of 'doc' using its object id */
if (pdf_obj_doc_get_obj (doc, 5, &catalog_dir)
    != PDF_ERROR)
@{
   /* 'catalog_dir' contains the pages dictionary. */
@}
@end example
@end table
@end deftypefun

@node Garbage collection in object documents
@subsection Garbage collection in object documents

A garbage collector is provided by the library to remove non-reachable
objects from an object document.

A @dfn{non-reachable object} is an indirect object that cannot be
reached starting from the root dictionary of the object document. A
special case is the Document Information Dictionary.  If it is present
it is never collected even if it is not reachable.

The algorithm implemented by the collector is:

@enumerate
@item
Mark the Document Information Dictionary if it exists.
@item
Starting from the root dictionary, inclusive, mark any reachable
object that is not a weak reference.
@item
For every non-marked object...
@enumerate
@item
If its acquire counter is @code{1}, destroy it freeing any used
memory.  Any @code{pdf_obj_t} referencing the object becomes invalid.
@end enumerate
@end enumerate

Note that the garbage collector is never called implicitly.

@deftypefun pdf_status_t pdf_obj_doc_gc (pdf_obj_doc_t @var{doc})

Call the garbage collector on @var{doc}, removing non-reachable
non-acquired objects.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The collection was successful.
@item PDF_ERROR
An error prevented the collector to terminate.  The document
@var{doc} should be considered invalid.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t unreachable_obj;

pdf_obj_integer_new (doc, PDF_TRUE, 10, &unreachable_obj);

/* Garbage-collect the document and save its
   content. */
if (pdf_obj_doc_gc (doc) != PDF_ERROR)
@{
   /* 'unreachable_obj' has been collected and its value is now
      undefined. */
@}
else
@{
   /* The collector failed and the document in 'doc' should be
      considered invalid. */
@}
@end example
@end table
@end deftypefun

@node Document Layer
@chapter Document Layer

@node Page Contents Layer
@chapter Page Contents Layer

@node Implementation Limits
@chapter Implementation Limits

The limits documented in this chapter are not imposed by neither of
the supported PDF specifications, but by this specific
implementation.

In no case the implementation limits are violating the PDF
specifications.

@menu
* Architectural limits::
* Memory limits::
@end menu

@node Architectural limits
@section Architectural limits

@multitable @columnfractions .20 .15 .65
@headitem Quantity @tab Limit @tab Description
@item Size of a PDF file
@tab 10^10 bytes
@tab Largest supported PDF file using a cross-reference table.
@item integer
@tab 2147483647
@tab Largest integer value.
@item integer
@tab -2147483647-1
@tab Smallest integer value.
@item real
@tab FLT_MAX
@tab Largest real value.
@item real
@tab -FLT_MAX
@tab Smallest real value.
@item string in content stream
@tab SIZE_MAX/2
@tab Maximum length of a string contained in a content stream, in
bytes.
@item name
@tab 32768
@tab Maximum length of a name, in bytes.
@item indirect object
@tab ??
@tab Maximum number of indirect objects in a PDF file.
@item content stream objects
@tab 2^32
Maximum number of objects in a content stream.
@item linked content stream objects
@tab 2^32
Maximum number of objects in linked content streams.
@end multitable

@node Memory limits
@section Memory limits

TBC.


@c FDL
@c ===

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi


@c The indexes
@c ===========

@node Global variable index
@unnumbered Global variable index

@printindex vr

@node Data type index
@unnumbered Data type index

@printindex tp

@node Function index
@unnumbered Function index

@printindex fn


@bye
