\input texinfo
@comment $Id: $
@comment %**start of header
@setfilename gnupdf-hg.info
@settitle GNU PDF Library Hackers Guide
@comment %**end of header

@include version.texi

@copying
This is the @cite{GNU PDF Library Hackers Guide},
updated for @strong{libgnupdf} version @strong{@value{VERSION}}.

Copyright @copyright{} 2008 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@sp 6
@center @titlefont{GNU PDF Library Hackers Guide}
@sp 4
@center Updated for version @value{VERSION}.
@sp 5
@page Free Software Foundation
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU PDF Library Hackers Guide

GNU PDF Library Hackers Guide

@insertcopying
@end ifnottex

@menu
* Information for Newcomers::
* The build system::
* Tasks management::
* Coding Conventions::
* Sending Patches::
* Writing Tests::
@end menu

@node Information for Newcomers
@chapter Information for Newcomers

First of all, many thanks for your interest in collaborate in the development!
Here you will find some useful information to get started. 

@table @strong
@item Getting a copy of the sources

The first step to perform is to get a local copy of the development
sources. Just install a GNU Bazaar client and issue the following
commands.

To get the sources of the GNU PDF Library from the trunk:

@example
$ bzr branch http://bzr.savannah.gnu.org/r/pdf/libgnupdf/branches/trunk
@end example

@item Getting familiar with GNU Bazaar

We are using the GNU Bazaar @footnote{http://bazaar-vcs.org} version
control system. Before to be able to contribute code to this project
you should get familiar to the usage of Bazaar.

The GNU Bazaar User Guide
@footnote{http://doc.bazaar-vcs.org/bzr.dev/en/user-guide/index.html}
is very good. In the Bazaar site (http://www.bazaar-vcs.org)
you will also find useful tips for people coming from other VCSs such
as CVS or subversion.

@item Subscribing to the development mailing list

GNU PDF developers communicate using the @email{pdf-devel@@gnu.org}
mailing list. Most of the work in the development is discussed there,
so you definitely want to subscribe to it if you are going to do
development work.

Goto the pdf-devel mailman web interface in
@url{http://lists.gnu.org/mailman/listinfo/pdf-devel} and set up your
subscription. Then, send a first email saying "Hello" :)

@item Getting familiar with Savannah

Savannah is the central point of development for GNU software. The GNU
PDF project has a savannah project in
@url{http://savannah.gnu.org/projects/pdf}

@item Getting familiar with the library

Take a look to the design of the library and the source code. If you
have doubts about any aspect of the library or the implementation,
just ask to pdf-devel.

@item Getting familiar with the GNU standards

The GNU PDF Library is a GNU package. That means we should follow the
GNU Standards to ensure quality and compatibility with other parts of
the GNU Operating System.

You should be familiar with the GNU Coding Standards before to write
code for the GNU PDF library. You can read it online in
@url{http://www.gnu.org/prep/standards}.

@item Getting familiar with our coding conventions

Read our Hackers Guide (this very document) for several conventions we
use when writing source code.

@item Taking a task to work on

Please read the documentation on tasks management in FIXME:xref.

If you want to work in a NEXT task, please be sure to state your
interest in the gnu-devel mailing list before. The developers in the
pdf-devel mailing list can guide you towards the more convenient task
for you to take and can give valuable advice about how to implement
it.

@item Getting an account for the wiki

It is quite important to write down the design of the code you write
for the project. So if you are going to write code please ask the
maintainer @footnote{@email{pdf-maintainer@@gnu.org}} for an account in
gnupdf.org.

@item Signing papers

The GNU PDF codebase is copyrighted by the Free Software
Foundation. It is a way to strength the GPL. That means that we need
you to sign papers before to be able to integrate your code in the
distribution. There are several ways to get this done. Please ask the
maintainer for the details.

@item Sending patches for inclusion

If you have written a patch you want to be included in GNU PDF, please
send it to the pdf-devel mailing list. Your patch will be then
discussed and maybe accepted.

@end table


@node The build system
@chapter The build system

The build system of the GNU PDF software uses the GNU build utilities
(otherwise known as the GNU Autotools). This chapter contains some
guidelines to apply when incorporating changes into the codebase.

@menu
* Third-party m4 macros::
@end menu

@node Third-party m4 macros
@section Third-party m4 macros

Sometimes it is useful to use third-party m4 macros provided by some
build dependency (such as libgcrypt that provides an
@code{AM_PATH_LIBGCRYPT} macro).

In that situation we are introducing a dependency in @emph{bootstrap}
time, and it is not desirable: the dependencies should be checked in
@emph{configure} time.

Any third-party m4 file should be copied in @file{libgnupdf/m4/} and
put under version control. In that way we avoid the dependency in
@emph{bootstrap} time.

@node Tasks management
@chapter Tasks management

This chapter contains information about the tasks management we use in
the development of the GNU PDF Library.

@menu
* The tasks pool::
* Task originators::
* Task types::
* Tasks workflow::
* The flyspray task manager::
@end menu

@node The tasks pool
@section The tasks pool

The real tasks being worked out in the project are contained in what
we call the tasks pool.

The tasks pool contain a set of tasks that should be performed out by
some agent. The pool do not contain all the tasks for the project:
there is an approximation in the project plan. Instead there is a
constant flow of tasks being introduced in the pool by originators and
being consumed out by the developers. That means that when a task is
performed by a developer it is pulled out of the pool and archived.

An archived task can be reactivated and inserted again in the tasks
pool.

@float Figure,fig:tasks-pool
@image{figures/tasks-pool}
@caption{The tasks pool}
@end float

A task is attributed with a priority while it is into the tasks
pool. The priority is a number between 1 (less priority) to 9 (higher
priority). Some priority levels have names:

@itemize @bullet
@item 1 - Later
@item 2
@item 3 - Low
@item 4
@item 5 - Normal
@item 6
@item 7 - High
@item 8
@item 9 - Immediate
@end itemize

@quotation Note
The maintainer may change the priority of a task to avoid it
to starve.
@end quotation

@quotation Note
A reactivated task gets a new priority number when it is
reinserted into the tasks pool.
@end quotation

@node Task originators
@section Task originators

There are several possible originators of tasks:

@table @strong
@item The maintainer
The maintainer is the responsible of maintaining the tasks pool,
introducing new tasks when needed and setting the priorities. The
source of the tasks is either the project plan, bug reports or
reactivated tasks.
@item Cron jobs running in gnupdf.org
There are several cron jobs running in gnupdf.org that perform checks
on a nightly build of the sources and executes the unit tests. These
jobs can automatically generate new tasks to fix some problem (a high
cyclomatic complexity in a module or a fail in a test case).
@end table

@node Task types
@section Task types

We distinguish between some types of tasks. Each task type has an
initial priority defined:

@multitable @columnfractions .25 .25 .25 .25
@headitem task type @tab originator @tab source @tab initial priority
@item @strong{planned task}
@tab maintainer
@tab project plan
@tab 5 (Normal)
@item @strong{sporadic task}
@tab maintainer
@tab bug report
@tab 4
@item @strong{automatic task}
@tab gnupdf.org
@tab test fail or bad software metric
@tab 6
@end multitable

@node Tasks workflow
@section Tasks workflow

The following diagram depicts the possible states for a task and the
allowed transitions between states:

@float Figure,fig:tasks-workflow
@image{figures/tasks-workflow}
@caption{Tasks workflow}
@end float

@table @strong
@item TODO
The task is into the tasks pool but it not ready to be performed.
@item NEXT
The task is into the tasks pool and it is ready to be performed by a
developer.
@item STARTED
The task has been started by a developer but it is not finished.
@item DONE
The task is archived and succesfully performed. 
@item DISCARDED
The task is archived but it has been discarded.
@end table

@node The flyspray task manager
@section The flyspray task manager

We use a flyspray task tracker installed in
@url{http://gnupdf.org/flyspray} in order to implement the tasks pool.

Each flyspray task has the following attributes:

@table @strong
@item Type
The type of the task:
@itemize @minus
@item planned
@item sporadic
@item automatic
@end itemize
@item Category
he context of the task. It may be the name of a library layer (such as
base layer), the name of a library module or a more general context
(such as build system).
@item Priority
The priority of the task. 
@item Status
The status of the task:
@itemize @minus
@item TODO
@item NEXT
@item STARTED
@item DONE
@item DISCARDED.
@end itemize
@item Summary
A summary of the task.
@end table

@node Coding Conventions
@chapter Coding Conventions

Like in any other GNU package, the code in the GNU PDF Library follows
the coding conventions documented in the GNU Coding Standards. 

In this section we complement the guidelines of the GHM with some
specific conventions that we follow in the development of the
library. It is quite important to follow these guidelines to maintain
a good level of coherence in the codebase.

@menu
* File Headers::
* Spaces vs. Tabs::
* Naming Functions::
* Abstract Data Types::
@end menu

@node File Headers
@section File Headers

The standard file header to be used in any source file in the library
is the following:

@example
/* -*- mode: C -*- Time-stamp: TIME_STAMP
 *
 *       File:         FILE_NAME
 *       Date:         CREATION_TIME
 *
 *       GNU PDF Project - SHORT_DESCRIPTION
 *
 */
@end example

The entries in the template are:

@table @var
@item TIME_STAMP
This is a time stamp with the format: 
@example
YYYY-MM-DD hh:mm:ss nickname
@end example
Note that if you are writing your code using Emacs then you will get
the timestamp automatically updated each time you save the file.
@item FILE_NAME
The basename of the file.
@item CREATION_TIME
A time stamp string in the format:
@example
Fri Feb 22 21:05:05 2008
@end example
Note that if you are writing your code using Emacs then you will get
the appropriate creation date running the @code{current-time-string}
elisp command. If you are using the @code{gnupdf-c-file-header}
skeleton template then you will get the creation date in
template-expansion time.
@item SHORT_DESCRIPTION
A one-sentence brief description of the contents of the file. This
description should not exceed one physical line of text.
@end table

@node Spaces vs. Tabs
@section Spaces vs. Tabs

It is preferable to use blank characters instead of tabs to indent the
source code: the interpretation of the actual width of a tab is up to
the viewer program.

Please use blank characters when writing code to be included in GNU
PDF software. 

If you use Emacs you can tell it to insert spaces instead of tabs
including:

@example
(setq-default indent-tabs-mode nil)
@end example

in your @file{.emacs}.

If you use GNU indent to indent your sources you can use the
@code{--nut} option:

@example
$ indent --nut [rest-of-parameters] [source-files]
@end example

@node Naming Functions
@section Naming Functions

@menu
* Public functions in a module::
* Private functions in a module::
* Platform specific functions::
@end menu

@node Public functions in a module
@subsection Public functions in a module

All the public functions inside a module should use the following name
convention:

@example
pdf_MODULE-NAME_...
@end example

where @var{module-name} is the canonical name of the module
(e.g. @code{alloc} or @code{text}).

Some modules are composed by more than one compilation unit. In that
case the public functions should follow the following name convention:

@example
pdf_MODULE-NAME_PART-NAME_...
@end example

where @var{part-name} is the canonical name of that part of the module
implementation (e.g. @code{pdf_stm_filter_...} where @code{filter} is
the part name.

@node Private functions in a module
@subsection Private functions in a module

The private (``static'') functions used in a module implementation
should follow the same naming conventions as the public ones.

@node Platform specific functions
@subsection Platform specific functions

The names for functions (both public and private) intended to be used
if compiling for a specific platform should use the following name
convention:

@example
pdf_MDULE-NAME[_PART-NAME]_PLATFORM_...
@end example

where @code{platform} is the canonical name for the target platform:

@table @code
@item gnu
For GNU systems.
@item posix
For POSIX systems.
@item win32
For Windows systems.
@item macos
For Macos X systems.
@end table

@node Abstract Data Types
@section Abstract Data Types

The GNU PDF Library codebase is written using the C programming
language. C does not support the notion of @emph{object} as used in
object-oriented programming. 

Instead of objects we are using a kind of data-control abstraction
called @emph{abstract data types}. This abstraction provides high
encapsulation of the implementation details of the data types and thus
allow the definition of @emph{opaque} types.

An @acronym{ADT} is composed by:

@itemize @bullet
@item
A @emph{data structure} containing the private data that characterizes
each instance of the @acronym{ADT}.
@item
A set of @emph{access functions} that implement actions on the
@acronym{ADT}.
@end itemize

@menu
* Implementation Files For ADTs::
* Data Structures For ADTs::
* Access Functions For ADTs::
@end menu

@node Implementation Files For ADTs
@subsection Implementation Files For ADTs

Each Abstract Data Type shall be implemented in source files following
this naming convention:

@example
pdf-FOO-*.[ch]
@end example

where @var{FOO} is the name of the @acronym{ADT}; for example,
@file{pdf-text-context.c}.

A general header file for the @acronym{ADT} should always be present
and should be named after:

@example
pdf-FOO.h
@end example

where @var{FOO} is again the name of the @acronym{ADT}; for example,
@file{pdf-text.h}.

@node Data Structures For ADTs
@subsection Data Structures For ADTs

There are two different approaches that shall be used to define the
data structures containing the private data for an @acronym{ADT}:

@table @strong
@item A pointer to a structure
In this case a C structure should be defined to hold the private data:
@example
/* Definition of the pdf_foo_t ADT */
struct pdf_foo_s
@{
   int data_a;
   int data_b;
@};
@end example
and then a typedef that defines @code{pdf_foo_t} as a pointer to that
structure:
@example
typedef struct pdf_foo_s *pdf_foo_t;
@end example
@item A structure
In this case a C structure (not a pointer to it) is used to represent
the @acronym{ADT}:
@example
typedef struct pdf_foo_s pdf_foo_t;
@end example
This alternative is indicated in the case where the private data of
the @acronym{ADT} is small, allowing the developer to allocate
instances of the @acronym{ADT} in the stack and thus avoiding
fragmentation of the heap.
@end table

Note that both alternatives allow to copy a @strong{reference} using
the C assignation operator, like in:

@example
reference_to_adt_instance1 = adt_instance1;
@end example

@node Access Functions For ADTs
@subsection Access Functions For ADTs

Every access function implemented by an @acronym{ADT} should have a
prototype conformant to the following convention:

@example
RETURN_TYPE pdf_FOO_* (pdf_FOO_t adt, args...)
@end example

where @var{FOO} is the name of the @acronym{ADT}.

The following standard functions shall be defined:

@table @code
@item pdf_status_t pdf_FOO_new (args..., pdf_FOO_t *adt)
This is the function used to create a new instance of the
@acronym{ADT}. The last parameter of the function should be a pointer
to a @code{pdf_FOO_t} value. The returned status value should indicate
the state of the operation.
@item pdf_FOO_destroy (pdf_FOO_t adt)
This is the function used to destroy an instance of the
@acronym{ADT}. The memory occupied by the @acronym{ADT} data structure
is freed.
@end table

@node Sending Patches
@chapter Sending Patches

This chapter contains some useful information to send patches to be
integrated in the trunk.

@menu
* Documenting Your Changes::
* Generating a Bazaar Merge Directive::
* Syntax Check::
* Patch Safety Dispatcher::
@end menu

@node Documenting Your Changes
@section Documenting Your Changes

Everyone loves documentation! :D

If your change includes new files please update the
@file{MANIFEST.wiki} in the directory containing the new files.

If your change is not trivial please take a look to the appropriate
architecture page in the wiki. Maybe it is needed to update the page
with more information?

@node Generating a Bazaar Merge Directive
@section Generating a Bazaar Merge Directive

The Bazaar version control system supports the notion of @emph{merge
directives}. A merge directive is a kind of ``superpatch'' that contain
an ascii-encoded binary block describing the patch (changes to file
contents, addition of new files, etc) and a preview that is much like
a regular diff.

A merge directive can be merged into a given branch much like any
other branch.

To create a merge directive out of your bazaar branch just type the
following command:

@example
$ bzr send -o my-patch
@end example

Then send the file @file{my-patch} in an email to
@email{pdf-devel@@gnu.org} in order to be reviewed by the development
team.

Note that you dont need to specify extra parameters to the @code{bzr
send} command: it will use the appropriate format for the patch by
default (unidiff).

@node Syntax Check
@section Syntax Check

The maintainer-makefile gnulib module provides some more make targets,
useful for the maintainership of the package.

One of the targets is 'syntax-check'. It performs a check of common
pitfalls on the source code and GCS conformance.

Please do a make syntax-check before to send a patch, or alternatively
use the Patch Safety Dispatcher (see the next section).


@node Patch Safety Dispatcher
@section Patch Safety Dispatcher

Before sending a patch to the list to be included in the trunk you
can run the patch safety dispatcher, which is a script that runs a
few more scripts, like the syntax check mentioned in this chapter.

In fact, the Patch Safety Dispatcher is a bzr plugin that is run before a
commit is applied to your working copy.
In order to execute it you need to tell bzr where the plugin is
located. There are two ways to do it:

1. Copy the script located in ``prmgt/patch-safety-dispatcher.py'' at
the projects root directory to your bazaar plugins directory
``~/.bazaar/plugins''.

2. Add the ``prmgt'' directory to the BZR_PLUGIN_PATH variable. For
example, doing ``export BZR_PLUGIN_PATH=/your/path/to/libgnupdf/prmgt''
(alternatively you can add it to your ~/.bashrc).

After telling bzr where your plugins are, you can test it doing: ``bzr
hooks'' (from the projects root directory) . You should find it in the
list as ``Patch safety scripts hook'' in the pre_commit section.

That's all. Now when you do a ``bzr commit'' a small report will tell if
your patch is correct in terms of the QA scripts we run daily.
If it is the commit will be applied, otherwise it won't.

NOTE: Make sure you run ``bzr commit'' from your working copy root
directory.  Bazaar will fail with some error or don't even run the
script otherwise. Until now we have no solution for this problem.

@node Writing Tests
@chapter Writing Tests

@menu
* Test Data Files::
* The tortutils Library::
@end menu

@node Test Data Files
@section Test Data Files

Some tests require the use of data files:

@itemize @minus
@item to hold input for the software under test
@item to hold output to be compared with the output of the software under test
@end itemize

Since we are not distributing the test data files with the source
distribution, neither they are stored in the bazaar repository, we
need to download a tarball
@url{http://www.gnupdf.org/prmgt/testdata/gnupdf-testdata-RELEASE.tar.gz},
where @var{release} is the version of the library or @file{trunk}.

After downloaded the data files should be untarred in the
@file{torture/testadata/} directory.

The easiest way to get the test data files is by using the
@file{prmgt/get-test-data.sh} script, that will download and install
the data files tarball matching the appropriate release.

The test data files are documented in the ``Test Data Files'' chapter
in the Test Specification Document.

@node The tortutils Library
@section The tortutils Library

The ``torture utils'' library provides several utility functions that
can be used while writing tests.

See @file{torture/tortutils/tortutils.h} for documentation on the
functions provided by the library.

@bye
