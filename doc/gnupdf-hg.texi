\input texinfo
@comment $Id: $
@comment %**start of header
@setfilename gnupdf-hg.info
@settitle GNU PDF Library Hackers Guide
@comment %**end of header

@set VERSION 0.1

@copying
This is the @cite{GNU PDF Library Hackers Guide},
updated for @strong{libgnupdf} version @strong{@value{VERSION}}.

Copyright @copyright{} 2008 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@sp 6
@center @titlefont{GNU PDF Library Hackers Guide}
@sp 4
@center Updated for version @value{VERSION}.
@sp 5
@page Free Software Foundation
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU PDF Library Hackers Guide

GNU PDF Library Hackers Guide

@insertcopying
@end ifnottex

@menu
* Coding Conventions::
* Sending Patches::
@end menu

@node Coding Conventions
@chapter Coding Conventions

Like in any other GNU package, the code in the GNU PDF Library follows
the coding conventions documented in the GNU Coding Standards. 

In this section we complement the guidelines of the GHM with some
specific conventions that we follow in the development of the
library. It is quite important to follow these guidelines to maintain
a good level of coherence in the codebase.

@menu
* File Headers::
* Naming Functions::
@end menu

@node File Headers
@section File Headers

The standard file header to be used in any source file in the library
is the following:

@example
/* -*- mode: C -*- Time-stamp: TIME_STAMP
 *
 *       File:         FILE_NAME
 *       Date:         CREATION_TIME
 *
 *       GNU PDF Project - SHORT_DESCRIPTION
 *
 */
@end example

The entries in the template are:

@table @var
@item TIME_STAMP
This is a time stamp with the format: 
@example
YYYY-MM-DD hh:mm:ss nickname
@end example
Note that if you are writing your code using Emacs then you will get
the timestamp automatically updated each time you save the file.
@item FILE_NAME
The basename of the file.
@item CREATION_TIME
A time stamp string in the format:
@example
Fri Feb 22 21:05:05 2008
@end example
Note that if you are writing your code using Emacs then you will get
the appropriate creation date running the @code{current-time-string}
elisp command. If you are using the @code{gnupdf-c-file-header}
skeleton template then you will get the creation date in
template-expansion time.
@item SHORT_DESCRIPTION
A one-sentence brief description of the contents of the file. This
description should not exceed one physical line of text.
@end table

@node Naming Functions
@section Naming Functions

@menu
* Public functions in a module::
* Private functions in a module::
* Platform specific functions::
@end menu

@node Public functions in a module
@subsection Public functions in a module

All the public functions inside a module should use the following name
convention:

@example
pdf_MODULE-NAME_...
@end example

where @var{module-name} is the canonical name of the module
(e.g. @code{alloc} or @code{text}).

Some modules are composed by more than one compilation unit. In that
case the public functions should follow the following name convention:

@example
pdf_MODULE-NAME_PART-NAME_...
@end example

where @var{part-name} is the canonical name of that part of the module
implementation (e.g. @code{pdf_stm_filter_...} where @code{filter} is
the part name.

@node Private functions in a module
@subsection Private functions in a module

The private (``static'') functions used in a module implementation
should follow the same naming conventions as the public ones.

@node Platform specific functions
@subsection Platform specific functions

The names for functions (both public and private) intended to be used
if compiling for a specific platform should use the following name
convention:

@example
pdf_MDULE-NAME[_PART-NAME]_PLATFORM_...
@end example

where @code{platform} is the canonical name for the target platform:

@table @code
@item gnu
For GNU systems.
@item posix
For POSIX systems.
@item win32
For Windows systems.
@item macos
For Macos X systems.
@end table

@node Sending Patches
@chapter Sending Patches

This chapter contains some useful information to send patches to be
integrated in the trunk.

@menu
* Syntax Check::
* Patch Safety Dispatcher::
@end menu

@node Syntax Check
@section Syntax Check

The maintainer-makefile gnulib module provides some more make targets,
useful for the maintainership of the package.

One of the targets is 'syntax-check'. It performs a check of common
pitfalls on the source code and GCS conformance.

Please do a make syntax-check before to send a patch, or alternatively
use the Patch Safety Dispatcher (see the next section).


@node Patch Safety Dispatcher
@section Patch Safety Dispatcher

Before sending a patch to the list to be included in the trunk you
can run the patch safety dispatcher, which is a script that runs a
few more scripts, like the syntax check mentioned in this chapter.

In fact, the Patch Safety Dispatcher is a bzr plugin that is run before a
commit is applied to your working copy.
In order to execute it you need to tell bzr where the plugin is
located. There are two ways to do it:

1. Copy the script located in ``prmgt/patch-safety-dispatcher.py'' at
the projects root directory to your bazaar plugins directory
``~/.bazaar/plugins''.

2. Add the ``prmgt'' directory to the BZR_PLUGIN_PATH variable. For
example, doing ``export BZR_PLUGIN_PATH=/your/path/to/libgnupdf/prmgt''
(alternatively you can add it to your ~/.bashrc).

After telling bzr where your plugins are, you can test it doing: ``bzr
hooks'' (from the projects root directory) . You should find it in the
list as ``Patch safety scripts hook'' in the pre_commit section.

That's all. Now when you do a ``bzr commit'' a small report will tell if
your patch is correct in terms of the QA scripts we run daily.
If it is the commit will be applied, otherwise it won't.

NOTE: Make sure you run ``bzr commit'' from your working copy root
directory.  Bazaar will fail with some error or don't even run the
script otherwise. Until now we have no solution for this problem.

@bye
